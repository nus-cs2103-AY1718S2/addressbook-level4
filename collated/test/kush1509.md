# kush1509
###### \data\XmlAddressBookStorageTest\invalidAndValidJobAddressBook.xml
``` xml

<addressbook>
    <!-- Valid Job -->
    <jobs>
        <position>Software Engineer</position>
        <team>Cloud Services</team>
        <location>Singapore</location>
        <numberOfPositions>2</numberOfPositions>
        <tagged>Java</tagged>
        <tagged>Algorithms</tagged>
    </jobs>
    <!-- Job with invalid number of positions field -->
    <jobs>
        <position>Software Engineer</position>
        <team>Cloud Services</team>
        <location>Singapore</location>
        <numberOfPositions>abc12</numberOfPositions>
        <tagged>Java</tagged>
        <tagged>Algorithms</tagged>
    </jobs>
</addressbook>
```
###### \data\XmlAddressBookStorageTest\invalidJobAddressBook.xml
``` xml

<addressbook>
    <!-- Job with invalid position field -->
    <jobs>
        <position>Softwar& Engineer@</position>
        <team>Cloud Services</team>
        <location>Singapore</location>
        <numberOfPositions>2</numberOfPositions>
        <tagged>Java</tagged>
        <tagged>Algorithms</tagged>
    </jobs>
</addressbook>
```
###### \data\XmlSerializableAddressBookTest\invalidJobAddressBook.xml
``` xml

<addressbook>
    <!-- Job with invalid position field -->
    <jobs>
        <position>Softwar& Engineer@</position>
        <team>Cloud Services</team>
        <location>Singapore</location>
        <numberOfPositions>2</numberOfPositions>
        <tagged>Java</tagged>
        <tagged>Algorithms</tagged>
    </jobs>
</addressbook>
```
###### \data\XmlSerializableAddressBookTest\typicalJobsAddressBook.xml
``` xml
<!-- AddressBook save file which contains the same Job values as in
{@code TypicalJobs#getTypicalAddressBook()}-->
<addressbook>
    <jobs>
        <position>Software Engineer</position>
        <team>Cloud Services</team>
        <location>Singapore</location>
        <numberOfPositions>2</numberOfPositions>
        <tagged>Java</tagged>
        <tagged>Algorithms</tagged>
    </jobs>
    <jobs>
        <position>Marketing Intern</position>
        <team>Marketing</team>
        <location>Kuala Lampur, Malaysia</location>
        <numberOfPositions>1</numberOfPositions>
        <tagged>Excel</tagged>
        <tagged>Writing</tagged>
    </jobs>
    <jobs>
        <position>DevOps Engineer</position>
        <team>DevOps</team>
        <location>Singapore</location>
        <numberOfPositions>3</numberOfPositions>
        <tagged>AWS</tagged>
        <tagged>SQL-Server</tagged>
    </jobs>
    <jobs>
        <position>Product Manager</position>
        <team>Mobile Products</team>
        <location>India</location>
        <numberOfPositions>1</numberOfPositions>
        <tagged>UI/UX</tagged>
        <tagged>Testing</tagged>
    </jobs>
    <skills>Java</skills>
    <skills>Algorithms</skills>
    <skills>Excel</skills>
    <skills>Writing</skills>
    <skills>AWS</skills>
    <skills>SQL-Server</skills>
    <skills>UI/UX</skills>
    <skills>Testing</skills>
</addressbook>
```
###### \data\XmlUtilTest\invalidJobField.xml
``` xml
<job>
    <position>Software% Engineer**</position>
    <team>Cloud Services</team>
    <location>Singapore</location>
    <numberOfPositions>2</numberOfPositions>
    <tagged>Java</tagged>
</job>
```
###### \data\XmlUtilTest\invalidPersonField.xml
``` xml
<!-- Person with an invalid phone field -->
<person>
    <name>Hans Muster</name>
    <phone>9482asf424</phone>
    <email>hans@example</email>
    <address>4th street</address>
    <currentPosition>Software Engineer</currentPosition>
    <company>Google</company>
    <profilePicture>./src/test/data/images/hans.jpeg</profilePicture>
    <tagged>Java</tagged>
</person>
```
###### \data\XmlUtilTest\missingJobField.xml
``` xml
<job>
    <team>Cloud Services</team>
    <location>Singapore</location>
    <numberOfPositions>2</numberOfPositions>
    <tagged>Java</tagged>
</job>
```
###### \data\XmlUtilTest\validJob.xml
``` xml
<job>
    <position>Software Engineer</position>
    <team>Cloud Services</team>
    <location>Singapore</location>
    <numberOfPositions>2</numberOfPositions>
    <tagged>Java</tagged>
</job>
```
###### \java\guitests\guihandles\ContactDetailsDisplayHandle.java
``` java
package guitests.guihandles;

import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;

/**
 * A handle to the {@code ContactDetailsDisplay} in the GUI.
 */
public class ContactDetailsDisplayHandle extends NodeHandle<Node> {

    private static final String NAME_FIELD_ID = "#name";
    private static final String LIST_ID = "#values";
    //TODO: include Tags

    private final Label nameLabel;
    private final ListView<Label> valuesList;

    public ContactDetailsDisplayHandle(Node contactDetailsDisplayNode) {
        super(contactDetailsDisplayNode);

        this.nameLabel = getChildNode(NAME_FIELD_ID);
        this.valuesList = getChildNode(LIST_ID);
    }

    public String getName() {
        return nameLabel.getText();
    }

    public String getFullName() {
        return valuesList.getItems().get(0).getText();
    }

    public String getPhone() {
        return valuesList.getItems().get(1).getText();
    }

    public String getEmail() {
        return valuesList.getItems().get(2).getText();
    }

    public String getAddress() {
        return valuesList.getItems().get(3).getText();
    }
}
```
###### \java\guitests\guihandles\DetailsPanelHandle.java
``` java
package guitests.guihandles;

import javafx.scene.control.TabPane;

/**
 * A handle to the {@code DetailsPanelHandle} in the GUI.
 */
public class DetailsPanelHandle extends NodeHandle<TabPane> {

    public DetailsPanelHandle(TabPane detailsPanel) {
        super(detailsPanel);
    }

    public int getCurrentTab() {
        return getRootNode().getSelectionModel().getSelectedIndex();
    }
}
```
###### \java\guitests\guihandles\JobCardHandle.java
``` java
package guitests.guihandles;

import java.util.List;
import java.util.stream.Collectors;

import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.Region;

/**
 * Provides a handle to a job card in the job list panel.
 */
public class JobCardHandle extends NodeHandle<Node> {
    private static final String ID_FIELD_ID = "#id";
    private static final String POSITION_FIELD_ID = "#position";
    private static final String TEAM_FIELD_ID = "#team";
    private static final String LOCATION_FIELD_ID = "#jobLocation";
    private static final String NUMBER_OF_POSITIONS_FIELD_ID = "#numberOfPositions";
    private static final String TAGS_FIELD_ID = "#skills";

    private final Label idLabel;
    private final Label positionLabel;
    private final Label teamLabel;
    private final Label locationLabel;
    private final Label numberOfPositionsLabel;
    private final List<Label> tagLabels;

    public JobCardHandle(Node cardNode) {
        super(cardNode);

        this.idLabel = getChildNode(ID_FIELD_ID);
        this.positionLabel = getChildNode(POSITION_FIELD_ID);
        this.teamLabel = getChildNode(TEAM_FIELD_ID);
        this.locationLabel = getChildNode(LOCATION_FIELD_ID);
        this.numberOfPositionsLabel = getChildNode(NUMBER_OF_POSITIONS_FIELD_ID);

        Region tagsContainer = getChildNode(TAGS_FIELD_ID);
        this.tagLabels = tagsContainer
                .getChildrenUnmodifiable()
                .stream()
                .map(Label.class::cast)
                .collect(Collectors.toList());
    }

    public String getId() {
        return idLabel.getText();
    }

    public String getPosition() {
        return positionLabel.getText();
    }

    public String getTeam() {
        return teamLabel.getText();
    }

    public String getLocation() {
        return locationLabel.getText();
    }

    public String getNumberOfPositions() {
        return numberOfPositionsLabel.getText();
    }

    public List<String> getSkills() {
        return tagLabels
                .stream()
                .map(Label::getText)
                .collect(Collectors.toList());
    }

    public List<String> getSkillStyleClasses(String tag) {
        return tagLabels
                .stream()
                .filter(label -> label.getText().equals(tag))
                .map(Label::getStyleClass)
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("No such skill."));
    }
}
```
###### \java\guitests\guihandles\JobListPanelHandle.java
``` java
package guitests.guihandles;

import java.util.List;
import java.util.Optional;

import javafx.scene.control.ListView;
import seedu.address.model.job.Job;
import seedu.address.ui.JobCard;

/**
 * Provides a handle for {@code JobListPanel} containing the list of {@code JobCard}.
 */
public class JobListPanelHandle extends NodeHandle<ListView<JobCard>> {
    public static final String JOB_LIST_VIEW_ID = "#jobListView";

    private Optional<JobCard> lastRememberedSelectedJobCard;

    public JobListPanelHandle(ListView<JobCard> jobListPanelNode) {
        super(jobListPanelNode);
    }

    /**
     * Returns a handle to the selected {@code JobCardHandle}.
     * A maximum of 1 item can be selected at any time.
     * @throws AssertionError if no card is selected, or more than 1 card is selected.
     */
    public JobCardHandle getHandleToSelectedCard() {
        List<JobCard> jobList = getRootNode().getSelectionModel().getSelectedItems();

        if (jobList.size() != 1) {
            throw new AssertionError("Job list size expected 1.");
        }

        return new JobCardHandle(jobList.get(0).getRoot());
    }

    /**
     * Returns the index of the selected card.
     */
    public int getSelectedCardIndex() {
        return getRootNode().getSelectionModel().getSelectedIndex();
    }

    /**
     * Returns true if a card is currently selected.
     */
    public boolean isAnyCardSelected() {
        List<JobCard> selectedCardsList = getRootNode().getSelectionModel().getSelectedItems();

        if (selectedCardsList.size() > 1) {
            throw new AssertionError("Card list size expected 0 or 1.");
        }

        return !selectedCardsList.isEmpty();
    }

    /**
     * Navigates the listview to display and select the job.
     */
    public void navigateToCard(Job job) {
        List<JobCard> cards = getRootNode().getItems();
        Optional<JobCard> matchingCard = cards.stream().filter(card -> card.job.equals(job)).findFirst();

        if (!matchingCard.isPresent()) {
            throw new IllegalArgumentException("Job does not exist.");
        }

        guiRobot.interact(() -> {
            getRootNode().scrollTo(matchingCard.get());
            getRootNode().getSelectionModel().select(matchingCard.get());
        });
        guiRobot.pauseForHuman();
    }

    /**
     * Returns the job card handle of a job associated with the {@code index} in the list.
     */
    public JobCardHandle getJobCardHandle(int index) {
        return getJobCardHandle(getRootNode().getItems().get(index).job);
    }

    /**
     * Returns the {@code JobCardHandle} of the specified {@code job} in the list.
     */
    public JobCardHandle getJobCardHandle(Job job) {
        Optional<JobCardHandle> handle = getRootNode().getItems().stream()
                .filter(card -> card.job.equals(job))
                .map(card -> new JobCardHandle(card.getRoot()))
                .findFirst();
        return handle.orElseThrow(() -> new IllegalArgumentException("Job does not exist."));
    }

    /**
     * Selects the {@code JobCard} at {@code index} in the list.
     */
    public void select(int index) {
        getRootNode().getSelectionModel().select(index);
    }

    /**
     * Remembers the selected {@code JobCard} in the list.
     */
    public void rememberSelectedJobCard() {
        List<JobCard> selectedItems = getRootNode().getSelectionModel().getSelectedItems();

        if (selectedItems.size() == 0) {
            lastRememberedSelectedJobCard = Optional.empty();
        } else {
            lastRememberedSelectedJobCard = Optional.of(selectedItems.get(0));
        }
    }

    /**
     * Returns true if the selected {@code JobCard} is different from the value remembered by the most recent
     * {@code rememberSelectedJobCard()} call.
     */
    public boolean isSelectedJobCardChanged() {
        List<JobCard> selectedItems = getRootNode().getSelectionModel().getSelectedItems();

        if (selectedItems.size() == 0) {
            return lastRememberedSelectedJobCard.isPresent();
        } else {
            return !lastRememberedSelectedJobCard.isPresent()
                    || !lastRememberedSelectedJobCard.get().equals(selectedItems.get(0));
        }
    }

    /**
     * Returns the size of the list.
     */
    public int getListSize() {
        return getRootNode().getItems().size();
    }
}
```
###### \java\seedu\address\commons\util\XmlUtilTest.java
``` java
    @Test
    public void xmlAdaptedJobFromFile_fileWithMissingJobField_validResult() throws Exception {
        XmlAdaptedJob actualJob = XmlUtil.getDataFromFile(
                MISSING_JOB_FIELD_FILE, XmlAdaptedJobWithRootElement.class);
        XmlAdaptedJob expectedJob = new XmlAdaptedJob(null, VALID_TEAM, VALID_LOCATION,
                VALID_NUMBER_OF_POSITIONS, VALID_SKILLS);
        assertEquals(expectedJob, actualJob);
    }

```
###### \java\seedu\address\commons\util\XmlUtilTest.java
``` java
    @Test
    public void xmlAdaptedJobFromFile_fileWithInvalidJobField_validResult() throws Exception {
        XmlAdaptedJob actualJob = XmlUtil.getDataFromFile(
                INVALID_JOB_FIELD_FILE, XmlAdaptedJobWithRootElement.class);
        XmlAdaptedJob expectedJob = new XmlAdaptedJob(INVALID_POSITION, VALID_TEAM, VALID_LOCATION,
                VALID_NUMBER_OF_POSITIONS, VALID_SKILLS);
        assertEquals(expectedJob, actualJob);
    }

```
###### \java\seedu\address\commons\util\XmlUtilTest.java
``` java
    @Test
    public void xmlAdaptedJobFromFile_fileWithValidJobField_validResult() throws Exception {
        XmlAdaptedJob actualJob = XmlUtil.getDataFromFile(
                VALID_JOB_FILE, XmlAdaptedJobWithRootElement.class);
        XmlAdaptedJob expectedJob = new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION,
                VALID_NUMBER_OF_POSITIONS, VALID_SKILLS);
        assertEquals(expectedJob, actualJob);
    }

```
###### \java\seedu\address\commons\util\XmlUtilTest.java
``` java
    /**
     * Test class annotated with {@code XmlRootElement} to allow unmarshalling of .xml data to {@code XmlAdaptedJob}
     * objects.
     */
    @XmlRootElement(name = "job")
    private static class XmlAdaptedJobWithRootElement extends XmlAdaptedJob {}
}
```
###### \java\seedu\address\logic\commands\job\JobAddCommandTest.java
``` java
package seedu.address.logic.commands.job;

import static seedu.address.logic.commands.CommandTestUtil.assertCommandFailure;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandSuccess;
import static seedu.address.testutil.TypicalJobs.getTypicalAddressBook;

import org.junit.Before;
import org.junit.Test;

import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.model.Account;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.job.Job;
import seedu.address.testutil.JobBuilder;

public class JobAddCommandTest {

    private Model model;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs(), new Account());
    }

    @Test
    public void execute_newJob_success() throws Exception {

        Job validJob = new JobBuilder().build();

        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs(), new Account());
        expectedModel.addJob(validJob);

        assertCommandSuccess(prepareCommand(validJob, model), model,
                String.format(JobAddCommand.MESSAGE_SUCCESS, validJob), expectedModel);
    }

    @Test
    public void execute_duplicateJob_throwsCommandException() {
        Job jobInList = model.getAddressBook().getJobList().get(0);
        assertCommandFailure(prepareCommand(jobInList, model), model, JobAddCommand.MESSAGE_DUPLICATE_JOB);
    }

    /**
     * Generates a new {@code JobAddCommand} which upon execution, adds {@code job} into the {@code model}.
     */
    private JobAddCommand prepareCommand(Job job, Model model) {
        JobAddCommand command = new JobAddCommand(job);
        command.setData(model, new CommandHistory(), new UndoRedoStack());
        return command;
    }

}
```
###### \java\seedu\address\logic\commands\job\JobDeleteCommandTest.java
``` java
package seedu.address.logic.commands.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandFailure;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandSuccess;
import static seedu.address.logic.commands.CommandTestUtil.prepareRedoCommand;
import static seedu.address.logic.commands.CommandTestUtil.prepareUndoCommand;
import static seedu.address.logic.commands.CommandTestUtil.showJobAtIndex;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND;
import static seedu.address.testutil.TypicalJobs.getTypicalAddressBook;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.model.Account;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.job.Job;

/**
 * Contains integration tests (interaction with the Model, UndoCommand and RedoCommand) and unit tests for
 * {@code JobDeleteCommand}.
 */
public class JobDeleteCommandTest {

    private Model model = new ModelManager(getTypicalAddressBook(), new UserPrefs(), new Account());

    @Test
    public void execute_validIndexUnfilteredList_success() throws Exception {
        Job jobToDelete = model.getFilteredJobList().get(INDEX_FIRST.getZeroBased());
        JobDeleteCommand jobDeleteCommand = prepareCommand(INDEX_FIRST);

        String expectedMessage = String.format(JobDeleteCommand.MESSAGE_DELETE_JOB_SUCCESS, jobToDelete);

        ModelManager expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs(), new Account());
        expectedModel.deleteJob(jobToDelete);

        assertCommandSuccess(jobDeleteCommand, model, expectedMessage, expectedModel);
    }

    @Test
    public void execute_invalidIndexUnfilteredList_throwsCommandException() throws Exception {
        Index outOfBoundIndex = Index.fromOneBased(model.getFilteredJobList().size() + 1);
        JobDeleteCommand jobDeleteCommand = prepareCommand(outOfBoundIndex);

        assertCommandFailure(jobDeleteCommand, model, Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX);
    }

    @Test
    public void execute_validIndexFilteredList_success() throws Exception {
        showJobAtIndex(model, INDEX_FIRST);

        Job jobToDelete = model.getFilteredJobList().get(INDEX_FIRST.getZeroBased());
        JobDeleteCommand jobDeleteCommand = prepareCommand(INDEX_FIRST);

        String expectedMessage = String.format(JobDeleteCommand.MESSAGE_DELETE_JOB_SUCCESS, jobToDelete);

        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs(), new Account());
        expectedModel.deleteJob(jobToDelete);
        showNoJob(expectedModel);

        assertCommandSuccess(jobDeleteCommand, model, expectedMessage, expectedModel);
    }

    @Test
    public void execute_invalidIndexFilteredList_throwsCommandException() {
        showJobAtIndex(model, INDEX_FIRST);

        Index outOfBoundIndex = INDEX_SECOND;
        // ensures that outOfBoundIndex is still in bounds of address book list
        assertTrue(outOfBoundIndex.getZeroBased() < model.getAddressBook().getJobList().size());

        JobDeleteCommand jobDeleteCommand = prepareCommand(outOfBoundIndex);

        assertCommandFailure(jobDeleteCommand, model, Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX);
    }

    @Test
    public void executeUndoRedo_validIndexUnfilteredList_success() throws Exception {
        UndoRedoStack undoRedoStack = new UndoRedoStack();
        UndoCommand undoCommand = prepareUndoCommand(model, undoRedoStack);
        RedoCommand redoCommand = prepareRedoCommand(model, undoRedoStack);
        Job jobToDelete = model.getFilteredJobList().get(INDEX_FIRST.getZeroBased());
        JobDeleteCommand jobDeleteCommand = prepareCommand(INDEX_FIRST);
        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs(), new Account());

        // delete -> first job deleted
        jobDeleteCommand.execute();
        undoRedoStack.push(jobDeleteCommand);

        // undo -> reverts addressbook back to previous state and filtered job list to show all jobs
        assertCommandSuccess(undoCommand, model, UndoCommand.MESSAGE_SUCCESS, expectedModel);

        // redo -> same first job deleted again
        expectedModel.deleteJob(jobToDelete);
        assertCommandSuccess(redoCommand, model, RedoCommand.MESSAGE_SUCCESS, expectedModel);
    }

    @Test
    public void executeUndoRedo_invalidIndexUnfilteredList_failure() {
        UndoRedoStack undoRedoStack = new UndoRedoStack();
        UndoCommand undoCommand = prepareUndoCommand(model, undoRedoStack);
        RedoCommand redoCommand = prepareRedoCommand(model, undoRedoStack);
        Index outOfBoundIndex = Index.fromOneBased(model.getFilteredJobList().size() + 1);
        JobDeleteCommand jobDeleteCommand = prepareCommand(outOfBoundIndex);

        // execution failed -> deleteCommand not pushed into undoRedoStack
        assertCommandFailure(jobDeleteCommand, model, Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX);

        // no commands in undoRedoStack -> undoCommand and redoCommand fail
        assertCommandFailure(undoCommand, model, UndoCommand.MESSAGE_FAILURE);
        assertCommandFailure(redoCommand, model, RedoCommand.MESSAGE_FAILURE);
    }

    /**
     * 1. Deletes a {@code Job} from a filtered list.
     * 2. Undo the deletion.
     * 3. The unfiltered list should be shown now. Verify that the index of the previously deleted job in the
     * unfiltered list is different from the index at the filtered list.
     * 4. Redo the deletion. This ensures {@code RedoCommand} deletes the job object regardless of indexing.
     */
    @Test
    public void executeUndoRedo_validIndexFilteredList_sameJobDeleted() throws Exception {
        UndoRedoStack undoRedoStack = new UndoRedoStack();
        UndoCommand undoCommand = prepareUndoCommand(model, undoRedoStack);
        RedoCommand redoCommand = prepareRedoCommand(model, undoRedoStack);
        JobDeleteCommand jobDeleteCommand = prepareCommand(INDEX_FIRST);
        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs(), new Account());

        showJobAtIndex(model, INDEX_SECOND);
        Job jobToDelete = model.getFilteredJobList().get(INDEX_FIRST.getZeroBased());
        // delete -> deletes second job in unfiltered job list / first job in filtered job list
        jobDeleteCommand.execute();
        undoRedoStack.push(jobDeleteCommand);

        // undo -> reverts addressbook back to previous state and filtered job list to show all jobs
        assertCommandSuccess(undoCommand, model, UndoCommand.MESSAGE_SUCCESS, expectedModel);

        expectedModel.deleteJob(jobToDelete);
        assertNotEquals(jobToDelete, model.getFilteredJobList().get(INDEX_FIRST.getZeroBased()));
        // redo -> deletes same second job in unfiltered job list
        assertCommandSuccess(redoCommand, model, RedoCommand.MESSAGE_SUCCESS, expectedModel);
    }

    @Test
    public void equals() throws Exception {
        JobDeleteCommand jobDeleteFirstCommand = prepareCommand(INDEX_FIRST);
        JobDeleteCommand jobDeleteSecondCommand = prepareCommand(INDEX_SECOND);

        // same object -> returns true
        assertTrue(jobDeleteFirstCommand.equals(jobDeleteFirstCommand));

        // same values -> returns true
        JobDeleteCommand jobDeleteFirstCommandCopy = prepareCommand(INDEX_FIRST);
        assertTrue(jobDeleteFirstCommand.equals(jobDeleteFirstCommandCopy));

        // one command preprocessed when previously equal -> returns false
        jobDeleteFirstCommandCopy.preprocessUndoableCommand();
        assertFalse(jobDeleteFirstCommand.equals(jobDeleteFirstCommandCopy));

        // different types -> returns false
        assertFalse(jobDeleteFirstCommand.equals(1));

        // null -> returns false
        assertFalse(jobDeleteFirstCommand.equals(null));

        // different person -> returns false
        assertFalse(jobDeleteFirstCommand.equals(jobDeleteSecondCommand));
    }

    /**
     * Returns a {@code JobDeleteCommand} with the parameter {@code index}.
     */
    private JobDeleteCommand prepareCommand(Index index) {
        JobDeleteCommand jobDeleteCommand = new JobDeleteCommand(index);
        jobDeleteCommand.setData(model, new CommandHistory(), new UndoRedoStack());
        return jobDeleteCommand;
    }

    /**
     * Updates {@code model}'s filtered job list to show no one.
     */
    private void showNoJob(Model model) {
        model.updateFilteredJobList(p -> false);

        assertTrue(model.getFilteredJobList().isEmpty());
    }

}
```
###### \java\seedu\address\logic\commands\job\JobFindCommandTest.java
``` java
package seedu.address.logic.commands.job;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.address.commons.core.Messages.MESSAGE_JOBS_LISTED_OVERVIEW;
import static seedu.address.testutil.TypicalJobs.DEVOPS_ENGINEER;
import static seedu.address.testutil.TypicalJobs.MARKETING_INTERN;
import static seedu.address.testutil.TypicalJobs.PRODUCT_MANAGER;
import static seedu.address.testutil.TypicalJobs.SOFTWARE_ENGINEER;
import static seedu.address.testutil.TypicalJobs.getTypicalAddressBook;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Test;

import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.logic.commands.CommandResult;
import seedu.address.model.Account;
import seedu.address.model.AddressBook;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.job.Job;
import seedu.address.model.job.PositionContainsKeywordsPredicate;

/**
 * Contains integration tests (interaction with the Model) for {@code JobFindCommand}.
 */
public class JobFindCommandTest {
    private Model model = new ModelManager(getTypicalAddressBook(), new UserPrefs(), new Account());

    @Test
    public void equals() {
        PositionContainsKeywordsPredicate firstPredicate =
                new PositionContainsKeywordsPredicate(Collections.singletonList("first"));
        PositionContainsKeywordsPredicate secondPredicate =
                new PositionContainsKeywordsPredicate(Collections.singletonList("second"));

        JobFindCommand findFirstCommand = new JobFindCommand(firstPredicate);
        JobFindCommand findSecondCommand = new JobFindCommand(secondPredicate);

        // same object -> returns true
        assertTrue(findFirstCommand.equals(findFirstCommand));

        // same values -> returns true
        JobFindCommand findFirstCommandCopy = new JobFindCommand(firstPredicate);
        assertTrue(findFirstCommand.equals(findFirstCommandCopy));

        // different types -> returns false
        assertFalse(findFirstCommand.equals(1));

        // null -> returns false
        assertFalse(findFirstCommand.equals(null));

        // different job -> returns false
        assertFalse(findFirstCommand.equals(findSecondCommand));
    }

    @Test
    public void execute_zeroKeywords_noJobFound() {
        String expectedMessage = String.format(MESSAGE_JOBS_LISTED_OVERVIEW, 0);
        JobFindCommand command = prepareCommand(" ");
        assertCommandSuccess(command, expectedMessage, Collections.emptyList());
    }

    @Test
    public void execute_multipleKeywords_multipleJobsFound() {
        String expectedMessage = String.format(MESSAGE_JOBS_LISTED_OVERVIEW, 4);
        JobFindCommand command = prepareCommand("Engineer Intern Manager");
        assertCommandSuccess(command, expectedMessage,
                Arrays.asList(SOFTWARE_ENGINEER, MARKETING_INTERN, DEVOPS_ENGINEER, PRODUCT_MANAGER));
    }

    /**
     * Parses {@code userInput} into a {@code JobFindCommand}.
     */
    private JobFindCommand prepareCommand(String userInput) {
        JobFindCommand command =
                new JobFindCommand(new PositionContainsKeywordsPredicate(Arrays.asList(userInput.split("\\s+"))));
        command.setData(model, new CommandHistory(), new UndoRedoStack());
        return command;
    }

    /**
     * Asserts that {@code command} is successfully executed, and<br>
     *     - the command feedback is equal to {@code expectedMessage}<br>
     *     - the {@code FilteredList<Job>} is equal to {@code expectedList}<br>
     *     - the {@code AddressBook} in model remains the same after executing the {@code command}
     */
    private void assertCommandSuccess(JobFindCommand command, String expectedMessage, List<Job> expectedList) {
        AddressBook expectedAddressBook = new AddressBook(model.getAddressBook());
        CommandResult commandResult = command.execute();

        assertEquals(expectedMessage, commandResult.feedbackToUser);
        assertEquals(expectedList, model.getFilteredJobList());
        assertEquals(expectedAddressBook, model.getAddressBook());
    }
}
```
###### \java\seedu\address\logic\commands\job\JobListCommandTest.java
``` java
package seedu.address.logic.commands.job;

import static seedu.address.logic.commands.CommandTestUtil.assertCommandSuccess;
import static seedu.address.logic.commands.CommandTestUtil.showJobAtIndex;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;
import static seedu.address.testutil.TypicalJobs.getTypicalAddressBook;

import org.junit.Before;
import org.junit.Test;

import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.model.Account;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;

/**
 * Contains integration tests (interaction with the Model) and unit tests for JobListCommand.
 */
public class JobListCommandTest {

    private Model model;
    private Model expectedModel;
    private JobListCommand listCommand;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs(), new Account());
        expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs(), new Account());

        listCommand = new JobListCommand();
        listCommand.setData(model, new CommandHistory(), new UndoRedoStack());
    }

    @Test
    public void execute_listIsNotFiltered_showsSameList() {
        assertCommandSuccess(listCommand, model, JobListCommand.MESSAGE_SUCCESS, expectedModel);
    }

    @Test
    public void execute_listIsFiltered_showsEverything() {
        showJobAtIndex(model, INDEX_FIRST);
        assertCommandSuccess(listCommand, model, JobListCommand.MESSAGE_SUCCESS, expectedModel);
    }
}
```
###### \java\seedu\address\logic\commands\job\JobMatchCommandTest.java
``` java
package seedu.address.logic.commands.job;

import static org.junit.Assert.assertEquals;
import static seedu.address.commons.core.Messages.MESSAGE_PERSONS_LISTED_OVERVIEW;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND;
import static seedu.address.testutil.TypicalIndexes.INDEX_THIRD;
import static seedu.address.testutil.TypicalJobsAndPersons.getTypicalAddressBook;
import static seedu.address.testutil.TypicalPersons.CARL;
import static seedu.address.testutil.TypicalPersons.ELLE;
import static seedu.address.testutil.TypicalPersons.FIONA;
import static seedu.address.testutil.TypicalPersons.GEORGE;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import seedu.address.commons.core.index.Index;
import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.logic.commands.CommandResult;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.Account;
import seedu.address.model.AddressBook;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.person.Person;
import seedu.address.ui.testutil.EventsCollectorRule;

public class JobMatchCommandTest {

    @Rule
    public final EventsCollectorRule eventsCollectorRule = new EventsCollectorRule();

    private Model model;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs(), new Account());
    }

    @Test
    public void execute_oneSkill_zeroPersonsFound() throws CommandException {
        String expectedMessage = String.format(MESSAGE_PERSONS_LISTED_OVERVIEW, 0);
        assertCommandSuccess(INDEX_THIRD, expectedMessage,  Collections.emptyList());
    }

    @Test
    public void execute_oneSkill_multiplePersonsFound() throws CommandException {
        String expectedMessage = String.format(MESSAGE_PERSONS_LISTED_OVERVIEW, 2);
        assertCommandSuccess(INDEX_FIRST, expectedMessage, Arrays.asList(FIONA, GEORGE));
    }

    @Test
    public void execute_multipleSkills_multiplePersonsFound() throws CommandException {
        String expectedMessage = String.format(MESSAGE_PERSONS_LISTED_OVERVIEW, 3);
        assertCommandSuccess(INDEX_SECOND, expectedMessage, Arrays.asList(CARL, ELLE, FIONA));
    }

    /**
     * Parses {@code userInput} into a {@code JobMatchCommand}.
     */
    private JobMatchCommand prepareCommand(Index index) {
        JobMatchCommand command = new JobMatchCommand(index);
        command.setData(model, new CommandHistory(), new UndoRedoStack());
        return command;
    }

    /**
     * Asserts that {@code command} is successfully executed, and<br>
     *     - the command feedback is equal to {@code expectedMessage}<br>
     *     - the {@code FilteredList<Person>} is equal to {@code expectedList}<br>
     *     - the {@code AddressBook} in model remains the same after executing the {@code command}
     */
    private void assertCommandSuccess(Index index, String expectedMessage, List<Person> expectedList)
            throws CommandException {

        JobMatchCommand command = prepareCommand(index);
        AddressBook expectedAddressBook = new AddressBook(model.getAddressBook());
        CommandResult commandResult = command.execute();

        assertEquals(expectedMessage, commandResult.feedbackToUser);
        assertEquals(expectedList, model.getFilteredPersonList());
        assertEquals(expectedAddressBook, model.getAddressBook());
    }

}
```
###### \java\seedu\address\logic\commands\LinkedInCommandTest.java
``` java
package seedu.address.logic.commands;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static seedu.address.logic.commands.CommandTestUtil.showPersonAtIndex;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND;
import static seedu.address.testutil.TypicalIndexes.INDEX_THIRD;
import static seedu.address.testutil.TypicalPersons.getTypicalAddressBook;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.commons.events.ui.JumpToPersonListRequestEvent;
import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.logic.commands.person.LinkedInCommand;
import seedu.address.model.Account;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.ui.testutil.EventsCollectorRule;

public class LinkedInCommandTest {

    @Rule
    public final EventsCollectorRule eventsCollectorRule = new EventsCollectorRule();

    private Model model;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs(), new Account());
    }

    @Test
    public void execute_validIndexUnfilteredList_success() {
        Index lastPersonIndex = Index.fromOneBased(model.getFilteredPersonList().size());

        assertExecutionSuccess(INDEX_FIRST);
        assertExecutionSuccess(INDEX_THIRD);
        assertExecutionSuccess(lastPersonIndex);
    }

    @Test
    public void execute_invalidIndexUnfilteredList_failure() {
        Index outOfBoundsIndex = Index.fromOneBased(model.getFilteredPersonList().size() + 1);

        assertExecutionFailure(outOfBoundsIndex, Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    @Test
    public void execute_validIndexFilteredList_success() {
        showPersonAtIndex(model, INDEX_FIRST);

        assertExecutionSuccess(INDEX_FIRST);
    }

    @Test
    public void execute_invalidIndexFilteredList_failure() {
        showPersonAtIndex(model, INDEX_FIRST);

        Index outOfBoundsIndex = INDEX_SECOND;
        // ensures that outOfBoundIndex is still in bounds of address book list
        assertTrue(outOfBoundsIndex.getZeroBased() < model.getAddressBook().getPersonList().size());

        assertExecutionFailure(outOfBoundsIndex, Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    @Test
    public void equals() {
        LinkedInCommand linkedInFirstCommand = new LinkedInCommand(INDEX_FIRST);
        LinkedInCommand linkedInSecondCommand = new LinkedInCommand(INDEX_SECOND);

        // same object -> returns true
        assertTrue(linkedInFirstCommand.equals(linkedInFirstCommand));

        // same values -> returns true
        LinkedInCommand linkedInFirstCommandCopy = new LinkedInCommand(INDEX_FIRST);
        assertTrue(linkedInFirstCommand.equals(linkedInFirstCommandCopy));

        // different types -> returns false
        assertFalse(linkedInFirstCommand.equals(1));

        // null -> returns false
        assertFalse(linkedInFirstCommand.equals(null));

        // different person -> returns false
        assertFalse(linkedInFirstCommand.equals(linkedInSecondCommand));
    }

    /**
     * Executes a {@code LinkedInCommand} with the given {@code index}, and checks that
     * {@code JumpToPersonListRequestEvent}
     * is raised with the correct index.
     */
    private void assertExecutionSuccess(Index index) {
        LinkedInCommand linkedInCommand = prepareCommand(index);

        try {
            CommandResult commandResult = linkedInCommand.execute();
            assertEquals(String.format(LinkedInCommand.MESSAGE_LINKEDIN_PERSON_SUCCESS, index.getOneBased()),
                    commandResult.feedbackToUser);
        } catch (CommandException ce) {
            throw new IllegalArgumentException("Execution of command should not fail.", ce);
        }

        JumpToPersonListRequestEvent lastEvent = (JumpToPersonListRequestEvent)
                eventsCollectorRule.eventsCollector.getMostRecent();
        assertEquals(index, Index.fromZeroBased(lastEvent.targetIndex));
    }

    /**
     * Executes a {@code LinkedInCommand} with the given {@code index}, and checks that a {@code CommandException}
     * is thrown with the {@code expectedMessage}.
     */
    private void assertExecutionFailure(Index index, String expectedMessage) {
        LinkedInCommand linkedInCommand = prepareCommand(index);

        try {
            linkedInCommand.execute();
            fail("The expected CommandException was not thrown.");
        } catch (CommandException ce) {
            assertEquals(expectedMessage, ce.getMessage());
            assertTrue(eventsCollectorRule.eventsCollector.isEmpty());
        }
    }

    /**
     * Returns a {@code LinkedInCommand} with parameters {@code index}.
     */
    private LinkedInCommand prepareCommand(Index index) {
        LinkedInCommand linkedInCommand = new LinkedInCommand(index);
        linkedInCommand.setData(model, new CommandHistory(), new UndoRedoStack());
        return linkedInCommand;
    }
}
```
###### \java\seedu\address\logic\parser\AddressBookParserTest.java
``` java
    @Test
    public void parseCommand_addJob() throws Exception {
        Job job = new JobBuilder().build();
        JobAddCommand command = (JobAddCommand) parser.parseCommand(JobUtil.getJobAddCommand(job));
        assertEquals(new JobAddCommand(job), command);
    }

```
###### \java\seedu\address\logic\parser\AddressBookParserTest.java
``` java
    @Test
    public void parseCommand_deleteJob() throws Exception {
        JobDeleteCommand command = (JobDeleteCommand) parser.parseCommand(
                JobDeleteCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased());
        assertEquals(new JobDeleteCommand(INDEX_FIRST), command);
    }

```
###### \java\seedu\address\logic\parser\AddressBookParserTest.java
``` java
    @Test
    public void parseCommand_linkedIn() throws Exception {
        LinkedInCommand command = (LinkedInCommand) parser.parseCommand(
                LinkedInCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased());
        assertEquals(new LinkedInCommand(INDEX_FIRST), command);
    }

```
###### \java\seedu\address\logic\parser\job\JobAddCommandParserTest.java
``` java
package seedu.address.logic.parser.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_LOCATION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_NUMBER_OF_POSITIONS_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_POSITION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_SKILL_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_TEAM_DESC;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.PREAMBLE_WHITESPACE;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_EXCEL;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_LOCATION_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_POSITION_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_EXCEL;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.VALID_TEAM_DEVELOPER_INTERN;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;

import org.junit.Test;

import seedu.address.logic.commands.job.JobAddCommand;
import seedu.address.model.job.Job;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.model.skill.Skill;
import seedu.address.testutil.JobBuilder;

public class JobAddCommandParserTest {
    private JobAddCommandParser parser = new JobAddCommandParser();

    @Test
    public void parse_allFieldsPresent_success() {
        Job expectedJob = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN)
                .withTeam(VALID_TEAM_DEVELOPER_INTERN).withLocation(VALID_LOCATION_DEVELOPER_INTERN)
                .withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN).withSkills(VALID_SKILL_JAVASCRIPT)
                .build();

        // whitespace only preamble
        assertParseSuccess(parser, PREAMBLE_WHITESPACE + POSITION_DESC_DEVELOPER_INTERN
                + TEAM_DESC_DEVELOPER_INTERN + LOCATION_DESC_DEVELOPER_INTERN
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple positions - last position accepted
        assertParseSuccess(parser, POSITION_DESC_INTERN + POSITION_DESC_DEVELOPER_INTERN
                + TEAM_DESC_DEVELOPER_INTERN + LOCATION_DESC_DEVELOPER_INTERN
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple teams - last team accepted
        assertParseSuccess(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_INTERN
                + TEAM_DESC_DEVELOPER_INTERN + LOCATION_DESC_DEVELOPER_INTERN
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple locations - last location accepted
        assertParseSuccess(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_INTERN + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple numberOfPositions - last numberOfPositions accepted
        assertParseSuccess(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple tags - all accepted
        Job expectedJobWithMultipleSkills = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN)
                .withTeam(VALID_TEAM_DEVELOPER_INTERN).withLocation(VALID_LOCATION_DEVELOPER_INTERN)
                .withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN).withSkills(VALID_SKILL_JAVASCRIPT,
                        VALID_SKILL_EXCEL).build();
        assertParseSuccess(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT
                + SKILL_DESC_EXCEL, new JobAddCommand(expectedJobWithMultipleSkills));
    }

    @Test
    public void parse_compulsoryFieldMissing_failure() {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE);

        // missing position prefix
        assertParseFailure(parser, VALID_POSITION_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                expectedMessage);

        // missing team prefix
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + VALID_TEAM_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                expectedMessage);

        // missing location prefix
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + VALID_LOCATION_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                expectedMessage);

        // missing numberOfLocations prefix
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                expectedMessage);

        // missing tags prefix
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + VALID_SKILL_JAVASCRIPT,
                expectedMessage);
    }

    @Test
    public void parse_invalidValue_failure() {
        // invalid position
        assertParseFailure(parser, INVALID_POSITION_DESC + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                Position.MESSAGE_POSITION_CONSTRAINTS);

        // invalid team
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + INVALID_TEAM_DESC
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                Team.MESSAGE_TEAM_CONSTRAINTS);

        // invalid location
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + INVALID_LOCATION_DESC + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                Location.MESSAGE_LOCATION_CONSTRAINTS);

        // invalid numberOfPositions
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + INVALID_NUMBER_OF_POSITIONS_DESC + SKILL_DESC_JAVASCRIPT,
                NumberOfPositions.MESSAGE_NUMBER_OF_POSITIONS_CONSTRAINTS);

        // invalid skill
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + INVALID_SKILL_DESC, Skill.MESSAGE_SKILL_CONSTRAINTS);
    }
}
```
###### \java\seedu\address\logic\parser\job\JobDeleteCommandParserTest.java
``` java
package seedu.address.logic.parser.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;

import org.junit.Test;

import seedu.address.logic.commands.job.JobDeleteCommand;

public class JobDeleteCommandParserTest {

    private JobDeleteCommandParser parser = new JobDeleteCommandParser();

    @Test
    public void parse_validArgs_returnsJobDeleteCommand() {
        assertParseSuccess(parser, "1", new JobDeleteCommand(INDEX_FIRST));
    }

    @Test
    public void parse_invalidArgs_throwsParseException() {
        assertParseFailure(parser, "a", String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobDeleteCommand.MESSAGE_USAGE));
    }

}
```
###### \java\seedu\address\logic\parser\job\JobEditCommandParserTest.java
``` java
package seedu.address.logic.parser.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_LOCATION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_NUMBER_OF_POSITIONS_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_POSITION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_SKILL_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_TEAM_DESC;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_ALGORITHMS;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_EXCEL;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_LOCATION_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_LOCATION_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_NUMBER_OF_POSITIONS_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_POSITION_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_ALGORITHMS;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_EXCEL;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.VALID_TEAM_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_TEAM_INTERN;
import static seedu.address.logic.parser.CliSyntax.PREFIX_SKILL;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND;
import static seedu.address.testutil.TypicalIndexes.INDEX_THIRD;

import org.junit.Test;

import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.job.JobEditCommand;
import seedu.address.logic.commands.job.JobEditCommand.EditJobDescriptor;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.model.skill.Skill;
import seedu.address.testutil.EditJobDescriptorBuilder;

public class JobEditCommandParserTest {

    private static final String SKILL_EMPTY = " " + PREFIX_SKILL;

    private static final String MESSAGE_INVALID_FORMAT =
            String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobEditCommand.MESSAGE_USAGE);

    private JobEditCommandParser parser = new JobEditCommandParser();

    @Test
    public void parse_missingParts_failure() {
        // no index specified
        assertParseFailure(parser, VALID_POSITION_INTERN, MESSAGE_INVALID_FORMAT);

        // no field specified
        assertParseFailure(parser, "1", JobEditCommand.MESSAGE_NOT_EDITED);

        // no index and no field specified
        assertParseFailure(parser, "", MESSAGE_INVALID_FORMAT);
    }

    @Test
    public void parse_invalidPreamble_failure() {
        // negative index
        assertParseFailure(parser, "-5" + POSITION_DESC_INTERN, MESSAGE_INVALID_FORMAT);

        // zero index
        assertParseFailure(parser, "0" + POSITION_DESC_INTERN, MESSAGE_INVALID_FORMAT);

        // invalid arguments being parsed as preamble
        assertParseFailure(parser, "1 some random string", MESSAGE_INVALID_FORMAT);

        // invalid prefix being parsed as preamble
        assertParseFailure(parser, "1 i/ string", MESSAGE_INVALID_FORMAT);
    }

    @Test
    public void parse_invalidValue_failure() {
        // invalid position
        assertParseFailure(parser, "1" + INVALID_POSITION_DESC, Position.MESSAGE_POSITION_CONSTRAINTS);
        assertParseFailure(parser, "1" + INVALID_TEAM_DESC, Team.MESSAGE_TEAM_CONSTRAINTS); // invalid team
        // invalid location
        assertParseFailure(parser, "1" + INVALID_LOCATION_DESC, Location.MESSAGE_LOCATION_CONSTRAINTS);
        assertParseFailure(parser, "1" + INVALID_NUMBER_OF_POSITIONS_DESC,
                NumberOfPositions.MESSAGE_NUMBER_OF_POSITIONS_CONSTRAINTS); // invalid address
        assertParseFailure(parser, "1" + INVALID_SKILL_DESC, Skill.MESSAGE_SKILL_CONSTRAINTS); // invalid skill

        // invalid team followed by valid location
        assertParseFailure(parser, "1" + INVALID_TEAM_DESC + LOCATION_DESC_INTERN,
                Team.MESSAGE_TEAM_CONSTRAINTS);

        // valid team followed by invalid team. The test case for invalid team followed by valid team
        // is tested at {@code parse_invalidValueFollowedByValidValue_success()}
        assertParseFailure(parser, "1" + TEAM_DESC_DEVELOPER_INTERN + INVALID_TEAM_DESC,
                Team.MESSAGE_TEAM_CONSTRAINTS);

        // while parsing {@code PREFIX_SKILL} alone will reset the SKILLs of the {@code Job} being edited,
        // parsing it together with a valid skill results in error
        assertParseFailure(parser, "1" + SKILL_DESC_JAVASCRIPT + SKILL_DESC_EXCEL + SKILL_EMPTY,
                Skill.MESSAGE_SKILL_CONSTRAINTS);
        assertParseFailure(parser, "1" + SKILL_DESC_JAVASCRIPT + SKILL_EMPTY + SKILL_DESC_EXCEL,
                Skill.MESSAGE_SKILL_CONSTRAINTS);
        assertParseFailure(parser, "1" + SKILL_EMPTY + SKILL_DESC_JAVASCRIPT + SKILL_DESC_EXCEL,
                Skill.MESSAGE_SKILL_CONSTRAINTS);

        // multiple invalid values, but only the first invalid value is captured
        assertParseFailure(parser, "1" + INVALID_POSITION_DESC + INVALID_LOCATION_DESC + VALID_TEAM_INTERN,
                Position.MESSAGE_POSITION_CONSTRAINTS);
    }

    @Test
    public void parse_allFieldsSpecified_success() {
        Index targetIndex = INDEX_SECOND;
        String userInput = targetIndex.getOneBased() + TEAM_DESC_DEVELOPER_INTERN + SKILL_DESC_ALGORITHMS
                + LOCATION_DESC_INTERN + POSITION_DESC_INTERN + SKILL_DESC_JAVASCRIPT + NUMBER_OF_POSITIONS_DESC_INTERN;

        EditJobDescriptor descriptor = new EditJobDescriptorBuilder().withPosition(VALID_POSITION_INTERN)
                .withTeam(VALID_TEAM_DEVELOPER_INTERN).withLocation(VALID_LOCATION_INTERN)
                .withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_INTERN)
                .withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_ALGORITHMS).build();
        JobEditCommand expectedCommand = new JobEditCommand(targetIndex, descriptor);

        assertParseSuccess(parser, userInput, expectedCommand);
    }

    @Test
    public void parse_someFieldsSpecified_success() {
        Index targetIndex = INDEX_FIRST;
        String userInput = targetIndex.getOneBased() + TEAM_DESC_DEVELOPER_INTERN + LOCATION_DESC_INTERN;

        EditJobDescriptor descriptor = new EditJobDescriptorBuilder().withTeam(VALID_TEAM_DEVELOPER_INTERN)
                .withLocation(VALID_LOCATION_INTERN).build();
        JobEditCommand expectedCommand = new JobEditCommand(targetIndex, descriptor);

        assertParseSuccess(parser, userInput, expectedCommand);
    }

    @Test
    public void parse_oneFieldSpecified_success() {
        // position
        Index targetIndex = INDEX_THIRD;
        String userInput = targetIndex.getOneBased() + POSITION_DESC_INTERN;
        EditJobDescriptor descriptor = new EditJobDescriptorBuilder().withPosition(VALID_POSITION_INTERN).build();
        JobEditCommand expectedCommand = new JobEditCommand(targetIndex, descriptor);
        assertParseSuccess(parser, userInput, expectedCommand);

        // team
        userInput = targetIndex.getOneBased() + TEAM_DESC_INTERN;
        descriptor = new EditJobDescriptorBuilder().withTeam(VALID_TEAM_INTERN).build();
        expectedCommand = new JobEditCommand(targetIndex, descriptor);
        assertParseSuccess(parser, userInput, expectedCommand);

        // location
        userInput = targetIndex.getOneBased() + LOCATION_DESC_INTERN;
        descriptor = new EditJobDescriptorBuilder().withLocation(VALID_LOCATION_INTERN).build();
        expectedCommand = new JobEditCommand(targetIndex, descriptor);
        assertParseSuccess(parser, userInput, expectedCommand);

        // number of Positions
        userInput = targetIndex.getOneBased() + NUMBER_OF_POSITIONS_DESC_INTERN;
        descriptor = new EditJobDescriptorBuilder().withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_INTERN).build();
        expectedCommand = new JobEditCommand(targetIndex, descriptor);
        assertParseSuccess(parser, userInput, expectedCommand);

        // skills
        userInput = targetIndex.getOneBased() + SKILL_DESC_JAVASCRIPT;
        descriptor = new EditJobDescriptorBuilder().withSkills(VALID_SKILL_JAVASCRIPT).build();
        expectedCommand = new JobEditCommand(targetIndex, descriptor);
        assertParseSuccess(parser, userInput, expectedCommand);
    }

    @Test
    public void parse_multipleRepeatedFields_acceptsLast() {
        Index targetIndex = INDEX_FIRST;
        String userInput = targetIndex.getOneBased()  + TEAM_DESC_INTERN  + LOCATION_DESC_INTERN
                + VALID_SKILL_JAVASCRIPT + TEAM_DESC_INTERN + LOCATION_DESC_INTERN + SKILL_DESC_JAVASCRIPT
                + TEAM_DESC_DEVELOPER_INTERN + LOCATION_DESC_DEVELOPER_INTERN + SKILL_DESC_EXCEL;

        EditJobDescriptor descriptor = new EditJobDescriptorBuilder().withTeam(VALID_TEAM_DEVELOPER_INTERN)
                .withLocation(VALID_LOCATION_DEVELOPER_INTERN).withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_EXCEL)
                .build();
        JobEditCommand expectedCommand = new JobEditCommand(targetIndex, descriptor);

        assertParseSuccess(parser, userInput, expectedCommand);
    }

    @Test
    public void parse_invalidValueFollowedByValidValue_success() {
        // no other valid values specified
        Index targetIndex = INDEX_FIRST;
        String userInput = targetIndex.getOneBased() + INVALID_TEAM_DESC + TEAM_DESC_DEVELOPER_INTERN;
        EditJobDescriptor descriptor = new EditJobDescriptorBuilder().withTeam(VALID_TEAM_DEVELOPER_INTERN).build();
        JobEditCommand expectedCommand = new JobEditCommand(targetIndex, descriptor);
        assertParseSuccess(parser, userInput, expectedCommand);

        // other valid values specified
        userInput = targetIndex.getOneBased() + LOCATION_DESC_DEVELOPER_INTERN + INVALID_TEAM_DESC
                + TEAM_DESC_DEVELOPER_INTERN;
        descriptor = new EditJobDescriptorBuilder().withTeam(VALID_TEAM_DEVELOPER_INTERN)
                .withLocation(VALID_LOCATION_DEVELOPER_INTERN).build();
        expectedCommand = new JobEditCommand(targetIndex, descriptor);
        assertParseSuccess(parser, userInput, expectedCommand);
    }

    @Test
    public void parse_resetSkills_success() {
        Index targetIndex = INDEX_THIRD;
        String userInput = targetIndex.getOneBased() + SKILL_EMPTY;

        EditJobDescriptor descriptor = new EditJobDescriptorBuilder().withSkills().build();
        JobEditCommand expectedCommand = new JobEditCommand(targetIndex, descriptor);

        assertParseSuccess(parser, userInput, expectedCommand);
    }
}
```
###### \java\seedu\address\logic\parser\job\JobFindCommandParserTest.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;

import java.util.Arrays;

import org.junit.Test;

import seedu.address.logic.commands.job.JobFindCommand;
import seedu.address.logic.parser.job.JobFindCommandParser;
import seedu.address.model.job.PositionContainsKeywordsPredicate;
import seedu.address.model.skill.JobSkillContainsKeywordsPredicate;

public class JobFindCommandParserTest {

    private JobFindCommandParser parser = new JobFindCommandParser();
    @Test
    public void parse_emptyArg_throwsParseException() {
        assertParseFailure(parser, "     ", String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                JobFindCommand.MESSAGE_USAGE));

        assertParseFailure(parser, "", String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobFindCommand.MESSAGE_USAGE));
    }

    @Test
    public void parse_validArgs_returnsJobFindCommand() {
        // no leading and trailing whitespaces
        JobFindCommand expectedFindPositionCommand =
                new JobFindCommand(new PositionContainsKeywordsPredicate(Arrays.asList("Alice", "Bob")));
        assertParseSuccess(parser, " p/Alice Bob", expectedFindPositionCommand);

        // multiple whitespaces between keywords
        assertParseSuccess(parser, " \n p/Alice \n \t Bob  \t", expectedFindPositionCommand);

        // no leading and trailing whitespaces
        JobFindCommand expectedFindSkillCommand =
                new JobFindCommand(new JobSkillContainsKeywordsPredicate(Arrays.asList("developer", "accountant")));
        assertParseSuccess(parser, " s/developer accountant", expectedFindSkillCommand);

        // multiple whitespaces between keywords
        assertParseSuccess(parser, " \n s/developer \n \t accountant  \t", expectedFindSkillCommand);
    }

    @Test
    public void parse_invalidArg_throwsParseException() {
        assertParseFailure(parser, " p/", String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobFindCommand.MESSAGE_USAGE));

        assertParseFailure(parser, " s/", String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobFindCommand.MESSAGE_USAGE));

        assertParseFailure(parser, " p/ s/", String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                JobFindCommand.MESSAGE_USAGE));

        assertParseFailure(parser, " s/ p/", String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                JobFindCommand.MESSAGE_USAGE));
    }

}
```
###### \java\seedu\address\logic\parser\job\JobMatchCommandParserTest.java
``` java
package seedu.address.logic.parser.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;

import org.junit.Test;

import seedu.address.logic.commands.job.JobMatchCommand;

/**
 * Test scope: similar to {@code SelectCommandParserTest}.
 * @see seedu.address.logic.parser.SelectCommandParserTest
 */
public class JobMatchCommandParserTest {

    private JobMatchCommandParser parser = new JobMatchCommandParser();

    @Test
    public void parse_validArgs_returnsJobMatchCommand() {
        assertParseSuccess(parser, "1", new JobMatchCommand(INDEX_FIRST));
    }

    @Test
    public void parse_invalidArgs_throwsParseException() {
        assertParseFailure(parser, "a", String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobMatchCommand.MESSAGE_USAGE));
    }
}
```
###### \java\seedu\address\logic\parser\LinkedInCommandParserTest.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;

import org.junit.Test;

import seedu.address.logic.commands.person.LinkedInCommand;
import seedu.address.logic.parser.person.LinkedInCommandParser;

public class LinkedInCommandParserTest {

    private LinkedInCommandParser parser = new LinkedInCommandParser();

    @Test
    public void parse_validArgs_returnsLinkedInCommand() {
        assertParseSuccess(parser, "1", new LinkedInCommand(INDEX_FIRST));
    }

    @Test
    public void parse_invalidArgs_throwsParseException() {
        assertParseFailure(parser, "a", String.format(MESSAGE_INVALID_COMMAND_FORMAT, LinkedInCommand.MESSAGE_USAGE));
    }
}
```
###### \java\seedu\address\model\job\LocationContainsKeywordsPredicateTest.java
``` java
package seedu.address.model.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Test;

import seedu.address.testutil.JobBuilder;

public class LocationContainsKeywordsPredicateTest {

    @Test
    public void equals() {
        List<String> firstPredicateKeywordList = Collections.singletonList("first");
        List<String> secondPredicateKeywordList = Arrays.asList("first", "second");

        LocationContainsKeywordsPredicate firstPredicate =
                new LocationContainsKeywordsPredicate(firstPredicateKeywordList);
        LocationContainsKeywordsPredicate secondPredicate =
                new LocationContainsKeywordsPredicate(secondPredicateKeywordList);

        // same object -> returns true
        assertTrue(firstPredicate.equals(firstPredicate));

        // same values -> returns true
        LocationContainsKeywordsPredicate firstPredicateCopy =
                new LocationContainsKeywordsPredicate(firstPredicateKeywordList);
        assertTrue(firstPredicate.equals(firstPredicateCopy));

        // different types -> returns false
        assertFalse(firstPredicate.equals(1));

        // null -> returns false
        assertFalse(firstPredicate.equals(null));

        // different job -> returns false
        assertFalse(firstPredicate.equals(secondPredicate));
    }

    @Test
    public void test_positionContainsKeywords_returnsTrue() {
        // One keyword
        LocationContainsKeywordsPredicate predicate =
                new LocationContainsKeywordsPredicate(Collections.singletonList("Alice"));
        assertTrue(predicate.test(new JobBuilder().withLocation("Alice Bob").build()));

        // Multiple keywords
        predicate = new LocationContainsKeywordsPredicate(Arrays.asList("Alice", "Bob"));
        assertTrue(predicate.test(new JobBuilder().withLocation("Alice Bob").build()));

        // Only one matching keyword
        predicate = new LocationContainsKeywordsPredicate(Arrays.asList("Bob", "Carol"));
        assertTrue(predicate.test(new JobBuilder().withLocation("Alice Carol").build()));

        // Mixed-case keywords
        predicate = new LocationContainsKeywordsPredicate(Arrays.asList("aLIce", "bOB"));
        assertTrue(predicate.test(new JobBuilder().withLocation("Alice Bob").build()));
    }

    @Test
    public void test_positionDoesNotContainKeywords_returnsFalse() {
        // Zero keywords
        LocationContainsKeywordsPredicate predicate = new LocationContainsKeywordsPredicate(Collections.emptyList());
        assertFalse(predicate.test(new JobBuilder().withLocation("Alice").build()));

        // Non-matching keyword
        predicate = new LocationContainsKeywordsPredicate(Arrays.asList("Carol"));
        assertFalse(predicate.test(new JobBuilder().withLocation("Alice Bob").build()));

        // Keywords match position, team, skill and number of positions, but does not match location
        predicate = new LocationContainsKeywordsPredicate(
                Arrays.asList("developer", "Hardware", "2", "developer"));
        assertFalse(predicate.test(new JobBuilder().withSkills("developer").withLocation("Engineer")
                .withTeam("Hardware").withLocation("Main Street").withNumberOfPositions("2").build()));
    }
}
```
###### \java\seedu\address\model\job\LocationTest.java
``` java
package seedu.address.model.job;

import static junit.framework.TestCase.assertTrue;
import static org.junit.Assert.assertFalse;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class LocationTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new Location(null));
    }

    @Test
    public void constructor_invalidLocation_throwsIllegalArgumentException() {
        String invalidLocation = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new Location(invalidLocation));
    }

    @Test
    public void isValidLocation() {
        // null location
        Assert.assertThrows(NullPointerException.class, () -> Location.isValidLocation(null));

        // invalid locations
        assertFalse(Location.isValidLocation("")); // empty string
        assertFalse(Location.isValidLocation(" ")); // spaces only

        // valid locations
        assertTrue(Location.isValidLocation("Singapore"));
        assertTrue(Location.isValidLocation("-")); // one character
        assertTrue(Location.isValidLocation("Leng Inc; 1234 Market St; San Francisco CA 2349879; USA")); // long address
    }

}
```
###### \java\seedu\address\model\job\NumberOfPositionsTest.java
``` java
package seedu.address.model.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class NumberOfPositionsTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new NumberOfPositions(null));
    }

    @Test
    public void constructor_invalidNumberOfPositions_throwsIllegalArgumentException() {
        String invalidNumberOfPositions = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new NumberOfPositions(invalidNumberOfPositions));
    }

    @Test
    public void isValidNumberOfPositions() {
        // null location
        Assert.assertThrows(NullPointerException.class, () -> NumberOfPositions.isValidNumberOfPositions(null));

        // invalid locations
        assertFalse(NumberOfPositions.isValidNumberOfPositions("")); // empty string
        assertFalse(NumberOfPositions.isValidNumberOfPositions(" ")); // spaces only
        assertFalse(NumberOfPositions.isValidNumberOfPositions("abc")); // non-numeric
        assertFalse(NumberOfPositions.isValidNumberOfPositions("9011p041")); // alphabets within digits
        assertFalse(NumberOfPositions.isValidNumberOfPositions("9312 1534")); // spaces within digits

        // valid locations
        assertTrue(NumberOfPositions.isValidNumberOfPositions("1")); // one digit
        assertTrue(NumberOfPositions.isValidNumberOfPositions("33"));
        assertTrue(NumberOfPositions.isValidNumberOfPositions("3545")); // long number of positions
    }
}
```
###### \java\seedu\address\model\job\PositionContainsKeywordsPredicateTest.java
``` java
package seedu.address.model.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Test;

import seedu.address.testutil.JobBuilder;

public class PositionContainsKeywordsPredicateTest {

    @Test
    public void equals() {
        List<String> firstPredicateKeywordList = Collections.singletonList("first");
        List<String> secondPredicateKeywordList = Arrays.asList("first", "second");

        PositionContainsKeywordsPredicate firstPredicate =
                new PositionContainsKeywordsPredicate(firstPredicateKeywordList);
        PositionContainsKeywordsPredicate secondPredicate =
                new PositionContainsKeywordsPredicate(secondPredicateKeywordList);

        // same object -> returns true
        assertTrue(firstPredicate.equals(firstPredicate));

        // same values -> returns true
        PositionContainsKeywordsPredicate firstPredicateCopy =
                new PositionContainsKeywordsPredicate(firstPredicateKeywordList);
        assertTrue(firstPredicate.equals(firstPredicateCopy));

        // different types -> returns false
        assertFalse(firstPredicate.equals(1));

        // null -> returns false
        assertFalse(firstPredicate.equals(null));

        // different job -> returns false
        assertFalse(firstPredicate.equals(secondPredicate));
    }

    @Test
    public void test_positionContainsKeywords_returnsTrue() {
        // One keyword
        PositionContainsKeywordsPredicate predicate =
                new PositionContainsKeywordsPredicate(Collections.singletonList("Alice"));
        assertTrue(predicate.test(new JobBuilder().withPosition("Alice Bob").build()));

        // Multiple keywords
        predicate = new PositionContainsKeywordsPredicate(Arrays.asList("Alice", "Bob"));
        assertTrue(predicate.test(new JobBuilder().withPosition("Alice Bob").build()));

        // Only one matching keyword
        predicate = new PositionContainsKeywordsPredicate(Arrays.asList("Bob", "Carol"));
        assertTrue(predicate.test(new JobBuilder().withPosition("Alice Carol").build()));

        // Mixed-case keywords
        predicate = new PositionContainsKeywordsPredicate(Arrays.asList("aLIce", "bOB"));
        assertTrue(predicate.test(new JobBuilder().withPosition("Alice Bob").build()));
    }

    @Test
    public void test_positionDoesNotContainKeywords_returnsFalse() {
        // Zero keywords
        PositionContainsKeywordsPredicate predicate = new PositionContainsKeywordsPredicate(Collections.emptyList());
        assertFalse(predicate.test(new JobBuilder().withPosition("Alice").build()));

        // Non-matching keyword
        predicate = new PositionContainsKeywordsPredicate(Arrays.asList("Carol"));
        assertFalse(predicate.test(new JobBuilder().withPosition("Alice Bob").build()));

        // Keywords match skill, team, location and number of positions, but does not match position
        predicate = new PositionContainsKeywordsPredicate(
                Arrays.asList("developer", "Hardware", "2", "Main", "Street"));
        assertFalse(predicate.test(new JobBuilder().withSkills("developer").withPosition("Engineer")
                .withTeam("Hardware").withLocation("Main Street").withNumberOfPositions("2").build()));
    }
}
```
###### \java\seedu\address\model\job\PositionTest.java
``` java
package seedu.address.model.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class PositionTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new Position(null));
    }

    @Test
    public void constructor_invalidPosition_throwsIllegalArgumentException() {
        String invalidPosition = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new Position(invalidPosition));
    }

    @Test
    public void isValidPosition() {
        // null position
        Assert.assertThrows(NullPointerException.class, () -> Position.isValidPosition(null));

        // invalid position
        assertFalse(Position.isValidPosition("")); // empty string
        assertFalse(Position.isValidPosition(" ")); // spaces only
        assertFalse(Position.isValidPosition("^")); // only non-alphanumeric characters
        assertFalse(Position.isValidPosition("engineer*")); // contains non-alphanumeric characters

        // valid position
        assertTrue(Position.isValidPosition("intern")); // alphabets only
        assertTrue(Position.isValidPosition("12345")); // numbers only
        assertTrue(Position.isValidPosition("2nd associate")); // alphanumeric characters
        assertTrue(Position.isValidPosition("Software Engineer")); // with capital letters
        assertTrue(Position.isValidPosition("Computer Science undergraduate")); // long positions
    }
}
```
###### \java\seedu\address\model\job\TeamTest.java
``` java
package seedu.address.model.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class TeamTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new Team(null));
    }

    @Test
    public void constructor_invalidTeam_throwsIllegalArgumentException() {
        String invalidTeam = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new Team(invalidTeam));
    }

    @Test
    public void isValidTeam() {
        // null team
        Assert.assertThrows(NullPointerException.class, () -> Team.isValidTeam(null));

        // invalid team
        assertFalse(Team.isValidTeam("")); // empty string
        assertFalse(Team.isValidTeam(" ")); // spaces only
        assertFalse(Team.isValidTeam("^")); // only non-alphanumeric characters
        assertFalse(Team.isValidTeam("management*")); // contains non-alphanumeric characters

        // valid team
        assertTrue(Team.isValidTeam("frontend")); // alphabets only
        assertTrue(Team.isValidTeam("12345")); // numbers only
        assertTrue(Team.isValidTeam("2nd development")); // alphanumeric characters
        assertTrue(Team.isValidTeam("Cloud Services")); // with capital letters
        assertTrue(Team.isValidTeam("Frontend Web Development")); // long teams
    }
}
```
###### \java\seedu\address\model\ModelManagerTest.java
``` java
    @Test
    public void getFilteredJobList_modifyList_throwsUnsupportedOperationException() {
        ModelManager modelManager = new ModelManager();
        thrown.expect(UnsupportedOperationException.class);
        modelManager.getFilteredJobList().remove(0);
    }

```
###### \java\seedu\address\model\person\CompanyTest.java
``` java
package seedu.address.model.person;

import static org.junit.Assert.assertFalse;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class CompanyTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new Company(null));
    }

    @Test
    public void constructor_invalidCompany_throwsIllegalArgumentException() {
        String invalidCompany = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new Company(invalidCompany));
    }

    @Test
    public void isValidCompany() {
        // null company
        Assert.assertThrows(NullPointerException.class, () -> Company.isValidCompany(null));

        // invalid company
        assertFalse(Company.isValidCompany("")); // empty string
        assertFalse(Company.isValidCompany(" ")); // spaces only
        assertFalse(Company.isValidCompany("^")); // only non-alphanumeric characters
        assertFalse(Company.isValidCompany("google*")); // contains non-alphanumeric characters

        // valid company
        assertTrue(Company.isValidCompany("google")); // alphabets only
        assertTrue(Company.isValidCompany("12345")); // numbers only
        assertTrue(Company.isValidCompany("facebook 2nd")); // alphanumeric characters
        assertTrue(Company.isValidCompany("Capital Ventures")); // with capital letters
        assertTrue(Company.isValidCompany("Google Services Pvt Ltd")); // long companys
    }

    private void assertTrue(boolean google) {
    }
}
```
###### \java\seedu\address\model\person\CurrentPositionTest.java
``` java
package seedu.address.model.person;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class CurrentPositionTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new CurrentPosition(null));
    }

    @Test
    public void constructor_invalidCurrentPosition_throwsIllegalArgumentException() {
        String invalidCurrentPosition = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new CurrentPosition(invalidCurrentPosition));
    }

    @Test
    public void isValidCurrentPosition() {
        // null current position
        Assert.assertThrows(NullPointerException.class, () -> CurrentPosition.isValidCurrentPosition(null));

        // invalid current position
        assertFalse(CurrentPosition.isValidCurrentPosition("")); // empty string
        assertFalse(CurrentPosition.isValidCurrentPosition(" ")); // spaces only
        assertFalse(CurrentPosition.isValidCurrentPosition("^")); // only non-alphanumeric characters
        assertFalse(CurrentPosition.isValidCurrentPosition("engineer*")); // contains non-alphanumeric characters

        // valid current position
        assertTrue(CurrentPosition.isValidCurrentPosition("engineer")); // alphabets only
        assertTrue(CurrentPosition.isValidCurrentPosition("12345")); // numbers only
        assertTrue(CurrentPosition.isValidCurrentPosition("2nd year student")); // alphanumeric characters
        assertTrue(CurrentPosition.isValidCurrentPosition("Marketing Intern")); // with capital letters
        assertTrue(CurrentPosition.isValidCurrentPosition("First year undergraduate student")); // long position
    }
}
```
###### \java\seedu\address\model\skill\JobSkillContainsKeywordsPredicateTest.java
``` java
package seedu.address.model.skill;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Test;

import seedu.address.testutil.JobBuilder;

public class JobSkillContainsKeywordsPredicateTest {

    @Test
    public void equals() {
        List<String> firstPredicateKeywordList = Collections.singletonList("first");
        List<String> secondPredicateKeywordList = Arrays.asList("first", "second");

        JobSkillContainsKeywordsPredicate firstPredicate =
                new JobSkillContainsKeywordsPredicate(firstPredicateKeywordList);
        JobSkillContainsKeywordsPredicate secondPredicate =
                new JobSkillContainsKeywordsPredicate(secondPredicateKeywordList);

        // same object -> returns true
        assertTrue(firstPredicate.equals(firstPredicate));

        // same values -> returns true
        JobSkillContainsKeywordsPredicate firstPredicateCopy =
                new JobSkillContainsKeywordsPredicate(firstPredicateKeywordList);
        assertTrue(firstPredicate.equals(firstPredicateCopy));

        // different types -> returns false
        assertFalse(firstPredicate.equals(1));

        // null -> returns false
        assertFalse(firstPredicate.equals(null));

        // different job -> returns false
        assertFalse(firstPredicate.equals(secondPredicate));
    }

    @Test
    public void test_skillContainsKeywords_returnsTrue() {
        // One keyword
        JobSkillContainsKeywordsPredicate predicate =
                new JobSkillContainsKeywordsPredicate(Collections.singletonList("developer"));
        assertTrue(predicate.test(new JobBuilder().withSkills("developer", "geek").build()));

        // Multiple keywords
        predicate = new JobSkillContainsKeywordsPredicate(Arrays.asList("developer", "geek"));
        assertTrue(predicate.test(new JobBuilder().withSkills("developer", "geek").build()));

        // Only one matching keyword
        predicate = new JobSkillContainsKeywordsPredicate(Arrays.asList("developer", "accountant"));
        assertTrue(predicate.test(new JobBuilder().withSkills("accountant", "manager").build()));

        // Mixed-case keywords
        predicate = new JobSkillContainsKeywordsPredicate(Arrays.asList("deVeloper", "acCounTant"));
        assertTrue(predicate.test(new JobBuilder().withSkills("developer", "accountant").build()));
    }

    @Test
    public void test_positionDoesNotContainKeywords_returnsFalse() {
        // Zero keywords
        JobSkillContainsKeywordsPredicate predicate =
                new JobSkillContainsKeywordsPredicate(Collections.emptyList());
        assertFalse(predicate.test(new JobBuilder().withSkills("developer").build()));

        // Non-matching keyword
        predicate = new JobSkillContainsKeywordsPredicate(Arrays.asList("projectmanager"));
        assertFalse(predicate.test(new JobBuilder().withSkills("developer", "designer").build()));

        // Keywords match position, team, location and number of positions, but does not match skill
        predicate = new JobSkillContainsKeywordsPredicate(
                Arrays.asList("Engineer", "Hardware", "2", "Main", "Street"));
        assertFalse(predicate.test(new JobBuilder().withSkills("developer").withPosition("Engineer")
                .withTeam("Hardware").withLocation("Main Street").withNumberOfPositions("2").build()));
    }
}
```
###### \java\seedu\address\model\UniqueJobListTest.java
``` java
package seedu.address.model;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import seedu.address.model.job.UniqueJobList;

public class UniqueJobListTest {
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void asObservableList_modifyList_throwsUnsupportedOperationException() {
        UniqueJobList uniqueJobList = new UniqueJobList();
        thrown.expect(UnsupportedOperationException.class);
        uniqueJobList.asObservableList().remove(0);
    }
}
```
###### \java\seedu\address\storage\XmlAdaptedJobTest.java
``` java
package seedu.address.storage;

import static org.junit.Assert.assertEquals;
import static seedu.address.storage.XmlAdaptedJob.MISSING_FIELD_MESSAGE_FORMAT;
import static seedu.address.testutil.TypicalJobs.MARKETING_INTERN;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.junit.Test;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.testutil.Assert;

public class XmlAdaptedJobTest {

    private static final String INVALID_POSITION = "Associ@te";
    private static final String INVALID_TEAM = "Engineering#";
    private static final String INVALID_LOCATION = " ";
    private static final String INVALID_NUMBER_OF_POSITIONS = "a12";
    private static final String INVALID_TAG = "C and Java";

    private static final String VALID_POSITION = MARKETING_INTERN.getPosition().toString();
    private static final String VALID_TEAM = MARKETING_INTERN.getTeam().toString();
    private static final String VALID_LOCATION = MARKETING_INTERN.getLocation().toString();
    private static final String VALID_NUMBER_OF_POSITIONS = MARKETING_INTERN.getNumberOfPositions().toString();
    private static final List<XmlAdaptedSkill> VALID_TAGS = MARKETING_INTERN.getSkills().stream()
            .map(XmlAdaptedSkill::new)
            .collect(Collectors.toList());

    @Test
    public void toModelType_validJobDetails_returnsJob() throws Exception {
        XmlAdaptedJob job = new XmlAdaptedJob(MARKETING_INTERN);
        assertEquals(MARKETING_INTERN, job.toModelType());
    }

    @Test
    public void toModelType_invalidPosition_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(INVALID_POSITION, VALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = Position.MESSAGE_POSITION_CONSTRAINTS;
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_nullPosition_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(null, VALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = String.format(MISSING_FIELD_MESSAGE_FORMAT, Position.class.getSimpleName());
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_invalidTeam_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, INVALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = Team.MESSAGE_TEAM_CONSTRAINTS;
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_nullTeam_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, null, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = String.format(MISSING_FIELD_MESSAGE_FORMAT, Team.class.getSimpleName());
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_invalidLocation_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, INVALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = Location.MESSAGE_LOCATION_CONSTRAINTS;
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_nullLocation_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, null, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = String.format(MISSING_FIELD_MESSAGE_FORMAT, Location.class.getSimpleName());
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_invalidNumberOfPositions_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION, INVALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = NumberOfPositions.MESSAGE_NUMBER_OF_POSITIONS_CONSTRAINTS;
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_nullNumberOfPositions_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION, null, VALID_TAGS);
        String expectedMessage = String.format(MISSING_FIELD_MESSAGE_FORMAT, NumberOfPositions.class.getSimpleName());
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_emptyTags_throwsIllegalValueException() {
        List<XmlAdaptedSkill> emptyTags = new ArrayList<>();
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, emptyTags);
        Assert.assertThrows(IllegalValueException.class, job::toModelType);
    }

    @Test
    public void toModelType_invalidTags_throwsIllegalValueException() {
        List<XmlAdaptedSkill> invalidTags = new ArrayList<>(VALID_TAGS);
        invalidTags.add(new XmlAdaptedSkill(INVALID_TAG));
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, invalidTags);
        Assert.assertThrows(IllegalValueException.class, job::toModelType);
    }

}
```
###### \java\seedu\address\storage\XmlAddressBookStorageTest.java
``` java
    @Test
    public void readAddressBook_invalidJobAddressBook_throwDataConversionException() throws Exception {
        thrown.expect(DataConversionException.class);
        readAddressBook("invalidJobAddressBook.xml");
    }

```
###### \java\seedu\address\storage\XmlAddressBookStorageTest.java
``` java
    @Test
    public void readAddressBook_invalidAndValidJobAddressBook_throwDataConversionException() throws Exception {
        thrown.expect(DataConversionException.class);
        readAddressBook("invalidAndValidJobAddressBook.xml");
    }

```
###### \java\seedu\address\storage\XmlSerializableAddressBookTest.java
``` java
    @Test
    public void toModelType_typicalJobsFile_success() throws Exception {
        XmlSerializableAddressBook dataFromFile = XmlUtil.getDataFromFile(TYPICAL_JOBS_FILE,
                XmlSerializableAddressBook.class);
        AddressBook addressBookFromFile = dataFromFile.toModelType();
        AddressBook typicalJobsAddressBook = TypicalJobs.getTypicalAddressBook();
        assertEquals(addressBookFromFile, typicalJobsAddressBook);
    }

```
###### \java\seedu\address\testutil\EditJobDescriptorBuilder.java
``` java
package seedu.address.testutil;

import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import seedu.address.logic.commands.job.JobEditCommand.EditJobDescriptor;
import seedu.address.model.job.Job;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.model.skill.Skill;

/**
 * A utility class to help with building EditJobDescriptor objects.
 */
public class EditJobDescriptorBuilder {

    private EditJobDescriptor descriptor;

    public EditJobDescriptorBuilder() {
        descriptor = new EditJobDescriptor();
    }

    public EditJobDescriptorBuilder(EditJobDescriptor descriptor) {
        this.descriptor = new EditJobDescriptor(descriptor);
    }

    /**
     * Returns an {@code EditJobDescriptor} with fields containing {@code job}'s details
     */
    public EditJobDescriptorBuilder(Job job) {
        descriptor = new EditJobDescriptor();
        descriptor.setPosition(job.getPosition());
        descriptor.setTeam(job.getTeam());
        descriptor.setLocation(job.getLocation());
        descriptor.setNumberOfPositions(job.getNumberOfPositions());
        descriptor.setSkills(job.getSkills());
    }

    /**
     * Sets the {@code Position} of the {@code EditJobDescriptor} that we are building.
     */
    public EditJobDescriptorBuilder withPosition(String position) {
        descriptor.setPosition(new Position(position));
        return this;
    }

    /**
     * Sets the {@code Team} of the {@code EditJobDescriptor} that we are building.
     */
    public EditJobDescriptorBuilder withTeam(String team) {
        descriptor.setTeam(new Team(team));
        return this;
    }

    /**
     * Sets the {@code Location} of the {@code EditJobDescriptor} that we are building.
     */
    public EditJobDescriptorBuilder withLocation(String location) {
        descriptor.setLocation(new Location(location));
        return this;
    }

    /**
     * Sets the {@code NumberOfPositions} of the {@code EditJobDescriptor} that we are building.
     */
    public EditJobDescriptorBuilder withNumberOfPositions(String numberOfPositions) {
        descriptor.setNumberOfPositions(new NumberOfPositions(numberOfPositions));
        return this;
    }

    /**
     * Parses the {@code skills} into a {@code Set<Skill>} and set it to the {@code EditJobDescriptor}
     * that we are building.
     */
    public EditJobDescriptorBuilder withSkills(String... skills) {
        Set<Skill> skillSet = Stream.of(skills).map(Skill::new).collect(Collectors.toSet());
        descriptor.setSkills(skillSet);
        return this;
    }

    public EditJobDescriptor build() {
        return descriptor;
    }
}
```
###### \java\seedu\address\testutil\JobBuilder.java
``` java
package seedu.address.testutil;

import java.util.HashSet;
import java.util.Set;

import seedu.address.model.job.Job;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.model.skill.Skill;
import seedu.address.model.util.SampleDataUtil;

/**
 * A utility class to help with building Person objects.
 */
public class JobBuilder {

    public static final String DEFAULT_POSITION = "Hardware Engineer";
    public static final String DEFAULT_TEAM = "Microprocessor";
    public static final String DEFAULT_LOCATION = "Singapore";
    public static final String DEFAULT_NUMBER_OF_POSITIONS = "2";
    public static final String DEFAULT_SKILLS = "C++";

    private Position position;
    private Team team;
    private Location location;
    private NumberOfPositions numberOfPositions;
    private Set<Skill> skills;

    public JobBuilder() {
        position = new Position(DEFAULT_POSITION);
        team = new Team(DEFAULT_TEAM);
        location = new Location(DEFAULT_LOCATION);
        numberOfPositions = new NumberOfPositions(DEFAULT_NUMBER_OF_POSITIONS);
        skills = SampleDataUtil.getSkillSet(DEFAULT_SKILLS);
    }

    /**
     * Initializes the JobBuilder with the data of {@code jobToCopy}.
     */
    public JobBuilder(Job jobToCopy) {
        position = jobToCopy.getPosition();
        team = jobToCopy.getTeam();
        location = jobToCopy.getLocation();
        numberOfPositions = jobToCopy.getNumberOfPositions();
        skills = new HashSet<>(jobToCopy.getSkills());
    }

    /**
     * Sets the {@code Position} of the {@code Job} that we are building.
     */
    public JobBuilder withPosition(String position) {
        this.position = new Position(position);
        return this;
    }

    /**
     * Sets the {@code Team} of the {@code Job} that we are building.
     */
    public JobBuilder withTeam(String team) {
        this.team = new Team(team);
        return this;
    }

    /**
     * Sets the {@code Location} of the {@code Job} that we are building.
     */
    public JobBuilder withLocation(String location) {
        this.location = new Location(location);
        return this;
    }

    /**
     * Sets the {@code NumberOfPositions} of the {@code Job} that we are building.
     */
    public JobBuilder withNumberOfPositions(String numberOfPositions) {
        this.numberOfPositions = new NumberOfPositions(numberOfPositions);
        return this;
    }

    /**
     * Parses the {@code skills} into a {@code Set<Skill>} and set it to the {@code Job} that we are building.
     */
    public JobBuilder withSkills(String ... skills) {
        this.skills = SampleDataUtil.getSkillSet(skills);
        return this;
    }

    public Job build() {
        return new Job(position, team, location, numberOfPositions, skills);
    }
}
```
###### \java\seedu\address\testutil\JobUtil.java
``` java
package seedu.address.testutil;

import static seedu.address.logic.parser.CliSyntax.PREFIX_LOCATION;
import static seedu.address.logic.parser.CliSyntax.PREFIX_NUMBER_OF_POSITIONS;
import static seedu.address.logic.parser.CliSyntax.PREFIX_POSITION;
import static seedu.address.logic.parser.CliSyntax.PREFIX_SKILL;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TEAM;

import seedu.address.logic.commands.job.JobAddCommand;
import seedu.address.model.job.Job;

/**
 * A utility class for Job.
 */
public class JobUtil {

    /**
     * Returns an add command string for adding the {@code job}.
     */
    public static String getJobAddCommand(Job job) {
        return JobAddCommand.COMMAND_WORD + " " + getJobDetails(job);
    }

    /**
     * Returns the part of command string for the given {@code job}'s details.
     */
    public static String getJobDetails(Job job) {
        StringBuilder sb = new StringBuilder();
        sb.append(PREFIX_POSITION + job.getPosition().value + " ");
        sb.append(PREFIX_TEAM + job.getTeam().value + " ");
        sb.append(PREFIX_LOCATION + job.getLocation().value + " ");
        sb.append(PREFIX_NUMBER_OF_POSITIONS + job.getNumberOfPositions().value + " ");
        job.getSkills().stream().forEach(s -> sb.append(PREFIX_SKILL + s.skillName + " "));
        return sb.toString();
    }
}
```
###### \java\seedu\address\testutil\TypicalJobs.java
``` java
package seedu.address.testutil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import seedu.address.model.AddressBook;
import seedu.address.model.job.Job;
import seedu.address.model.job.exceptions.DuplicateJobException;

/**
 * A utility class containing a list of {@code Job} objects to be used in tests.
 */
public class TypicalJobs {

    public static final Job SOFTWARE_ENGINEER = new JobBuilder().withPosition("Software Engineer")
            .withTeam("Cloud Services").withLocation("Singapore").withNumberOfPositions("2")
            .withSkills("Java", "Algorithms").build();
    public static final Job MARKETING_INTERN = new JobBuilder().withPosition("Marketing Intern")
            .withTeam("Marketing").withLocation("Kuala Lampur, Malaysia").withNumberOfPositions("1")
            .withSkills("Excel", "Writing").build();
    public static final Job DEVOPS_ENGINEER = new JobBuilder().withPosition("DevOps Engineer")
            .withTeam("DevOps").withLocation("Singapore").withNumberOfPositions("3")
            .withSkills("AWS", "SQL-Server").build();
    public static final Job PRODUCT_MANAGER = new JobBuilder().withPosition("Product Manager")
            .withTeam("Mobile Products").withLocation("India").withNumberOfPositions("1")
            .withSkills("UI/UX", "Testing").build();

    // Manually added
    public static final Job ANALYST = new JobBuilder().withPosition("Analyst").withTeam("Data Science")
            .withLocation("New Delhi, India").withNumberOfPositions("5").withSkills("Excel").build();
    public static final Job DEVELOPER_INTERN = new JobBuilder().withPosition("Developer Intern")
            .withLocation("Jakarta, Indonesia").withTeam("Web Development").withNumberOfPositions("2")
            .withSkills("JavaScript", "Algorithms").build();

    // Manually added - Job's details found in {@code CommandTestUtil}
    public static final Job INTERN = new JobBuilder().withPosition("Intern").withTeam("Human Resources")
            .withLocation("Kuala Lampur, Malaysia").withNumberOfPositions("5").withSkills("Algorithms").build();
    public static final Job DATA_SCIENTIST = new JobBuilder().withPosition("Data Scientist").withTeam("Data Science")
            .withLocation("Singapore").withNumberOfPositions("1").withSkills("Analysis").build();

    public static final String KEYWORD_MATCHING_POSITION_ENGINEER = "Engineer"; // A keyword that matches Engineer
    public static final String KEYWORD_MATCHING_LOCATION_SINGAPORE = "Singapore"; // A keyword that matches Singapore
    public static final String KEYWORD_MATCHING_SKILL_JAVA = "Java"; // A keyword that matches Java

    private TypicalJobs() {} // prevents instantiation

    /**
     * Returns an {@code AddressBook} with all the typical persons.
     */
    public static AddressBook getTypicalAddressBook() {
        AddressBook ab = new AddressBook();
        for (Job job : getTypicalJobs()) {
            try {
                ab.addJob(job);
            } catch (DuplicateJobException e) {
                throw new AssertionError("not possible");
            }
        }
        return ab;
    }

    public static List<Job> getTypicalJobs() {
        return new ArrayList<>(Arrays.asList(SOFTWARE_ENGINEER, MARKETING_INTERN, DEVOPS_ENGINEER, PRODUCT_MANAGER));
    }
}

```
###### \java\seedu\address\testutil\TypicalJobsAndPersons.java
``` java
package seedu.address.testutil;

import seedu.address.model.AddressBook;
import seedu.address.model.job.Job;
import seedu.address.model.job.exceptions.DuplicateJobException;

/**
 * A utility class containing a list of {@code Person} and {@code Jobs} objects to be used in tests.
 */
public class TypicalJobsAndPersons {

    /**
     * Returns an {@code AddressBook} with all the typical persons.
     */
    public static AddressBook getTypicalAddressBook() {
        AddressBook ab = TypicalPersons.getTypicalAddressBook();
        for (Job job : TypicalJobs.getTypicalJobs()) {
            try {
                ab.addJob(job);
            } catch (DuplicateJobException e) {
                throw new AssertionError("not possible");
            }
        }
        return ab;
    }
}
```
###### \java\seedu\address\ui\ContactDetailsDisplayTest.java
``` java
package seedu.address.ui;

import static org.junit.Assert.assertEquals;
import static seedu.address.testutil.EventsUtil.postNow;

import org.junit.Before;
import org.junit.Test;

import guitests.guihandles.ContactDetailsDisplayHandle;
import seedu.address.commons.events.ui.PersonPanelSelectionChangedEvent;
import seedu.address.model.person.Person;
import seedu.address.testutil.PersonBuilder;

public class ContactDetailsDisplayTest extends GuiUnitTest {

    private ContactDetailsDisplayHandle contactDetailsDisplayHandle;

    @Before
    public void setUp() {
        ContactDetailsDisplay contactDetailsDisplay = new ContactDetailsDisplay();
        uiPartRule.setUiPart(contactDetailsDisplay);

        contactDetailsDisplayHandle = new ContactDetailsDisplayHandle(contactDetailsDisplay.getRoot());
    }

    @Test
    public void display() {

        // new result received
        Person person = new PersonBuilder().build();
        PersonCard personCard = new PersonCard(person, 0);

        postNow(new PersonPanelSelectionChangedEvent(personCard));
        guiRobot.pauseForHuman();

        assertEquals(person.getName().fullName, contactDetailsDisplayHandle.getName());
        assertEquals(person.getName().fullName, contactDetailsDisplayHandle.getFullName());
        assertEquals(person.getPhone().value, contactDetailsDisplayHandle.getPhone());
        assertEquals(person.getEmail().value, contactDetailsDisplayHandle.getEmail());
    }
}
```
###### \java\seedu\address\ui\DetailsPanelTest.java
``` java
package seedu.address.ui;

import static org.junit.Assert.assertEquals;
import static seedu.address.testutil.EventsUtil.postNow;

import org.junit.Before;
import org.junit.Test;

import guitests.guihandles.DetailsPanelHandle;
import seedu.address.commons.events.ui.SwitchTabRequestEvent;

public class DetailsPanelTest extends GuiUnitTest {

    private DetailsPanelHandle detailsPanelHandle;

    @Before
    public void setUp() {
        DetailsPanel detailsPanel = new DetailsPanel();
        uiPartRule.setUiPart(detailsPanel);

        detailsPanelHandle = new DetailsPanelHandle(getChildNode(detailsPanel.getRoot(), "#tabPane"));
    }

    @Test
    public void display() {
        // default tab
        assertEquals(0, detailsPanelHandle.getCurrentTab());

        postNow(new SwitchTabRequestEvent(1));
        assertEquals(1, detailsPanelHandle.getCurrentTab());
        postNow(new SwitchTabRequestEvent(0));
        assertEquals(0, detailsPanelHandle.getCurrentTab());
        postNow(new SwitchTabRequestEvent(2));
        assertEquals(2, detailsPanelHandle.getCurrentTab());
    }
}
```
###### \java\seedu\address\ui\JobCardTest.java
``` java
package seedu.address.ui;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.address.ui.testutil.GuiTestAssert.assertCardDisplaysJob;

import org.junit.Test;

import guitests.guihandles.JobCardHandle;
import seedu.address.model.job.Job;
import seedu.address.testutil.JobBuilder;

public class JobCardTest extends GuiUnitTest {
    @Test
    public void display() {

        // sample job
        Job job = new JobBuilder().build();
        JobCard jobCard = new JobCard(job, 1);
        uiPartRule.setUiPart(jobCard);
        assertCardDisplay(jobCard, job, 1);
    }

    @Test
    public void equals() {
        Job job = new JobBuilder().build();
        JobCard jobCard = new JobCard(job, 0);

        // same job, same index -> returns true
        JobCard copy = new JobCard(job, 0);
        assertTrue(jobCard.equals(copy));

        // same object -> returns true
        assertTrue(jobCard.equals(jobCard));

        // null -> returns false
        assertFalse(jobCard.equals(null));

        // different types -> returns false
        assertFalse(jobCard.equals(0));

        // different job, same index -> returns false
        Job differentJob = new JobBuilder().withPosition("differentPosition").build();
        assertFalse(jobCard.equals(new JobCard(differentJob, 0)));

        // same job, different index -> returns false
        assertFalse(jobCard.equals(new JobCard(job, 1)));
    }

    /**
     * Asserts that {@code jobCard} displays the details of {@code expectedJob} correctly and matches
     * {@code expectedId}.
     */
    private void assertCardDisplay(JobCard jobCard, Job expectedJob, int expectedId) {
        guiRobot.pauseForHuman();

        JobCardHandle jobCardHandle = new JobCardHandle(jobCard.getRoot());

        // verify id is displayed correctly
        assertEquals(Integer.toString(expectedId) + ". ", jobCardHandle.getId());

        // verify job details are displayed correctly
        assertCardDisplaysJob(expectedJob, jobCardHandle);
    }
}
```
###### \java\seedu\address\ui\JobListPanelTest.java
``` java
package seedu.address.ui;

import static org.junit.Assert.assertEquals;
import static seedu.address.testutil.EventsUtil.postNow;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND;
import static seedu.address.testutil.TypicalJobs.getTypicalJobs;
import static seedu.address.ui.testutil.GuiTestAssert.assertCardDisplaysJob;
import static seedu.address.ui.testutil.GuiTestAssert.assertCardEquals;

import org.junit.Before;
import org.junit.Test;

import guitests.guihandles.JobCardHandle;
import guitests.guihandles.JobListPanelHandle;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.address.commons.events.ui.JumpToJobListRequestEvent;
import seedu.address.model.job.Job;

public class JobListPanelTest extends GuiUnitTest {
    private static final ObservableList<Job> TYPICAL_JOBS =
            FXCollections.observableList(getTypicalJobs());

    private static final JumpToJobListRequestEvent JUMP_TO_SECOND_EVENT = new JumpToJobListRequestEvent(INDEX_SECOND);

    private JobListPanelHandle jobListPanelHandle;

    @Before
    public void setUp() {
        JobListPanel jobListPanel = new JobListPanel(TYPICAL_JOBS);
        uiPartRule.setUiPart(jobListPanel);

        jobListPanelHandle = new JobListPanelHandle(getChildNode(jobListPanel.getRoot(),
                JobListPanelHandle.JOB_LIST_VIEW_ID));
    }

    @Test
    public void display() {
        for (int i = 0; i < TYPICAL_JOBS.size(); i++) {
            jobListPanelHandle.navigateToCard(TYPICAL_JOBS.get(i));
            Job expectedJob = TYPICAL_JOBS.get(i);
            JobCardHandle actualCard = jobListPanelHandle.getJobCardHandle(i);

            assertCardDisplaysJob(expectedJob, actualCard);
            assertEquals(Integer.toString(i + 1) + ". ", actualCard.getId());
        }
    }

    @Test
    public void handleJumpToListRequestEvent() {
        postNow(JUMP_TO_SECOND_EVENT);
        guiRobot.pauseForHuman();

        JobCardHandle expectedCard = jobListPanelHandle.getJobCardHandle(INDEX_SECOND.getZeroBased());
        JobCardHandle selectedCard = jobListPanelHandle.getHandleToSelectedCard();
        assertCardEquals(expectedCard, selectedCard);
    }

}
```
###### \java\systemtests\AddressBookSystemTest.java
``` java
    public JobListPanelHandle getJobListPanel() {
        return mainWindowHandle.getJobListPanel();
    }

    public MainMenuHandle getMainMenu() {
        return mainWindowHandle.getMainMenu();
    }

    public BrowserPanelHandle getBrowserPanel() {
        return mainWindowHandle.getBrowserPanel();
    }

    public StatusBarFooterHandle getStatusBarFooter() {
        return mainWindowHandle.getStatusBarFooter();
    }

    public ResultDisplayHandle getResultDisplay() {
        return mainWindowHandle.getResultDisplay();
    }

    /**
     * Executes {@code command} in the application's {@code CommandBox}.
     * Method returns after UI components have been updated.
     */
    protected void executeCommand(String command) {
        rememberStates();
        // Injects a fixed clock before executing a command so that the time stamp shown in the status bar
        // after each command is predictable and also different from the previous command.
        clockRule.setInjectedClockToCurrentTime();

        mainWindowHandle.getCommandBox().run(command);
    }

    /**
     * Displays all persons in the address book.
     */
    protected void showAllPersons() {
        executeCommand(ListCommand.COMMAND_WORD);
        assertEquals(getModel().getAddressBook().getPersonList().size(), getModel().getFilteredPersonList().size());
    }

    /**
     * Displays all persons with any parts of their names matching {@code keyword} (case-insensitive).
     */
    protected void showPersonsWithName(String keyword) {
        executeCommand(FindCommand.COMMAND_WORD + " n/" + keyword);
        assertTrue(getModel().getFilteredPersonList().size() < getModel().getAddressBook().getPersonList().size());
    }

```
###### \java\systemtests\AddressBookSystemTest.java
``` java

    /**
     * Displays all persons in the address book.
     */
    protected void showAllJobs() {
        executeCommand(JobListCommand.COMMAND_WORD);
        assertEquals(getModel().getAddressBook().getPersonList().size(), getModel().getFilteredPersonList().size());
    }

    /**
     * Displays all jobs with any parts of their positions matching {@code keyword} (case-insensitive).
     */
    protected void showJobsWithPosition(String keyword) {
        executeCommand(JobFindCommand.COMMAND_WORD + " p/" + keyword);
        assertTrue(getModel().getFilteredJobList().size() < getModel().getAddressBook().getJobList().size());
    }

```
###### \java\systemtests\job\JobAddCommandSystemTest.java
``` java
package systemtests.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_LOCATION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_NUMBER_OF_POSITIONS_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_POSITION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_SKILL_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_TEAM_DESC;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_ALGORITHMS;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_EXCEL;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_LOCATION_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_LOCATION_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_NUMBER_OF_POSITIONS_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_POSITION_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_POSITION_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_ALGORITHMS;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.VALID_TEAM_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_TEAM_INTERN;
import static seedu.address.testutil.TypicalJobs.DEVELOPER_INTERN;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.logic.commands.job.JobAddCommand;
import seedu.address.model.Model;
import seedu.address.model.job.Job;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.model.job.exceptions.DuplicateJobException;
import seedu.address.model.skill.Skill;
import seedu.address.testutil.JobBuilder;
import seedu.address.testutil.JobUtil;
import systemtests.AddressBookSystemTest;

public class JobAddCommandSystemTest extends AddressBookSystemTest {

    @Test
    public void add() throws Exception {
        Model model = getModel();

        /* ------------------------ Perform add operations on the shown unfiltered list ----------------------------- */

        /* Case: add a job to a non-empty address book, command with leading spaces and trailing spaces
         * -> added
         */
        Job toAdd = DEVELOPER_INTERN;
        String command = "   " + JobAddCommand.COMMAND_WORD + "  " + POSITION_DESC_DEVELOPER_INTERN + " "
                + TEAM_DESC_DEVELOPER_INTERN + " " + LOCATION_DESC_DEVELOPER_INTERN + " "
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + " " + SKILL_DESC_JAVASCRIPT + " " + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* Case: undo adding Software Engineer to the list -> Software Engineer deleted */
        command = UndoCommand.COMMAND_WORD;
        String expectedResultMessage = UndoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, model, expectedResultMessage);

        /* Case: redo adding Software Engineer to the list -> Software Engineer added again */
        command = RedoCommand.COMMAND_WORD;
        model.addJob(toAdd);
        expectedResultMessage = RedoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, model, expectedResultMessage);

        /* Case: add a job with all fields same as another job in the address book except position -> added */
        toAdd = new JobBuilder().withPosition(VALID_POSITION_INTERN).withTeam(VALID_TEAM_DEVELOPER_INTERN)
                .withLocation(VALID_LOCATION_DEVELOPER_INTERN)
                .withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN)
                .withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_ALGORITHMS).build();
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + SKILL_DESC_JAVASCRIPT + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* Case: add a job with all fields same as another job in the address book except team -> added */
        toAdd = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN).withTeam(VALID_TEAM_INTERN)
                .withLocation(VALID_LOCATION_DEVELOPER_INTERN)
                .withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN)
                .withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_ALGORITHMS).build();
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + SKILL_DESC_JAVASCRIPT + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* Case: add a job with all fields same as another job in the address book except location -> added */
        toAdd = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN).withTeam(VALID_TEAM_DEVELOPER_INTERN)
                .withLocation(VALID_LOCATION_INTERN).withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN)
                .withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_ALGORITHMS).build();
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + SKILL_DESC_JAVASCRIPT + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* Case: add a job with all fields same as another job in the address book except numberOfPositions -> added */
        toAdd = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN).withTeam(VALID_TEAM_DEVELOPER_INTERN)
                .withLocation(VALID_LOCATION_DEVELOPER_INTERN).withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_INTERN)
                .withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_ALGORITHMS).build();
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_JAVASCRIPT
                + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* ----------------------------------- Perform invalid add operations --------------------------------------- */

        /* Case: add a duplicate job -> rejected */
        command = JobUtil.getJobAddCommand(DEVELOPER_INTERN);
        assertCommandFailure(command, JobAddCommand.MESSAGE_DUPLICATE_JOB);

        /* Case: missing position -> rejected */
        command = JobAddCommand.COMMAND_WORD + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: missing team -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + LOCATION_DESC_INTERN
                + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: missing location -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: missing numberOfPositions -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN + LOCATION_DESC_INTERN
                + SKILL_DESC_EXCEL;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: missing tags -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: invalid keyword -> rejected */
        command = "adds " + JobUtil.getJobDetails(toAdd);
        assertCommandFailure(command, Messages.MESSAGE_UNKNOWN_COMMAND);

        /* Case: invalid position -> rejected */
        command = JobAddCommand.COMMAND_WORD + INVALID_POSITION_DESC + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, Position.MESSAGE_POSITION_CONSTRAINTS);

        /* Case: invalid team -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + INVALID_TEAM_DESC
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, Team.MESSAGE_TEAM_CONSTRAINTS);

        /* Case: invalid location -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + INVALID_LOCATION_DESC + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, Location.MESSAGE_LOCATION_CONSTRAINTS);

        /* Case: invalid numberOfPositions -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + INVALID_NUMBER_OF_POSITIONS_DESC + SKILL_DESC_EXCEL;
        assertCommandFailure(command, NumberOfPositions.MESSAGE_NUMBER_OF_POSITIONS_CONSTRAINTS);

        /* Case: invalid skill -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + INVALID_SKILL_DESC;
        assertCommandFailure(command, Skill.MESSAGE_SKILL_CONSTRAINTS);
    }

    /**
     * Executes the {@code JobAddCommand} that adds {@code toAdd} to the model and asserts that the,<br>
     * 1. Command box displays an empty string.<br>
     * 2. Command box has the default style class.<br>
     * 3. Result display box displays the success message of executing {@code JobAddCommand} with the details of
     * {@code toAdd}.<br>
     * 4. {@code Model}, {@code Storage} and {@code JobListPanel} equal to the corresponding components in
     * the current model added with {@code toAdd}.<br>
     * 5. Browser url and selected card remain unchanged.<br>
     * 6. Status bar's sync status changes.<br>
     * Verifications 1, 3 and 4 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(Job toAdd) {
        assertCommandSuccess(JobUtil.getJobAddCommand(toAdd), toAdd);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(Job)}. Executes {@code command}
     * instead.
     * @see JobAddCommandSystemTest#assertCommandSuccess(Job)
     */
    private void assertCommandSuccess(String command, Job toAdd) {
        Model expectedModel = getModel();
        try {
            expectedModel.addJob(toAdd);
        } catch (DuplicateJobException dpe) {
            throw new IllegalArgumentException("toAdd already exists in the model.");
        }
        String expectedResultMessage = String.format(JobAddCommand.MESSAGE_SUCCESS, toAdd);

        assertCommandSuccess(command, expectedModel, expectedResultMessage);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Job)} except asserts that
     * the,<br>
     * 1. Result display box displays {@code expectedResultMessage}.<br>
     * 2. {@code Model}, {@code Storage} and {@code JobListPanel} equal to the corresponding components in
     * {@code expectedModel}.<br>
     * @see JobAddCommandSystemTest#assertCommandSuccess(String, Job)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage) {
        executeCommand(command);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);
        assertSelectedJobCardUnchanged();
        assertCommandBoxShowsDefaultStyle();
        assertStatusBarUnchangedExceptSyncStatus();
    }

    /**
     * Executes {@code command} and asserts that the,<br>
     * 1. Command box displays {@code command}.<br>
     * 2. Command box has the error style class.<br>
     * 3. Result display box displays {@code expectedResultMessage}.<br>
     * 4. {@code Model}, {@code Storage} and {@code JobListPanel} remain unchanged.<br>
     * 5. Browser url, selected card and status bar remain unchanged.<br>
     * Verifications 1, 3 and 4 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedJobCardUnchanged();
        assertCommandBoxShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
###### \java\systemtests\job\JobDeleteCommandSystemTest.java
``` java
package systemtests.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX;
import static seedu.address.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;
import static seedu.address.logic.commands.job.JobDeleteCommand.MESSAGE_DELETE_JOB_SUCCESS;
import static seedu.address.testutil.TestUtil.getJob;
import static seedu.address.testutil.TestUtil.getLastJobIndex;
import static seedu.address.testutil.TestUtil.getMidJobIndex;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.logic.commands.job.JobDeleteCommand;
import seedu.address.model.Model;
import seedu.address.model.job.Job;
import seedu.address.model.job.exceptions.JobNotFoundException;
import systemtests.AddressBookSystemTest;

public class JobDeleteCommandSystemTest extends AddressBookSystemTest {

    private static final String MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT =
            String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, JobDeleteCommand.MESSAGE_USAGE);

    @Test
    public void delete() {
        /* ----------------- Performing delete operation while an unfiltered list is being shown -------------------- */

        /* Case: delete the first Job in the list, command with leading spaces and trailing spaces -> deleted */
        Model expectedModel = getModel();
        String command = "     " + JobDeleteCommand.COMMAND_WORD + "      " + INDEX_FIRST.getOneBased() + "       ";
        Job deletedJob = removeJob(expectedModel, INDEX_FIRST);
        String expectedResultMessage = String.format(MESSAGE_DELETE_JOB_SUCCESS, deletedJob);
        assertCommandSuccess(command, expectedModel, expectedResultMessage);

        /* Case: delete the last Job in the list -> deleted */
        Model modelBeforeDeletingLast = getModel();
        Index lastJobIndex = getLastJobIndex(modelBeforeDeletingLast);
        assertCommandSuccess(lastJobIndex);

        /* Case: undo deleting the last Job in the list -> last Job restored */
        command = UndoCommand.COMMAND_WORD;
        expectedResultMessage = UndoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, modelBeforeDeletingLast, expectedResultMessage);

        /* Case: redo deleting the last Job in the list -> last Job deleted again */
        command = RedoCommand.COMMAND_WORD;
        removeJob(modelBeforeDeletingLast, lastJobIndex);
        expectedResultMessage = RedoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, modelBeforeDeletingLast, expectedResultMessage);

        /* Case: delete the middle Job in the list -> deleted */
        Index middleJobIndex = getMidJobIndex(getModel());
        assertCommandSuccess(middleJobIndex);

        /* ------------------ Performing delete operation while a filtered list is being shown ---------------------- */

        //        /* Case: filtered Job list, delete index within bounds of address book and Job list -> deleted */
        //        showJobsWithName(KEYWORD_MATCHING_MEIER);
        //        Index index = INDEX_FIRST;
        //        assertTrue(index.getZeroBased() < getModel().getFilteredJobList().size());
        //        assertCommandSuccess(index);
        //
        //        /* Case: filtered Job list, delete index within bounds of address book but out of bounds of Job list
        //         * -> rejected
        //         */
        //        showJobsWithName(KEYWORD_MATCHING_MEIER);
        //        int invalidIndex = getModel().getAddressBook().getJobList().size();
        //        command = JobDeleteCommand.COMMAND_WORD + " " + invalidIndex;
        //        assertCommandFailure(command, MESSAGE_INVALID_JOB_DISPLAYED_INDEX);
        //
        // /* --------------------- Performing delete operation while a Job card is selected ------------------------ */
        //
        //        /* Case: delete the selected Job -> Job list panel selects the Job before the deleted Job */
        //        showAllJobs();
        //        expectedModel = getModel();
        //        Index selectedIndex = getLastPersonIndex(expectedModel);
        //        Index expectedIndex = Index.fromZeroBased(selectedIndex.getZeroBased() - 1);
        //        selectJob(selectedIndex);
        //        command = JobDeleteCommand.COMMAND_WORD + " " + selectedIndex.getOneBased();
        //        deletedJob = removeJob(expectedModel, selectedIndex);
        //        expectedResultMessage = String.format(MESSAGE_DELETE_JOB_SUCCESS, deletedJob);
        //        assertCommandSuccess(command, expectedModel, expectedResultMessage, expectedIndex);

        /* --------------------------------- Performing invalid delete operation ------------------------------------ */

        /* Case: invalid index (0) -> rejected */
        command = JobDeleteCommand.COMMAND_WORD + " 0";
        assertCommandFailure(command, MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT);

        /* Case: invalid index (-1) -> rejected */
        command = JobDeleteCommand.COMMAND_WORD + " -1";
        assertCommandFailure(command, MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT);

        /* Case: invalid index (size + 1) -> rejected */
        Index outOfBoundsIndex = Index.fromOneBased(
                getModel().getAddressBook().getJobList().size() + 1);
        command = JobDeleteCommand.COMMAND_WORD + " " + outOfBoundsIndex.getOneBased();
        assertCommandFailure(command, MESSAGE_INVALID_JOB_DISPLAYED_INDEX);

        /* Case: invalid arguments (alphabets) -> rejected */
        assertCommandFailure(JobDeleteCommand.COMMAND_WORD + " abc",
                MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT);

        /* Case: invalid arguments (extra argument) -> rejected */
        assertCommandFailure(JobDeleteCommand.COMMAND_WORD + " 1 abc",
                MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT);

        /* Case: mixed case command word -> rejected */
        assertCommandFailure("DelETE 1", MESSAGE_UNKNOWN_COMMAND);
    }

    /**
     * Removes the {@code Job} at the specified {@code index} in {@code model}'s address book.
     * @return the removed Job
     */
    private Job removeJob(Model model, Index index) {
        Job targetJob = getJob(model, index);
        try {
            model.deleteJob(targetJob);
        } catch (JobNotFoundException pnfe) {
            throw new AssertionError("targetJob is retrieved from model.");
        }
        return targetJob;
    }

    /**
     * JobDeletes the Job at {@code toJobDelete} by creating a default {@code JobDeleteCommand}
     * using {@code toJobDelete} and performs the same verification as
     * {@code assertCommandSuccess(String, Model, String)}.
     * @see JobDeleteCommandSystemTest#assertCommandSuccess(String, Model, String)
     */
    private void assertCommandSuccess(Index toJobDelete) {
        Model expectedModel = getModel();
        Job deletedJob = removeJob(expectedModel, toJobDelete);
        String expectedResultMessage = String.format(MESSAGE_DELETE_JOB_SUCCESS, deletedJob);

        assertCommandSuccess(
                JobDeleteCommand.COMMAND_WORD + " " + toJobDelete.getOneBased(), expectedModel, expectedResultMessage);
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays an empty string.<br>
     * 2. Asserts that the result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to {@code expectedModel}.<br>
     * 4. Asserts that the browser url and selected card remains unchanged.<br>
     * 5. Asserts that the status bar's sync status changes.<br>
     * 6. Asserts that the command box has the default style class.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage) {
        assertCommandSuccess(command, expectedModel, expectedResultMessage, null);
    }

```
###### \java\systemtests\job\JobEditCommandSystemTest.java
``` java
package systemtests.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_LOCATION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_NUMBER_OF_POSITIONS_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_POSITION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_SKILL_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_TEAM_DESC;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_ALGORITHMS;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_FRIEND;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_LOCATION_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_NUMBER_OF_POSITIONS_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_POSITION_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_ALGORITHMS;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_FRIEND;
import static seedu.address.logic.commands.CommandTestUtil.VALID_TEAM_INTERN;
import static seedu.address.model.Model.PREDICATE_SHOW_ALL_JOBS;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;
import static seedu.address.testutil.TypicalJobs.DEVELOPER_INTERN;
import static seedu.address.testutil.TypicalJobs.INTERN;
import static seedu.address.testutil.TypicalJobs.KEYWORD_MATCHING_POSITION_ENGINEER;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.logic.commands.job.JobEditCommand;
import seedu.address.model.Model;
import seedu.address.model.job.Job;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.model.job.exceptions.DuplicateJobException;
import seedu.address.model.job.exceptions.JobNotFoundException;
import seedu.address.model.skill.Skill;
import seedu.address.testutil.JobBuilder;
import seedu.address.testutil.JobUtil;
import systemtests.AddressBookSystemTest;

public class JobEditCommandSystemTest extends AddressBookSystemTest {

    @Test
    public void edit() throws Exception {
        Model model = getModel();

        /* ----------------- Performing edit operation while an unfiltered list is being shown ---------------------- */

        /* Case: edit all fields, command with leading spaces, trailing spaces and multiple spaces between each field
         * -> edited
         */
        Index index = INDEX_FIRST;
        String command = " " + JobEditCommand.COMMAND_WORD + "  " + index.getOneBased() + "  "
                + POSITION_DESC_INTERN + "  " + TEAM_DESC_INTERN + " " + LOCATION_DESC_INTERN + "  "
                + NUMBER_OF_POSITIONS_DESC_INTERN + " " + SKILL_DESC_ALGORITHMS + " ";
        Job editedJob = new JobBuilder().withPosition(VALID_POSITION_INTERN).withTeam(VALID_TEAM_INTERN)
                .withLocation(VALID_LOCATION_INTERN).withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_INTERN)
                .withSkills(VALID_SKILL_ALGORITHMS).build();
        assertCommandSuccess(command, index, editedJob);

        /* Case: undo editing the last job in the list -> last job restored */
        command = UndoCommand.COMMAND_WORD;
        String expectedResultMessage = UndoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, model, expectedResultMessage);

        /* Case: redo editing the last job in the list -> last job edited again */
        command = RedoCommand.COMMAND_WORD;
        expectedResultMessage = RedoCommand.MESSAGE_SUCCESS;
        model.updateJob(getModel().getFilteredJobList().get(INDEX_FIRST.getZeroBased()), editedJob);
        assertCommandSuccess(command, model, expectedResultMessage);

        /* Case: edit a job with new values same as existing values -> edited */
        command = " " + JobEditCommand.COMMAND_WORD + "  " + index.getOneBased() + "  " + POSITION_DESC_INTERN + "  "
                + TEAM_DESC_INTERN + " " + LOCATION_DESC_INTERN + "  " + NUMBER_OF_POSITIONS_DESC_INTERN
                + " " + SKILL_DESC_ALGORITHMS + " ";
        assertCommandSuccess(command, index, INTERN);

        /* Case: edit some fields -> edited */
        index = INDEX_FIRST;
        command = JobEditCommand.COMMAND_WORD + " " + index.getOneBased() + SKILL_DESC_FRIEND;
        Job jobToEdit = getModel().getFilteredJobList().get(index.getZeroBased());
        editedJob = new JobBuilder(jobToEdit).withSkills(VALID_SKILL_FRIEND).build();
        assertCommandSuccess(command, index, editedJob);

        /* ------------------ Performing edit operation while a filtered list is being shown ------------------------ */

        /* Case: filtered job list, edit index within bounds of address book and job list -> edited */
        showJobsWithPosition(KEYWORD_MATCHING_POSITION_ENGINEER);
        index = INDEX_FIRST;
        assertTrue(index.getZeroBased() < getModel().getFilteredJobList().size());
        command = JobEditCommand.COMMAND_WORD + " " + index.getOneBased() + " " + POSITION_DESC_INTERN;
        jobToEdit = getModel().getFilteredJobList().get(index.getZeroBased());
        editedJob = new JobBuilder(jobToEdit).withPosition(VALID_POSITION_INTERN).build();
        assertCommandSuccess(command, index, editedJob);

        /* Case: filtered job list, edit index within bounds of address book but out of bounds of job list
         * -> rejected
         */
        showJobsWithPosition(KEYWORD_MATCHING_POSITION_ENGINEER);
        int invalidIndex = getModel().getAddressBook().getJobList().size();
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " " + invalidIndex + POSITION_DESC_INTERN,
                Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX);

        /* --------------------------------- Performing invalid edit operation -------------------------------------- */

        /* Case: invalid index (0) -> rejected */
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " 0" + POSITION_DESC_INTERN,
                String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, JobEditCommand.MESSAGE_USAGE));

        /* Case: invalid index (-1) -> rejected */
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " -1" + POSITION_DESC_INTERN,
              String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, JobEditCommand.MESSAGE_USAGE));

        /* Case: invalid index (size + 1) -> rejected */
        invalidIndex = getModel().getFilteredJobList().size() + 1;
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " " + invalidIndex + POSITION_DESC_INTERN,
                Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX);

        /* Case: missing index -> rejected */
        assertCommandFailure(JobEditCommand.COMMAND_WORD + POSITION_DESC_INTERN,
                String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, JobEditCommand.MESSAGE_USAGE));

        /* Case: missing all fields -> rejected */
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased(),
                JobEditCommand.MESSAGE_NOT_EDITED);

        /* Case: invalid position -> rejected */
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased()
                        + INVALID_POSITION_DESC,
                Position.MESSAGE_POSITION_CONSTRAINTS);

        /* Case: invalid team -> rejected */
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased() + INVALID_TEAM_DESC,
                Team.MESSAGE_TEAM_CONSTRAINTS);

        /* Case: invalid location -> rejected */
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased()
                + INVALID_LOCATION_DESC, Location.MESSAGE_LOCATION_CONSTRAINTS);

        /* Case: invalid number of positions -> rejected */
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased()
                        + INVALID_NUMBER_OF_POSITIONS_DESC,
                NumberOfPositions.MESSAGE_NUMBER_OF_POSITIONS_CONSTRAINTS);

        /* Case: invalid skill -> rejected */
        assertCommandFailure(JobEditCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased()
                        + INVALID_SKILL_DESC,
                Skill.MESSAGE_SKILL_CONSTRAINTS);

        /* Case: edit a job with new values same as another job's values -> rejected */
        executeCommand(JobUtil.getJobAddCommand(DEVELOPER_INTERN));
        assertTrue(getModel().getAddressBook().getJobList().contains(DEVELOPER_INTERN));
        index = INDEX_FIRST;
        assertFalse(getModel().getFilteredJobList().get(index.getZeroBased()).equals(DEVELOPER_INTERN));
        command = " " + JobEditCommand.COMMAND_WORD + "  " + index.getOneBased() + "  "
                + POSITION_DESC_DEVELOPER_INTERN + "  " + TEAM_DESC_DEVELOPER_INTERN + " "
                + LOCATION_DESC_DEVELOPER_INTERN + "  " + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + " "
                + SKILL_DESC_JAVASCRIPT + " " + SKILL_DESC_ALGORITHMS;
        assertCommandFailure(command, JobEditCommand.MESSAGE_DUPLICATE_JOB);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Index, Job, Index)} except that
     * the browser url and selected card remain unchanged.
     * @param toEdit the index of the current model's filtered list
     * @see JobEditCommandSystemTest#assertCommandSuccess(String, Index, Job, Index)
     */
    private void assertCommandSuccess(String command, Index toEdit, Job editedJob) {
        assertCommandSuccess(command, toEdit, editedJob, null);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Model, String, Index)} and in addition,<br>
     * 1. Asserts that result display box displays the success message of executing {@code JobEditCommand}.<br>
     * 2. Asserts that the model related components are updated to reflect the job at index {@code toEdit} being
     * updated to values specified {@code editedJob}.<br>
     * @param toEdit the index of the current model's filtered list.
     * @see JobEditCommandSystemTest#assertCommandSuccess(String, Model, String, Index)
     */
    private void assertCommandSuccess(String command, Index toEdit, Job editedJob,
                                      Index expectedSelectedCardIndex) {
        Model expectedModel = getModel();
        try {
            expectedModel.updateJob(
                    expectedModel.getFilteredJobList().get(toEdit.getZeroBased()), editedJob);
            expectedModel.updateFilteredJobList(PREDICATE_SHOW_ALL_JOBS);
        } catch (DuplicateJobException | JobNotFoundException e) {
            throw new IllegalArgumentException(
                    "editedJob is a duplicate in expectedModel, or it isn't found in the model.");
        }

        assertCommandSuccess(command, expectedModel,
                String.format(JobEditCommand.MESSAGE_EDIT_JOB_SUCCESS, editedJob), expectedSelectedCardIndex);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Model, String, Index)} except that the
     * browser url and selected card remain unchanged.
     * @see JobEditCommandSystemTest#assertCommandSuccess(String, Model, String, Index)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage) {
        assertCommandSuccess(command, expectedModel, expectedResultMessage, null);
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays an empty string.<br>
     * 2. Asserts that the result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to {@code expectedModel}.<br>
     * 4. Asserts that the browser url and selected card update accordingly depending on the card at
     * {@code expectedSelectedCardIndex}.<br>
     * 5. Asserts that the status bar's sync status changes.<br>
     * 6. Asserts that the command box has the default style class.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     * @see AddressBookSystemTest#assertSelectedCardChanged(Index)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage,
                                      Index expectedSelectedCardIndex) {
        executeCommand(command);
        expectedModel.updateFilteredJobList(PREDICATE_SHOW_ALL_JOBS);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);
        assertCommandBoxShowsDefaultStyle();
        if (expectedSelectedCardIndex != null) {
            assertSelectedCardChanged(expectedSelectedCardIndex);
        } else {
            assertSelectedCardUnchanged();
        }
        assertStatusBarUnchangedExceptSyncStatus();
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays {@code command}.<br>
     * 2. Asserts that result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to the current model.<br>
     * 4. Asserts that the browser url, selected card and status bar remain unchanged.<br>
     * 5. Asserts that the command box has the error style.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedCardUnchanged();
        assertCommandBoxShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
###### \java\systemtests\job\JobFindCommandSystemTest.java
``` java
package systemtests.job;

import static org.junit.Assert.assertFalse;
import static seedu.address.commons.core.Messages.MESSAGE_JOBS_LISTED_OVERVIEW;
import static seedu.address.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;
import static seedu.address.testutil.TypicalJobs.DEVOPS_ENGINEER;
import static seedu.address.testutil.TypicalJobs.KEYWORD_MATCHING_LOCATION_SINGAPORE;
import static seedu.address.testutil.TypicalJobs.KEYWORD_MATCHING_POSITION_ENGINEER;
import static seedu.address.testutil.TypicalJobs.KEYWORD_MATCHING_SKILL_JAVA;
import static seedu.address.testutil.TypicalJobs.MARKETING_INTERN;
import static seedu.address.testutil.TypicalJobs.PRODUCT_MANAGER;
import static seedu.address.testutil.TypicalJobs.SOFTWARE_ENGINEER;

import org.junit.Test;

import seedu.address.logic.commands.job.JobDeleteCommand;
import seedu.address.logic.commands.job.JobFindCommand;
import seedu.address.model.Model;
import systemtests.AddressBookSystemTest;
import systemtests.ModelHelper;

public class JobFindCommandSystemTest extends AddressBookSystemTest {

    @Test
    public void findByPosition() {
        /* Case: find multiple jobs in address book, command with leading spaces and trailing spaces
         * -> 2 jobs found
         */
        String command = "   " + JobFindCommand.COMMAND_WORD + " p/" + KEYWORD_MATCHING_POSITION_ENGINEER + "   ";
        Model expectedModel = getModel();
        ModelHelper.setFilteredJobList(expectedModel, SOFTWARE_ENGINEER, DEVOPS_ENGINEER); // position contains Engineer
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: repeat previous find command where job list is displaying the jobs we are finding
         * -> 2 jobs found
         */
        command = JobFindCommand.COMMAND_WORD + " p/" + KEYWORD_MATCHING_POSITION_ENGINEER;
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find same jobs in address book after deleting 1 of them -> 1 job found */
        executeCommand(JobDeleteCommand.COMMAND_WORD + " 1");
        assertFalse(getModel().getAddressBook().getJobList().contains(SOFTWARE_ENGINEER));
        command = JobFindCommand.COMMAND_WORD + " p/" + KEYWORD_MATCHING_POSITION_ENGINEER;
        expectedModel = getModel();
        ModelHelper.setFilteredJobList(expectedModel, DEVOPS_ENGINEER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job where job list is not displaying the job we are finding -> 1 job found */
        command = JobFindCommand.COMMAND_WORD + " p/Intern";
        ModelHelper.setFilteredJobList(expectedModel, MARKETING_INTERN);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 keywords -> 2 jobs found */
        command = JobFindCommand.COMMAND_WORD + " p/Intern Manager";
        ModelHelper.setFilteredJobList(expectedModel, MARKETING_INTERN, PRODUCT_MANAGER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 keywords in reversed order -> 2 jobs found */
        command = JobFindCommand.COMMAND_WORD + " p/Manager Intern";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 keywords with 1 repeat -> 2 jobs found */
        command = JobFindCommand.COMMAND_WORD + " p/Manager Intern Manager";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 matching keywords and 1 non-matching keyword
         * -> 2 jobs found
         */
        command = JobFindCommand.COMMAND_WORD + " p/Manager Intern NonMatchingKeyWord";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in address book, keyword is same as position but of different case -> 1 job found */
        command = JobFindCommand.COMMAND_WORD + " p/EnGINeeR";
        ModelHelper.setFilteredJobList(expectedModel, DEVOPS_ENGINEER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in address book, keyword is substring of position -> 0 jobs found */
        command = JobFindCommand.COMMAND_WORD + " p/Engin";
        ModelHelper.setFilteredJobList(expectedModel);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in address book, position is substring of keyword -> 0 jobs found */
        command = JobFindCommand.COMMAND_WORD + " p/Engineers";
        ModelHelper.setFilteredJobList(expectedModel);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job not in address book -> 0 jobs found */
        command = JobFindCommand.COMMAND_WORD + " p/Analyst";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in empty address book -> 0 jobs found */
        deleteAllPersonsAndJobs();
        command = JobFindCommand.COMMAND_WORD + " p/" + KEYWORD_MATCHING_POSITION_ENGINEER;
        expectedModel = getModel();
        ModelHelper.setFilteredJobList(expectedModel, SOFTWARE_ENGINEER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: mixed case command word -> rejected */
        command = "FiNdjOB p/eNGIneeR";
        assertCommandFailure(command, MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void findByLocation() {
        /* Case: find multiple jobs in address book, command with leading spaces and trailing spaces
         * -> 2 jobs found
         */
        String command = "   " + JobFindCommand.COMMAND_WORD + " l/" + KEYWORD_MATCHING_LOCATION_SINGAPORE + "   ";
        Model expectedModel = getModel();
        ModelHelper.setFilteredJobList(expectedModel, SOFTWARE_ENGINEER, DEVOPS_ENGINEER); // position contains Engineer
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: repeat previous find command where job list is displaying the jobs we are finding
         * -> 2 jobs found
         */
        command = JobFindCommand.COMMAND_WORD + " l/" + KEYWORD_MATCHING_LOCATION_SINGAPORE;
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find same jobs in address book after deleting 1 of them -> 1 job found */
        executeCommand(JobDeleteCommand.COMMAND_WORD + " 1");
        assertFalse(getModel().getAddressBook().getJobList().contains(SOFTWARE_ENGINEER));
        command = JobFindCommand.COMMAND_WORD + " l/" + KEYWORD_MATCHING_LOCATION_SINGAPORE;
        expectedModel = getModel();
        ModelHelper.setFilteredJobList(expectedModel, DEVOPS_ENGINEER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job where job list is not displaying the job we are finding -> 1 job found */
        command = JobFindCommand.COMMAND_WORD + " l/India";
        ModelHelper.setFilteredJobList(expectedModel, PRODUCT_MANAGER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 keywords -> 2 jobs found */
        command = JobFindCommand.COMMAND_WORD + " l/Malaysia India";
        ModelHelper.setFilteredJobList(expectedModel, MARKETING_INTERN, PRODUCT_MANAGER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 keywords in reversed order -> 2 jobs found */
        command = JobFindCommand.COMMAND_WORD + " l/India Malaysia";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 keywords with 1 repeat -> 2 jobs found */
        command = JobFindCommand.COMMAND_WORD + " l/India Malaysia India";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 matching keywords and 1 non-matching keyword
         * -> 2 jobs found
         */
        command = JobFindCommand.COMMAND_WORD + " l/India Malaysia NonMatchingKeyWord";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in address book, keyword is same as location but of different case -> 1 job found */
        command = JobFindCommand.COMMAND_WORD + " l/SinGAPoRe";
        ModelHelper.setFilteredJobList(expectedModel, DEVOPS_ENGINEER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in address book, keyword is substring of location -> 0 jobs found */
        command = JobFindCommand.COMMAND_WORD + " l/Singa";
        ModelHelper.setFilteredJobList(expectedModel);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in address book, location is substring of keyword -> 0 jobs found */
        command = JobFindCommand.COMMAND_WORD + " l/Singaporecity";
        ModelHelper.setFilteredJobList(expectedModel);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job not in address book -> 0 jobs found */
        command = JobFindCommand.COMMAND_WORD + " l/Vietnam";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in empty address book -> 0 jobs found */
        deleteAllPersonsAndJobs();
        command = JobFindCommand.COMMAND_WORD + " l/" + KEYWORD_MATCHING_LOCATION_SINGAPORE;
        expectedModel = getModel();
        ModelHelper.setFilteredJobList(expectedModel, SOFTWARE_ENGINEER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: mixed case command word -> rejected */
        command = "FiNdjOB l/SingaporE";
        assertCommandFailure(command, MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void findBySkill() {
        /* Case: find multiple jobs in address book, command with leading spaces and trailing spaces
         * -> 2 jobs found
         */
        String command = "   " + JobFindCommand.COMMAND_WORD + " s/" + KEYWORD_MATCHING_SKILL_JAVA + "   ";
        Model expectedModel = getModel();
        ModelHelper.setFilteredJobList(expectedModel, SOFTWARE_ENGINEER); // position contains Engineer"
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: repeat previous find command where job list is displaying the jobs we are finding
         * -> 2 jobs found
         */
        command = JobFindCommand.COMMAND_WORD + " s/" + KEYWORD_MATCHING_SKILL_JAVA;
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find same jobs in address book after deleting 1 of them -> 1 job found */
        executeCommand(JobDeleteCommand.COMMAND_WORD + " 1");
        assertFalse(getModel().getAddressBook().getJobList().contains(SOFTWARE_ENGINEER));
        command = JobFindCommand.COMMAND_WORD + " s/" + KEYWORD_MATCHING_SKILL_JAVA;
        expectedModel = getModel();
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job where job list is not displaying the job we are finding -> 1 job found */
        command = JobFindCommand.COMMAND_WORD + " s/Testing";
        ModelHelper.setFilteredJobList(expectedModel, PRODUCT_MANAGER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 keywords -> 2 jobs found */
        command = JobFindCommand.COMMAND_WORD + " s/Excel Testing";
        ModelHelper.setFilteredJobList(expectedModel, MARKETING_INTERN, PRODUCT_MANAGER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 keywords in reversed order -> 2 jobs found */
        command = JobFindCommand.COMMAND_WORD + " s/Testing Excel";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 keywords with 1 repeat -> 2 jobs found */
        command = JobFindCommand.COMMAND_WORD + " s/Excel Testing Excel";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find multiple jobs in address book, 2 matching keywords and 1 non-matching keyword
         * -> 2 jobs found
         */
        command = JobFindCommand.COMMAND_WORD + " s/Excel Testing NonMatchingKeyWord";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in address book, keyword is same as location but of different case -> 1 job found */
        command = JobFindCommand.COMMAND_WORD + " s/ExCEl";
        ModelHelper.setFilteredJobList(expectedModel, MARKETING_INTERN);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in address book, keyword is substring of location -> 0 jobs found */
        command = JobFindCommand.COMMAND_WORD + " s/Exc";
        ModelHelper.setFilteredJobList(expectedModel);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in address book, location is substring of keyword -> 0 jobs found */
        command = JobFindCommand.COMMAND_WORD + " s/Excels";
        ModelHelper.setFilteredJobList(expectedModel);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job not in address book -> 0 jobs found */
        command = JobFindCommand.COMMAND_WORD + " s/C++";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: find job in empty address book -> 0 jobs found */
        deleteAllPersonsAndJobs();
        command = JobFindCommand.COMMAND_WORD + " s/" + KEYWORD_MATCHING_SKILL_JAVA;
        expectedModel = getModel();
        ModelHelper.setFilteredJobList(expectedModel, SOFTWARE_ENGINEER);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: mixed case command word -> rejected */
        command = "FiNdjOB s/JaVA";
        assertCommandFailure(command, MESSAGE_UNKNOWN_COMMAND);
    }

    /**
     * Executes {@code command} and verifies that the command box displays an empty string, the result display
     * box displays {@code Messages#MESSAGE_JOBS_LISTED_OVERVIEW} with the number of people in the filtered list,
     * and the model related components equal to {@code expectedModel}.
     * These verifications are done by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * Also verifies that the status bar remains unchanged, and the command box has the default style class, and the
     * selected card updated accordingly, depending on {@code cardStatus}.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(String command, Model expectedModel) {
        String expectedResultMessage = String.format(
                MESSAGE_JOBS_LISTED_OVERVIEW, expectedModel.getFilteredJobList().size());

        executeCommand(command);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);
        assertCommandBoxShowsDefaultStyle();
        assertStatusBarUnchanged();
    }

    /**
     * Executes {@code command} and verifies that the command box displays {@code command}, the result display
     * box displays {@code expectedResultMessage} and the model related components equal to the current model.
     * These verifications are done by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * Also verifies that the browser url, selected card and status bar remain unchanged, and the command box has the
     * error style.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedCardUnchanged();
        assertCommandBoxShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
###### \java\systemtests\job\JobMatchCommandSystemTest.java
``` java
package systemtests.job;

import static org.junit.Assert.assertFalse;
import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.commons.core.Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX;
import static seedu.address.commons.core.Messages.MESSAGE_PERSONS_LISTED_OVERVIEW;
import static seedu.address.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND;
import static seedu.address.testutil.TypicalPersons.CARL;
import static seedu.address.testutil.TypicalPersons.ELLE;
import static seedu.address.testutil.TypicalPersons.FIONA;
import static seedu.address.testutil.TypicalPersons.GEORGE;

import org.junit.Test;

import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.logic.commands.job.JobMatchCommand;
import seedu.address.logic.commands.person.DeleteCommand;
import seedu.address.model.Model;
import systemtests.AddressBookSystemTest;
import systemtests.ModelHelper;

public class JobMatchCommandSystemTest extends AddressBookSystemTest {

    @Test
    public void match() {
        /* Case: match the first job in address book, command with leading spaces and trailing spaces
         * -> 2 persons found
         */
        Model expectedModel = getModel();
        String command = "   " + JobMatchCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased() + "   ";
        ModelHelper.setFilteredPersonList(expectedModel, FIONA, GEORGE); //first names of Benson and Daniel are "Meier"
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: repeat previous match command where person list is displaying the persons we are matching
         * -> 2 persons found
         */
        command = "   " + JobMatchCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased() + "   ";
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: match job where person list is not displaying the person we are matching -> 1 person found */
        command = "   " + JobMatchCommand.COMMAND_WORD + " " + INDEX_SECOND.getOneBased() + "   ";
        ModelHelper.setFilteredPersonList(expectedModel, CARL, ELLE, FIONA);
        assertCommandSuccess(command, expectedModel);
        assertSelectedCardUnchanged();

        /* Case: undo previous find command -> rejected */
        command = UndoCommand.COMMAND_WORD;
        String expectedResultMessage = UndoCommand.MESSAGE_FAILURE;
        assertCommandFailure(command, expectedResultMessage);

        /* Case: redo previous find command -> rejected */
        command = RedoCommand.COMMAND_WORD;
        expectedResultMessage = RedoCommand.MESSAGE_FAILURE;
        assertCommandFailure(command, expectedResultMessage);

        /* Case: match same job in address book after deleting 1 person -> 2 person found */
        executeCommand(DeleteCommand.COMMAND_WORD + " 1");
        assertFalse(getModel().getAddressBook().getPersonList().contains(CARL));
        command = JobMatchCommand.COMMAND_WORD + " 2";
        expectedModel = getModel();
        ModelHelper.setFilteredPersonList(expectedModel, ELLE, FIONA);
        assertCommandSuccess(command, expectedModel);

        /* ----------------------------------- Perform invalid matchJob operations --------------------------------- */

        /* Case: invalid index (0) -> rejected */
        int invalidIndex = -1;
        assertCommandFailure(JobMatchCommand.COMMAND_WORD + " " + 0,
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobMatchCommand.MESSAGE_USAGE));

        /* Case: invalid index (-1) -> rejected */
        assertCommandFailure(JobMatchCommand.COMMAND_WORD + " " + -1,
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobMatchCommand.MESSAGE_USAGE));

        /* Case: invalid index (size + 1) -> rejected */
        invalidIndex = getModel().getFilteredJobList().size() + 1;
        assertCommandFailure(JobMatchCommand.COMMAND_WORD + " "
                + invalidIndex, MESSAGE_INVALID_JOB_DISPLAYED_INDEX);

        /* Case: invalid arguments (alphabets) -> rejected */
        assertCommandFailure(JobMatchCommand.COMMAND_WORD + " abc",
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobMatchCommand.MESSAGE_USAGE));

        /* Case: invalid arguments (extra argument) -> rejected */
        assertCommandFailure(JobMatchCommand.COMMAND_WORD + " 1 abc",
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobMatchCommand.MESSAGE_USAGE));

        /* Case: mixed case command word -> rejected */
        assertCommandFailure("matCHjOb 1", MESSAGE_UNKNOWN_COMMAND);

        /* Case: match from empty address book -> rejected */
        deleteAllJobs();
        assertCommandFailure(JobMatchCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased(),
                MESSAGE_INVALID_JOB_DISPLAYED_INDEX);
    }

    /**
     * Executes {@code command} and verifies that the command box displays an empty string, the result display
     * box displays {@code Messages#MESSAGE_PERSONS_LISTED_OVERVIEW} with the number of people in the filtered list,
     * and the model related components equal to {@code expectedModel}.
     * These verifications are done by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * Also verifies that the status bar remains unchanged, and the command box has the default style class, and the
     * selected card updated accordingly, depending on {@code cardStatus}.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(String command, Model expectedModel) {
        String expectedResultMessage = String.format(
                MESSAGE_PERSONS_LISTED_OVERVIEW, expectedModel.getFilteredPersonList().size());

        executeCommand(command);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);
        assertCommandBoxShowsDefaultStyle();
        assertStatusBarUnchanged();
    }

    /**
     * Executes {@code command} and verifies that the command box displays {@code command}, the result display
     * box displays {@code expectedResultMessage} and the model related components equal to the current model.
     * These verifications are done by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * Also verifies that the browser url, selected card and status bar remain unchanged, and the command box has the
     * error style.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedCardUnchanged();
        assertCommandBoxShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
