# jas5469
###### \java\seedu\address\commons\events\ui\GroupPanelSelectionChangedEvent.java
``` java
package seedu.address.commons.events.ui;

import seedu.address.commons.events.BaseEvent;
import seedu.address.ui.GroupCard;

/**
 * Represents a selection change in the Group List Panel
 */
public class GroupPanelSelectionChangedEvent extends BaseEvent {


    private final GroupCard newSelection;

    public GroupPanelSelectionChangedEvent(GroupCard newSelection) {
        this.newSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\address\logic\commands\AddGroupCommand.java
``` java
package seedu.address.logic.commands;

import static java.util.Objects.requireNonNull;

import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.exceptions.DuplicateGroupException;

/**
 * Adds a group to the address book.
 */
public class AddGroupCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "addGroup";
    public static final String COMMAND_ALIAS = "aG";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a group to the address book. "
            + "Parameters: "
            + "GROUP NAME "
            + "Example: " + COMMAND_WORD + " "
            + "CS1010 project";

    public static final String MESSAGE_SUCCESS = "New group added: %1$s";
    public static final String MESSAGE_DUPLICATE_GROUP = "This group already exists in the address book";

    private final Group addGroup;

    /**
     * Creates an AddGroupCommand to add the specified {@code Group}
     */
    public AddGroupCommand(Group group) {
        requireNonNull(group);
        addGroup = group;
    }

    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        requireNonNull(model);
        try {
            model.addGroup(addGroup);
            return new CommandResult(String.format(MESSAGE_SUCCESS, addGroup));
        } catch (DuplicateGroupException dge) {
            throw new CommandException(MESSAGE_DUPLICATE_GROUP);
        }

    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddGroupCommand // instanceof handles nulls
                && addGroup.equals(((AddGroupCommand) other).addGroup));
    }
}
```
###### \java\seedu\address\logic\commands\AddMemberToGroupCommand.java
``` java
package seedu.address.logic.commands;

import static java.util.Objects.requireNonNull;
import static seedu.address.logic.parser.CliSyntax.PREFIX_GROUP;

import java.util.List;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.exceptions.DuplicateGroupException;
import seedu.address.model.group.exceptions.GroupNotFoundException;
import seedu.address.model.person.Person;
import seedu.address.model.person.exceptions.DuplicatePersonException;

/**
 * Finds a person by index  add him to a specific group in Fastis .
 * Keyword matching is case sensitive.
 */
public class AddMemberToGroupCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "addGroupMember";
    public static final String COMMAND_ALIAS = "aGM";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds person via index on the most recent list "
            + "and add to group that contain the specified keywords (case-sensitive).\n"
            + "Parameters: INDEX (must be a positive integer) g/GroupName(Must exist) "
            + "Example: " + COMMAND_WORD + " 1 "
            + PREFIX_GROUP + "CS1010";

    public static final String MESSAGE_NO_SUCH_GROUP = "No such group exist.";
    public static final String MESSAGE_ADD_PERSON_TO_GROUP_SUCCESS = "%1$s added to group %2$s";
    public static final String MESSAGE_DUPLICATE_PERSON = "Person already in Group";
    public static final String MESSAGE_GROUP_NOT_FOUND = "No such Group in Fastis";
    public static final String MESSAGE_DUPLICATE_GROUP = "Group already in Group";

    private Index index;
    private Person personToAdd;
    private Group groupToAdd;
    private Group groupAdded;
    private List<Group> groupList;

    public AddMemberToGroupCommand(Index index, Group groupToAdd) {
        requireNonNull(index);
        this.index = index;
        this.groupToAdd = groupToAdd;
    }


    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        requireNonNull(model);

        for (Group group : groupList) {
            if (groupToAdd.getInformation().equals(group.getInformation())) {
                try {
                    groupAdded = new Group(group.getInformation(), group.getPersonList());
                    groupAdded.addPerson(personToAdd);
                    model.updateGroup(group, groupAdded);
                } catch (DuplicatePersonException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_PERSON);
                } catch (DuplicateGroupException dge) {
                    throw new CommandException(MESSAGE_DUPLICATE_GROUP);
                } catch (GroupNotFoundException gnfe) {
                    throw new CommandException(MESSAGE_GROUP_NOT_FOUND);
                }
            }
        }
        return new CommandResult(String.format(MESSAGE_ADD_PERSON_TO_GROUP_SUCCESS, personToAdd.getName(),
                groupToAdd.getInformation().toString()));
    }

    @Override
    protected void preprocessUndoableCommand() throws CommandException {
        List<Person> lastShownList = model.getFilteredPersonList();
        groupList = model.getFilteredGroupList();
        if (index.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
        boolean contains = new Boolean(Boolean.FALSE);
        for (Group g : groupList) {
            if (g.getInformation().equals(groupToAdd.getInformation())) {
                contains = true;
            }
        }
        if (contains == false) {
            throw new CommandException(MESSAGE_NO_SUCH_GROUP);
        } else {
            personToAdd = lastShownList.get(index.getZeroBased());
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddMemberToGroupCommand // instanceof handles nulls
                && groupToAdd.equals(((AddMemberToGroupCommand) other).groupToAdd));
    }


}
```
###### \java\seedu\address\logic\commands\DeleteGroupCommand.java
``` java
package seedu.address.logic.commands;

import java.util.List;
import java.util.Objects;

import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.group.exceptions.GroupNotFoundException;

/**
 * Deletes a group identified using it's last displayed index from the address book.
 */
public class DeleteGroupCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "deleteGroup";
    public static final String COMMAND_ALIAS = "dG";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the group identified by the group Name used.\n"
            + "Parameters: GroupName(Must exist) KEYWORD ...\n"
            + "CS1010";

    public static final String MESSAGE_DELETE_GROUP_SUCCESS = "Deleted group: %1$s";
    public static final String MESSAGE_NO_SUCH_GROUP = "Group not found";

    private final Information groupName;

    private Group groupToDelete;

    public DeleteGroupCommand(Information groupName) {
        this.groupName = groupName;
    }


    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        groupToDelete = new Group(groupName);
        List<Group> groupList = model.getFilteredGroupList();
        boolean contains = new Boolean(Boolean.FALSE);
        for (Group g : groupList) {
            if (g.getInformation().equals(groupToDelete.getInformation())) {
                contains = true;
            }
        }
        if (contains == false) {
            throw new CommandException(MESSAGE_NO_SUCH_GROUP);
        } else {
            for (Group group : groupList) {
                if (groupName.equals(group.getInformation())) {
                    groupToDelete = group;
                }
            }
            try {
                model.deleteGroup(groupToDelete);
            } catch (GroupNotFoundException gnfe) {
                throw new CommandException(String.format(MESSAGE_NO_SUCH_GROUP,
                        groupName.toString()));
            }

            return new CommandResult(String.format(MESSAGE_DELETE_GROUP_SUCCESS,
                    groupToDelete.getInformation().toString()));

        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DeleteGroupCommand // instanceof handles nulls
                && this.groupName.equals(((DeleteGroupCommand) other).groupName) // state check
                && Objects.equals(this.groupToDelete, ((DeleteGroupCommand) other).groupToDelete));
    }
}
```
###### \java\seedu\address\logic\commands\DeleteMemberFromGroupCommand.java
``` java
package seedu.address.logic.commands;

import static java.util.Objects.requireNonNull;
import static seedu.address.logic.parser.CliSyntax.PREFIX_GROUP;

import java.util.List;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.exceptions.DuplicateGroupException;
import seedu.address.model.group.exceptions.GroupNotFoundException;
import seedu.address.model.person.Person;
import seedu.address.model.person.exceptions.PersonNotFoundException;

/**
 * Finds by index and delete person in a group that exist in  Fastis .
 * Keyword matching is case sensitive.
 */
public class DeleteMemberFromGroupCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "deleteGroupMember";
    public static final String COMMAND_ALIAS = "dGM";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds person via index on the most recent list "
            + "and delete from group that contain the specified keywords (case-sensitive).\n"
            + "Parameters: INDEX (must be a positive integer) g/GroupName(Must exist) "
            + "Example: " + COMMAND_WORD + " 1 "
            + PREFIX_GROUP + "CS1010";

    public static final String MESSAGE_NO_SUCH_GROUP = "No such group exist.";
    public static final String MESSAGE_DELETE_PERSON_FROM_GROUP_SUCCESS = "%1$s deleted from group %2$s";
    public static final String MESSAGE_GROUP_NOT_FOUND = "No such Group in Fastis";
    public static final String MESSAGE_DUPLICATE_GROUP = "Group already in Group";
    public static final String MESSAGE_PERSON_NOT_FOUND = "No such Person in Group";

    private Index index;
    private Person personToDelete;
    private Group groupToDelete;
    private Group groupInvolved;
    private List<Group> groupList;

    public DeleteMemberFromGroupCommand(Index index, Group groupToDelete) {
        requireNonNull(index);
        this.index = index;
        this.groupToDelete = groupToDelete;
    }


    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        requireNonNull(model);

        for (Group group : groupList) {
            if (groupToDelete.getInformation().equals(group.getInformation())) {
                try {
                    groupInvolved = new Group(group.getInformation(), group.getPersonList());
                    groupInvolved.removePerson(personToDelete);
                    model.updateGroup(group, groupInvolved);
                } catch (DuplicateGroupException dge) {
                    throw new CommandException(MESSAGE_DUPLICATE_GROUP);
                } catch (GroupNotFoundException gnfe) {
                    throw new CommandException(MESSAGE_GROUP_NOT_FOUND);
                } catch (PersonNotFoundException pnfe) {
                    throw new CommandException(MESSAGE_PERSON_NOT_FOUND);
                }
            }
        }
        return new CommandResult(String.format(MESSAGE_DELETE_PERSON_FROM_GROUP_SUCCESS, personToDelete.getName(),
                groupToDelete.getInformation().toString()));
    }

    @Override
    protected void preprocessUndoableCommand() throws CommandException {
        List<Person> lastShownList = model.getFilteredPersonList();
        groupList = model.getFilteredGroupList();
        if (index.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
        boolean contains = new Boolean(Boolean.FALSE);
        for (Group g : groupList) {
            if (g.getInformation().equals(groupToDelete.getInformation())) {
                contains = true;
            }
        }
        if (contains == false) {
            throw new CommandException(MESSAGE_NO_SUCH_GROUP);
        } else {
            personToDelete = lastShownList.get(index.getZeroBased());
        }

    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof seedu.address.logic.commands
                .DeleteMemberFromGroupCommand // instanceof handles nulls
                && groupToDelete.equals(((seedu.address.logic.commands
                .DeleteMemberFromGroupCommand) other).groupToDelete));
    }


}
```
###### \java\seedu\address\logic\commands\ListGroupMembersCommand.java
``` java
package seedu.address.logic.commands;

import java.util.List;

import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.MembersInGroupPredicate;

/**
 * Lists all persons in the address book to the user under the same group.
 */
public class ListGroupMembersCommand extends Command {


    public static final String COMMAND_WORD = "listGroupMembers";
    public static final String COMMAND_ALIAS = "lGM";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all persons whose Group contain any of "
        + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
        + "Parameters: KEYWORD \n"
        + "Example: " + COMMAND_WORD + " CS1010";
    public static final String MESSAGE_SUCCESS = "Listed all persons under group %1$s";
    public static final String MESSAGE_NO_SUCH_GROUP = "No such group exist.";

    private final MembersInGroupPredicate predicate;
    private Group groupToList;
    private Group groupToBeListed;

    public ListGroupMembersCommand(MembersInGroupPredicate predicate, Group groupToList) {
        this.predicate = predicate;
        this.groupToList = groupToList;
    }

    @Override
    public CommandResult execute() throws CommandException {

        List<Group> groupList = model.getFilteredGroupList();
        boolean contains = new Boolean(Boolean.FALSE);
        for (Group g : groupList) {
            if (g.getInformation().equals(groupToList.getInformation())) {
                contains = true;
            }
        }
        if (contains == false) {
            throw new CommandException(MESSAGE_NO_SUCH_GROUP);
        } else {
            for (Group group : groupList) {
                if (groupToList.getInformation().equals(group.getInformation())) {
                    groupToBeListed = group;
                }
            }
            MembersInGroupPredicate predicateCurr = new MembersInGroupPredicate(groupToBeListed);
            model.updateFilteredPersonList(predicateCurr);
            return new CommandResult(getMessageForPersonListShownSummary(model.getFilteredPersonList().size()));

        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof ListGroupMembersCommand // instanceof handles nulls
            && this.predicate.equals(((ListGroupMembersCommand) other).predicate)); // state check
    }
}

```
###### \java\seedu\address\logic\commands\ListTagMembersCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.model.person.TagContainKeywordsPredicate;

/**
 * Finds and lists all persons in address book whose tag name is of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class ListTagMembersCommand extends Command {

    public static final String COMMAND_WORD = "listTagMembers";
    public static final String COMMAND_ALIAS = "lTM";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all persons whose tags contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " CS1010";


    private final TagContainKeywordsPredicate predicate;

    public ListTagMembersCommand(TagContainKeywordsPredicate predicate) {
        this.predicate = predicate;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredPersonList(predicate);
        return new CommandResult(getMessageForPersonListShownSummary(model.getFilteredPersonList().size()));
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ListTagMembersCommand // instanceof handles nulls
                && this.predicate.equals(((ListTagMembersCommand) other).predicate)); // state check
    }
}
```
###### \java\seedu\address\logic\parser\AddGroupCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.AddGroupCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.person.UniquePersonList;


/**
 * Parses input arguments and creates a new AddGroupCommand object
 */
public class AddGroupCommandParser implements Parser<AddGroupCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the AddGroupCommand
     * and returns an AddGroupCommand object for execution.
     *
     * @throws ParseException if the user input does not conform the expected format
     */
    public AddGroupCommand parse(String args) throws ParseException {

        if (args.trim().isEmpty()) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddGroupCommand.MESSAGE_USAGE));
        }

        try {
            Information information = ParserUtil.parseInformation(args);
            UniquePersonList personList = new UniquePersonList();
            Group group = new Group(information);

            return new AddGroupCommand(group);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }
}
```
###### \java\seedu\address\logic\parser\AddMemberToGroupCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_GROUP;

import java.util.stream.Stream;

import seedu.address.commons.core.index.Index;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.AddMemberToGroupCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;

/**
 * Parses input arguments and creates a new AddMemberToGroupCommand object
 */
public class AddMemberToGroupCommandParser implements Parser<AddMemberToGroupCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the AddMemberToGroupCommand
     * and returns an AddMemberToGroupCommand object for execution.
     *
     * @throws ParseException if the user input does not conform the expected format
     */
    public AddMemberToGroupCommand parse(String args) throws ParseException {

        ArgumentMultimap argMultimap =
                ArgumentTokenizer.tokenize(args, PREFIX_GROUP);

        if (!arePrefixesPresent(argMultimap, PREFIX_GROUP)) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    AddMemberToGroupCommand.MESSAGE_USAGE));
        }

        try {
            Index index = ParserUtil.parseIndex(argMultimap.getPreamble());
            Information information = ParserUtil.parseInformation(argMultimap.getValue(PREFIX_GROUP).get());
            Group group = new Group(information);
            return new AddMemberToGroupCommand(index, group);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }

    /**
     * Returns true if none of the prefixes contains empty {@code Optional} values in the given
     * {@code ArgumentMultimap}.
     */
    private static boolean arePrefixesPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        return Stream.of(prefixes).allMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }

}
```
###### \java\seedu\address\logic\parser\AddressBookParser.java
``` java
        case AddGroupCommand.COMMAND_WORD:
        case AddGroupCommand.COMMAND_ALIAS:
            return new AddGroupCommandParser().parse(arguments);

        case AddMemberToGroupCommand.COMMAND_WORD:
        case AddMemberToGroupCommand.COMMAND_ALIAS:
            return new AddMemberToGroupCommandParser().parse(arguments);
```
###### \java\seedu\address\logic\parser\AddressBookParser.java
``` java
        case DeleteGroupCommand.COMMAND_WORD:
        case DeleteGroupCommand.COMMAND_ALIAS:
            return new DeleteGroupCommandParser().parse(arguments);

        case DeleteMemberFromGroupCommand.COMMAND_WORD:
        case DeleteMemberFromGroupCommand.COMMAND_ALIAS:
            return new DeleteMemberFromGroupCommandParser().parse(arguments);
```
###### \java\seedu\address\logic\parser\AddressBookParser.java
``` java
        case ListGroupMembersCommand.COMMAND_WORD:
        case ListGroupMembersCommand.COMMAND_ALIAS:
            return new ListGroupMembersCommandParser().parse(arguments);

        case ListTagMembersCommand.COMMAND_WORD:
        case ListTagMembersCommand.COMMAND_ALIAS:
            return new ListTagMembersCommandParser().parse(arguments);
```
###### \java\seedu\address\logic\parser\DeleteGroupCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.DeleteGroupCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Information;

/**
 * Parses input arguments and creates a new DeleteGroupCommand object
 */
public class DeleteGroupCommandParser implements Parser<DeleteGroupCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteGroupCommand
     * and returns an DeleteGroupCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public DeleteGroupCommand parse(String args) throws ParseException {


        try {
            Information information = ParserUtil.parseInformation(args);
            return new DeleteGroupCommand(information);
        } catch (IllegalValueException ive) {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteGroupCommand.MESSAGE_USAGE));
        }

    }
}
```
###### \java\seedu\address\logic\parser\DeleteMemberFromGroupCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_GROUP;

import java.util.stream.Stream;

import seedu.address.commons.core.index.Index;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.DeleteMemberFromGroupCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;

/**
 * Parses input arguments and creates a new DeleteMemberFromGroupCommand object
 */
public class DeleteMemberFromGroupCommandParser implements Parser<DeleteMemberFromGroupCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteMemberFromGroupCommand
     * and returns an DeleteMemberFromGroupCommand object for execution.
     *
     * @throws ParseException if the user input does not conform the expected format
     */
    public DeleteMemberFromGroupCommand parse(String args) throws ParseException {

        ArgumentMultimap argMultimap =
                ArgumentTokenizer.tokenize(args, PREFIX_GROUP);

        if (!arePrefixesPresent(argMultimap, PREFIX_GROUP)) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    DeleteMemberFromGroupCommand.MESSAGE_USAGE));
        }

        try {
            Index index = ParserUtil.parseIndex(argMultimap.getPreamble());
            Information information = ParserUtil.parseInformation(argMultimap.getValue(PREFIX_GROUP).get());
            Group group = new Group(information);
            return new DeleteMemberFromGroupCommand(index, group);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }

    /**
     * Returns true if none of the prefixes contains empty {@code Optional} values in the given
     * {@code ArgumentMultimap}.
     */
    private static boolean arePrefixesPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        return Stream.of(prefixes).allMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }

}
```
###### \java\seedu\address\logic\parser\ListGroupMembersCommandParser.java
``` java
package seedu.address.logic.parser;

import static java.util.Objects.requireNonNull;
import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.ListGroupMembersCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.group.MembersInGroupPredicate;

/**
 * Parses input arguments and creates a new ListGroupMembersCommand object
 */
public class ListGroupMembersCommandParser implements Parser<ListGroupMembersCommand> {


    /**
     * Parses the given {@code String} of arguments in the context of the ListGroupMembersCommand
     * and returns an ListGroupMembersCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public ListGroupMembersCommand parse(String args) throws ParseException {
        requireNonNull(args);

        if (args.isEmpty()) {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListGroupMembersCommand.MESSAGE_USAGE));
        }
        try {
            Information information = ParserUtil.parseInformation(args);
            Group group = new Group(information);
            return new ListGroupMembersCommand(new MembersInGroupPredicate(group), group);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }

}
```
###### \java\seedu\address\logic\parser\ListTagMembersCommandParser.java
``` java

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Arrays;

import seedu.address.logic.commands.ListTagMembersCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.person.TagContainKeywordsPredicate;

/**
 * Parses input arguments and creates a new ListTagMembersCommand object
 */
public class ListTagMembersCommandParser implements Parser<ListTagMembersCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the ListTagMembersCommand
     * and returns an ListTagMembersCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public ListTagMembersCommand parse(String args) throws ParseException {
        String trimmedArgs = args.trim();
        if (trimmedArgs.isEmpty()) {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListTagMembersCommand.MESSAGE_USAGE));
        }

        String[] nameKeywords = trimmedArgs.split("\\s+");

        return new ListTagMembersCommand(new TagContainKeywordsPredicate(Arrays.asList(nameKeywords)));
    }

}
```
###### \java\seedu\address\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code String content} into a {@code Content}.
     * Leading and trailing whitespaces will be trimmed.
     *
     * @throws IllegalValueException if the given {@code content} is invalid.
     */
    public static Information parseInformation(String information) throws IllegalValueException {
        requireNonNull(information);
        String trimmedInformation = information.trim();
        if (!Content.isValidContent(trimmedInformation)) {
            throw new IllegalValueException(Information.MESSAGE_INFORMATION_CONSTRAINTS);
        }
        return new Information(trimmedInformation);
    }

```
###### \java\seedu\address\model\AddressBook.java
``` java
    ////Group operation
    public void addGroup(Group group) throws DuplicateGroupException {
        groups.add(group);
    }

    /**
     * Removes {@code key} from this {@code AddressBook}.
     *
     * @throws ToDoNotFoundException if the {@code key} is not in this {@code AddressBook}.
     */
    public boolean removeGroup(Group key) throws GroupNotFoundException {
        if (groups.remove(key)) {
            return true;
        } else {
            throw new GroupNotFoundException();
        }
    }
```
###### \java\seedu\address\model\group\exceptions\DuplicateGroupException.java
``` java
package seedu.address.model.group.exceptions;

import seedu.address.commons.exceptions.DuplicateDataException;

/**
 * Signals that the operation will result in duplicate Group objects.
 */
public class DuplicateGroupException extends DuplicateDataException {
    public DuplicateGroupException() {
        super("Operation would result in duplicate groups");
    }
}
```
###### \java\seedu\address\model\group\exceptions\GroupNotFoundException.java
``` java

/**
 * Signals that the operation is unable to find the specified group.
 */
public class GroupNotFoundException extends Exception {}
```
###### \java\seedu\address\model\group\Group.java
``` java
package seedu.address.model.group;

import static seedu.address.commons.util.CollectionUtil.requireAllNonNull;

import java.util.Objects;

import seedu.address.model.person.Person;
import seedu.address.model.person.UniquePersonList;
import seedu.address.model.person.exceptions.DuplicatePersonException;
import seedu.address.model.person.exceptions.PersonNotFoundException;

/**
 * Represents a Group in the address book.
 * Guarantees: details are present and not null, field values are validated, immutable.
 */
public class Group {

    private final Information information;
    private UniquePersonList personList;

    /**
     * Every field must be present and not null.
     */
    public Group(Information information) {
        requireAllNonNull(information);
        this.information = information;
        this.personList = new UniquePersonList();
    }
    /**
     * Every field must be present and not null.
     */
    public Group(Information information, UniquePersonList personList) {
        requireAllNonNull(information);
        this.information = new Information(information.value);
        this.personList = new UniquePersonList();
        this.personList.setPersons(personList);
    }

    public Information getInformation() {
        return information;
    }

    public UniquePersonList getPersonList() {
        return personList;
    }

```
###### \java\seedu\address\model\group\Group.java
``` java

    /**
     * Removes a person to the group's personList
     * @param toRemove The Person to remove.
     * @throws DuplicatePersonException
     */
    public void removePerson(Person toRemove) throws PersonNotFoundException {
        if (!getPersonList().contains(toRemove)) {
            throw new PersonNotFoundException();
        } else {
            this.personList.remove(toRemove);
        }

    }
    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }

        if (!(other instanceof Group)) {
            return false;
        }

        Group otherGroup = (Group) other;
        if (otherGroup.getInformation().equals(this.getInformation())
            && otherGroup.getPersonList().asObservableList().size() == this.getPersonList().asObservableList().size()) {
            for (Person p : personList) {
                if (!otherGroup.getPersonList().contains(p)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(information);
    }

    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getInformation());
        return builder.toString();
    }

}
```
###### \java\seedu\address\model\group\Information.java
``` java
package seedu.address.model.group;

import static java.util.Objects.requireNonNull;
import static seedu.address.commons.util.AppUtil.checkArgument;


/**
 * Represents a Group's information in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidInformation(String)}
 */
public class Information {

    public static final String MESSAGE_INFORMATION_CONSTRAINTS =
            "Group information should only contain alphanumeric characters and spaces, and it should not be blank";

    /*
     * The first character of the information must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String INFORMATION_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";

    public final String value;

    /**
     * Constructs a {@code Information}.
     *
     * @param information A valid information.
     */
    public Information(String information) {
        requireNonNull(information);
        checkArgument(isValidInformation(information), MESSAGE_INFORMATION_CONSTRAINTS);
        this.value = information;
    }

    /**
     * Returns true if a given string is a valid to-do information.
     */
    public static boolean isValidInformation(String test) {
        return test.matches(INFORMATION_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Information // instanceof handles nulls
                && this.value.equals(((Information) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\address\model\group\MembersInGroupPredicate.java
``` java
package seedu.address.model.group;

import java.util.function.Predicate;

import seedu.address.model.person.Person;
import seedu.address.model.person.UniquePersonList;

/**
 *Tests that a {@code Person}'s is in the group specified.
 */
public class MembersInGroupPredicate implements Predicate<Person> {

    private final Group group;

    public MembersInGroupPredicate(Group group) {
        this.group = group;
    }

    @Override
    public boolean test(Person person) {
        UniquePersonList personList = group.getPersonList();
        if (personList.contains(person)) {
            return true;
        }
        return false;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof MembersInGroupPredicate // instanceof handles nulls
                && this.group.equals(((MembersInGroupPredicate) other).group)); // state check
    }
}
```
###### \java\seedu\address\model\group\UniqueGroupList.java
``` java
package seedu.address.model.group;

import static java.util.Objects.requireNonNull;
import static seedu.address.commons.util.CollectionUtil.requireAllNonNull;

import java.util.Iterator;
import java.util.List;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.address.commons.util.CollectionUtil;
import seedu.address.model.group.exceptions.DuplicateGroupException;
import seedu.address.model.group.exceptions.GroupNotFoundException;

/**
 * A list of Groups that enforces uniqueness between its elements and does not allow nulls.
 *
 * Supports a minimal set of list operations.
 *
 * @see Group#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueGroupList implements Iterable<Group> {

    private final ObservableList<Group> internalList = FXCollections.observableArrayList();

    /**
     * Returns true if the list contains an equivalent Group as the given argument.
     */
    public boolean contains(Group toCheck) {
        requireNonNull(toCheck);
        return internalList.contains(toCheck);
    }

    /**
     * Adds a Group to the list.
     *
     * @throws DuplicateGroupException if the Group to add is a duplicate of an existing Group in the list.
     */
    public void add(Group groupToAdd) throws DuplicateGroupException {
        requireNonNull(groupToAdd);
        if (contains(groupToAdd)) {
            throw new DuplicateGroupException();
        }
        internalList.add(groupToAdd);
    }

    public void setGroups(UniqueGroupList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setGroups(List<Group> groups) throws DuplicateGroupException {
        requireAllNonNull(groups);
        final UniqueGroupList replacement = new UniqueGroupList();
        for (final Group group : groups) {
            replacement.add(group);
        }
        setGroups(replacement);
    }

    /**
     * Removes the equivalent Group from the list.
     *
     * @throws GroupNotFoundException if no such Group could be found in the list.
     */
    public boolean remove(Group toRemove) throws GroupNotFoundException {
        requireNonNull(toRemove);
        final boolean groupFoundAndDeleted = internalList.remove(toRemove);
        if (!groupFoundAndDeleted) {
            throw new GroupNotFoundException();
        }
        return groupFoundAndDeleted;
    }

    /**
     * Replaces the group {@code target} in the list with {@code editedGroup}.
     *
     * @throws DuplicateGroupException if the replacement is equivalent to another existing Group in the list.
     * @throws GroupNotFoundException if {@code target} could not be found in the list.
     */
    public void setGroup(Group target, Group editedGroup)
            throws DuplicateGroupException, GroupNotFoundException {
        requireNonNull(editedGroup);

        int index = internalList.indexOf(target);
        if (index == -1) {
            throw new GroupNotFoundException();
        }

        if (!target.equals(editedGroup) && internalList.contains(editedGroup)) {
            throw new DuplicateGroupException();
        }

        internalList.set(index, editedGroup);
    }

    /**
     * Returns the backing list as an unmodifiable {@code ObservableList}.
     */
    public ObservableList<Group> asObservableList() {
        return FXCollections.unmodifiableObservableList(internalList);
    }

    @Override
    public Iterator<Group> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueGroupList // instanceof handles nulls
                && this.internalList.equals(((UniqueGroupList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteGroup(Group target) throws GroupNotFoundException {
        addressBook.removeGroup(target);
        indicateAddressBookChanged();
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateGroup(Group target, Group editedGroup)
            throws DuplicateGroupException, GroupNotFoundException {
        requireAllNonNull(target, editedGroup);

        addressBook.updateGroup(target, editedGroup);
        indicateAddressBookChanged();
    }

    @Override
    public synchronized void addGroup(Group group) throws DuplicateGroupException {
        addressBook.addGroup(group);
        indicateAddressBookChanged();
    }

```
###### \java\seedu\address\model\person\TagContainKeywordsPredicate.java
``` java
package seedu.address.model.person;

import java.util.List;
import java.util.Set;
import java.util.function.Predicate;

import seedu.address.model.tag.Tag;

/**
 * Tests that a {@code Person}'s {@code Tag} matches any of the keywords given.
 */
public class TagContainKeywordsPredicate implements Predicate<Person> {
    private final List<String> keywords;

    public TagContainKeywordsPredicate(List<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public boolean test(Person person) {
        Set<Tag> tags = person.getTags();
        for (Tag t : tags) {
            for (String key : keywords) {
                if (t.name.equals(key)) {
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TagContainKeywordsPredicate // instanceof handles nulls
                && this.keywords.equals(((TagContainKeywordsPredicate) other).keywords)); // state check
    }
}
```
###### \java\seedu\address\storage\XmlAdaptedGroup.java
``` java
package seedu.address.storage;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import javax.xml.bind.annotation.XmlElement;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.person.Person;
import seedu.address.model.person.UniquePersonList;

/**
 * JAXB-friendly version of the Group.
 */
public class XmlAdaptedGroup {

    public static final String MISSING_FIELD_MESSAGE_FORMAT = "Group's %s field is missing!";

    @XmlElement(required = true)
    private String information;

    @XmlElement(required = true)
    private List<XmlAdaptedPerson> personList = new ArrayList<>();

    /**
     * Constructs an XmlAdaptedGroup.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedGroup() {
    }

    /**
     * Constructs an {@code XmlAdaptedGroup} with the given group details.
     */
    public XmlAdaptedGroup(String information) {
        this.information = information;
        this.personList = new ArrayList<>();
    }

    /**
     * Converts a given Group into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedGroup
     */
    public XmlAdaptedGroup(Group source) {
        information = source.getInformation().value;
        UniquePersonList persons = source.getPersonList();
        for (Person person : persons) {
            personList.add(new XmlAdaptedPerson(person));
        }
    }

    /**
     * Converts this jaxb-friendly adapted group object into the model's Group object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted group
     */
    public Group toModelType() throws IllegalValueException {
        if (this.information == null) {
            throw new IllegalValueException(String.format(MISSING_FIELD_MESSAGE_FORMAT,
                    Information.class.getSimpleName()));
        }
        if (!Information.isValidInformation(this.information)) {
            throw new IllegalValueException(Information.MESSAGE_INFORMATION_CONSTRAINTS);
        }
        final Information information = new Information(this.information);
        final UniquePersonList uniquePersonList = new UniquePersonList();
        for (XmlAdaptedPerson adaptedPerson : personList) {
            Person personToAdd = adaptedPerson.toModelType();
            uniquePersonList.add(personToAdd);
        }

        return new Group(information, uniquePersonList);

    }

    public List<XmlAdaptedPerson> getPersonList() {
        return personList;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }

        if (!(other instanceof XmlAdaptedGroup)) {
            return false;
        }

        XmlAdaptedGroup otherGroup = (XmlAdaptedGroup) other;
        return Objects.equals(information, otherGroup.information);
    }
}
```
###### \java\seedu\address\ui\GroupCard.java
``` java
package seedu.address.ui;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Region;
import seedu.address.model.group.Group;

/**
 * An UI component that displays information of a {@code Group}.
 */
public class GroupCard extends UiPart<Region> {

    private static final String FXML = "GroupListCard.fxml";

    public final Group group;

    @FXML
    private HBox cardPane;
    @FXML
    private Label information;
    @FXML
    private Label id;

    public GroupCard(Group group, int displayedIndex) {
        super(FXML);
        this.group = group;
        id.setText(displayedIndex + ". ");
        information.setText(group.getInformation().value);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        if (other == this) {
            return true;
        }

        // instanceof handles nulls
        if (!(other instanceof GroupCard)) {
            return false;
        }

        // state check
        GroupCard card = (GroupCard) other;
        return id.getText().equals(card.id.getText())
                && group.equals(card.group);
    }
}
```
###### \java\seedu\address\ui\GroupListPanel.java
``` java
package seedu.address.ui;

import java.util.logging.Logger;

import org.fxmisc.easybind.EasyBind;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.layout.Region;
import seedu.address.commons.core.LogsCenter;
import seedu.address.commons.events.ui.GroupPanelSelectionChangedEvent;
import seedu.address.model.group.Group;

/**
 * Panel containing the list of groups.
 */
public class GroupListPanel extends UiPart<Region> {
    private static final String FXML = "GroupListPanel.fxml";
    private final Logger logger = LogsCenter.getLogger(GroupListPanel.class);

    @FXML
    private ListView<GroupCard> groupListView;

    public GroupListPanel(ObservableList<Group> groupList) {
        super(FXML);
        setConnections(groupList);
        registerAsAnEventHandler(this);
    }

    private void setConnections(ObservableList<Group> groupList) {
        ObservableList<GroupCard> mappedList = EasyBind.map(
                groupList, (group) -> new GroupCard(group, groupList.indexOf(group) + 1));
        groupListView.setItems(mappedList);
        groupListView.setCellFactory(listView -> new GroupListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void setEventHandlerForSelectionChangeEvent() {
        groupListView.getSelectionModel().selectedItemProperty()
                .addListener((observable, oldValue, newValue) -> {
                    if (newValue != null) {
                        logger.fine("Selection in group list panel changed to : '" + newValue + "'");
                        raise(new GroupPanelSelectionChangedEvent(newValue));
                    }
                });
    }

    /**
     * Custom {@code ListCell} that displays the graphics of a {@code GroupCard}.
     */
    class GroupListViewCell extends ListCell<GroupCard> {

        @Override
        protected void updateItem(GroupCard groupCard, boolean empty) {
            super.updateItem(groupCard, empty);

            if (empty || groupCard == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(groupCard.getRoot());
            }
        }

    }
}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
        StatusBarFooter statusBarFooter = new StatusBarFooter(prefs.getAddressBookFilePath(),
                logic.getFilteredPersonList().size());
```
###### \resources\view\GroupListCard.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.VBox?>
<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <GridPane HBox.hgrow="ALWAYS">
        <columnConstraints>
            <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="100" />
        </columnConstraints>
        <VBox alignment="CENTER_LEFT" minHeight="70" GridPane.columnIndex="0">
            <padding>
                <Insets top="5" right="5" bottom="5" left="15" />
            </padding>
            <HBox spacing="5" alignment="CENTER_LEFT">
                <Label fx:id="id" styleClass="cell_big_label">
                    <minWidth>
                        <!-- Ensures that the label text is never truncated -->
                        <Region fx:constant="USE_PREF_SIZE" />
                    </minWidth>
                </Label>
                <Label fx:id="information" text="\$first" styleClass="cell_big_label" />
            </HBox>
        </VBox>
    </GridPane>
</HBox>
```
###### \resources\view\GroupListPanel.fxml
``` fxml

<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>
<VBox xmlns="http://javafx.com/javafx/8.0.141" xmlns:fx="http://javafx.com/fxml/1">
   <Label  prefHeight="23.0" prefWidth="95.0" text="GROUP LIST" >
      <font>
         <Font name="System Bold" size="16.0" />
      </font></Label>
    <ListView fx:id="groupListView" VBox.vgrow="ALWAYS" />
</VBox>
```
###### \resources\view\StatusBarFooter.fxml
``` fxml
  <StatusBar styleClass="anchor-pane" fx:id="totalPersonsStatus" GridPane.columnIndex="1" />
```
