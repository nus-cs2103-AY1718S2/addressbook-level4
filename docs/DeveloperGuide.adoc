= Event Planning isn't Complicated (EPIC) - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: short
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/CS2103JAN2018-W13-B2/main/blob/master

By: `Team W13-B2`      Since: `Mar 2018`      Licence: `MIT`

Table of Contents:

== Introduction

EPIC is a Java application and event planning tool for large organization hosting many large-scale events (e.g. schools which host competitions, award and graduation ceremonies, and seminars and talks).

It provides a basic suite of operations for managing the attendance for multiple events. Attendees can be drawn from a common attendance list. It is targeted at and optimised for event planners who are comfortable with using a Command Line Interface (CLI).


This Developer Guide provides a high level introduction and view of EPIC. We will walk you through the software architecture EPIC adopts, the implementation
of several interesting features EPIC has, as well as prepare you to modify the codebase of EPIC yourself.

== Setting Up

This section details the set-up process for working on the codebase on your computer.

=== Prerequisites

Please ensure that you have the following installed on your computer:

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFX plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting Up the Project on Your Computer

Please follow these steps to set up the project on your computer:

. Fork this repo, and clone the fork to your computer.
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first).
. Set up the correct JDK version for Gradle.
.. Click `Configure` > `Project Defaults` > `Project Structure`.
.. Click `New...` and find the directory of the JDK.
. Click `Import Project`.
. Locate the `build.gradle` file and select it. Click `OK`.
. Click `Open as Project`.
. Click `OK` to accept the default settings.
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the Setup

To ensure that EPIC has been set up correctly:

. Run the `seedu.address.MainApp` and try a few commands.
. <<Testing,Run the tests>> to ensure they all pass.

=== Configurations to Do Before Writing Code

For the best developer experience, we recommend the following configurations before you start coding.

==== Configuring the Coding Style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify:

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS).
. Select `Editor` > `Code Style` > `Java`.
. Click on the `Imports` tab. Then,

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`:
** Set to `999` to prevent IntelliJ from contracting the import statements.
* For `Import Layout`:
** The order should be `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`.
** Check the checkbox: `Add a blank line between each import`.

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating Documentation to Match Your Fork

After forking the repo, links in the documentation will still point to the `CS3103JAN2018-W13-B2/main` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `CS2103JAN2018-W13-B2/main`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting Up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see <<UsingCoveralls#, UsingCoveralls.adoc>>).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based).

[[Design-Architecture]]
== Architecture

EPIC incorporates the core architectural principles of object-oriented, Java-based applications. It consists of loosely coupled components written in Java. The *_Architecture Diagram_* (<<#architecture-diagram>>) given below explains the high-level design of the App.

[#architecture-diagram]
.Architecture Diagram
image::Architecture.png[width="600"]

The application consists of the Main, Commons, Logic, UI, Model and Storage components. The UI, Logic, Model and Storage
components form the *core* of the application, with Main and Commons facilitating their initialisation and inter-communication.

Below is a quick overview of each component:

=== Main

The Main component only has one class - link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. This class has two main responsibilities:

* At app launch, it initialises the other components in the correct sequence, and connects them up with each other.
* Upon exit, it shuts down the other components and invokes cleanup methods where necessary.

=== Commons

Commons represents a collection of classes used by multiple other components. Two of these classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library])
is used by components to communicate with other components using events (i.e. a form of _Event Driven Design_).
* `LogsCenter` : This class is used by many classes to write log messages to the application's log file.

[[Design-Ui]]
// tag::uicomponent[]
=== UI Component

The UI component is responsible for interfacing with the user. The UI component has three main responsibilities:

* It executes user commands using the Logic component.
* It binds itself to some data in the Model component so that it can auto-update itself when data in the Model component changes.
* It responds to events raised from various parts of the App and updates itself accordingly.

====  Functional Overview

The UI consists of a `MainWindow` that contains the 5 main layout regions (<<#GUIOverview>>):

[#GUIOverview]
.Overview of the Graphical User Interface of EPIC
image::GUI.png[width="750"]

. Command Box: text box to receive user inputs.
. Result Display: status bar that displays the result of user commands.
. Persons Pane: pane that lists all persons.
. Events Pane: pane that lists all events.
. Attendance Pane: pane that lists all registrants in the user selected event.
. Person Card: a card that lists a person's contact information.
. Event Card: a card that lists an event's details.
. Attendance Card: a card that lists a registrant's contact information and displays if the registrant has attended or not.

[NOTE]
If no  `EpicEvent` has been selected, the Attendance Pane will be empty


==== Technical Overview

The UI component (<<#UiClassDiagram>>) uses the JavaFX UI framework. The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.


[#UiClassDiagram]
.Structure of the UI Component
image::UiClassDiagram.png[width="750"]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]


The layout of these UI parts is defined in matching `.fxml` files that are in the `src/main/resources/view` folder.
For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]
// end::uicomponent[]

[[Design-Logic]]
=== Logic Component

The Logic component (<<#LGC>>) is responsible for the parsing and execution of commands.

[#LGC]
.Structure of the Logic Component
image::LogicClassDiagram.png[width="800"]

.Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in <<#LGC>>
image::LogicCommandClassDiagram.png[width="800"]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

When a command is entered into the command box, the following steps take place:

.  The Logic component uses the `EventPlannerParser` class to parse the user command.
.  A `Command` object is returned by the parser, which is passed to the `LogicManager` to execute.
.  The command execution may affect the Model component (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the UI component.

The Sequence Diagram for interactions within the Logic component for the `execute("delete 1")` API call is shown below.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeletePersonSdForLogic.png[width="800"]

// tag::modelcomponent[]
[[Design-Model]]
=== Model Component

The Model component (<<#MCD>>) is responsible for holding application data in-memory.

[#MCD]
.Structure of the Model Component
image::ModelClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The Model component has the following responsibilities:

* It stores a `UserPref` object that represents the user's preferences.
* It stores the Event Planner data.
* It exposes three unmodifiable `ObservableLists`, one each for `Person`, `EpicEvent` and `Attendance`.
The UI can be bound to any of these lists so that it automatically updates when the data in the list changes.

[NOTE]
The Model does not depend on any of the other three components. This reduces coupling between components.
// end::modelcomponent[]

[[Design-Storage]]
=== Storage Component

The Storage component (<<SCD>>) is responsible for persisting application data on the hard disk.

[#SCD]
.Structure of the Storage Component
image::StorageClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The Storage component has the following functions:

* It can save `UserPref` objects in json format and reconstruct the Model from a file of this format.
* It can save the Event Planner data in xml format and reconstruct the Model from a file of this format.

// tag::storagedevguide[]

When EPIC is re-launched, the following steps take place to restore data from the storage file:

.  The `Main` creates an instance of `UserPrefStorage` object to initiate user preference for storage.
.  The `Main` creates an instance of `XmlEventPlannerStorage` object to restore data with storage file path supplied by the instance of `UserPrefStorage` object.
.  The restored data is encapsulated as an `EventPlanner` object inside the `XmlEventPlannerStorage` instance.
.  An instance of `StorageManager` object is created from both the `XmlEventPlannerStorage` object and the `UserPrefStorage` object.
.  The `StorageManager` object is used to initiate the model components.

The Sequence Diagram (<<SCSD>>) for interactions within the Storage Component to restore data is shown below.

[#SCSD]
.Interactions inside the Storage Component to restore data
image::StorageComponentSequenceDiagram.png[width="800"]

// end::storagedevguide[]

=== How Components Interact

Finally, we will conclude the Architecture section with several examples on how the components interact.

Each of the core components (UI, Logic, Model, Storage) has the following functions:

* It defines its _API_ in an `interface` with the same name as the component.
* It exposes its functionality using a `{COMPONENT NAME}Manager` class.

For example, the Logic component
defines its API in the `Logic.java` interface and exposes its functionality
using the `LogicManager.java` class.

The _Sequence Diagram_ below shows how the components interact with one another after the user issues the command `delete 1`.

.Component interactions for `delete 1` command (part 1)
image::SDforDeletePerson.png[width="800"]

[NOTE]
Note how the Model component simply raises a `EventPlannerChangedEvent` when the data in EPIC is changed,
instead of asking the Storage component to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event,
which eventually results in the updates being saved to the hard disk and the
status bar of the UI reflecting the 'Last Updated' time.

.Component interactions for `delete 1` command (part 2)
image::SDforDeletePersonEventHandling.png[width="800"]

[NOTE]
Note how the event is propagated through the `EventsCenter` to the Storage and UI components without
the Model component having to be coupled to either of them. This is an example of how the _Event Driven Design_ helps us reduce direct coupling between components.


== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::findeventdevguide[]

=== Find Event Feature
The `find-event` command enables the user to find events from the event list with keywords. The command finds all events whose names contain any of the given keywords. The user can further modify the events with `edit-event` or `delete-event` command once the event is found.

<<#SDFEC>> below shows how the `find-event` command is processed in the Logic component.

[#SDFEC]
.Sequence Diagram for `find-event` command
image::FindEventCommandSequenceDiagram.png[width="650"]
==== Current Implementation
The `find-event` command input is passed into an `EventPlannerParser` object. The `EventPlannerParser` reads the command word “find-event” and creates a `FindEventCommandParser` object that further parses the command input and creates a `FindEventCommand`. The `FindEventCommand` filters the the event list based on the keywords and updates Model component on changes in the filtered event list.

==== Design Considerations

===== Aspect: Keyword Matching Pattern

* **Alternative 1 (current choice):** Match any of the keywords
** Pros: The user can find multiple events given multiple keywords for events.
** Cons: The user cannot pin-point an event if the keyword used for matching is also inside other event names.
* **Alternative 2:** Match all the keywords
** Pros: The find events function will be more targeted and precise.
** Cons: The users cannot find different types of events at the same time.
* **Alternative 3:** Fuzzy search
** Pros: The user can find an event even if he/she has forgotten the name of the event.
** Cons: It is harder to implement the find function.
// end::findeventdevguide[]

=== Edit Person/Event Features

// tag::editfeature[]

==== Previous Implementation

In https://github.com/se-edu/addressbook-level4[AddressBook-Level4], the `edit` command was performed by creating a new `Person`
and passing it to the `UniquePersonList` in the model, which would then replace the to-be-edited `Person` with it.

[source,java]
----
    int index = internalList.indexOf(personToEdit);
    Person editedPerson = new Person(name, ...);
    internalList.set(index, editedPerson);
----

[#edit-curr-implementation]
==== Current Implementation

In EPIC, the `edit` and `edit-event` commands are now implemented in a mutable manner - instead of replacing the to-be-edited `Person/EpicEvent` with the new one, we edit the details of the to-be-edited `Person/EpicEvent` directly.

[source,java]
----
    int index = internalList.indexOf(personToEdit);
    Person editedPerson = new Person(name, ...);
    internalList.get(index).setPerson(editedPerson); // setPerson edits internal details using those of the supplied Person
----

==== Design Considerations

===== Aspect: Implementation of `edit`

* **Alternative 1 (current choice):** Edit in a mutable manner
** Pros: Since an `EpicEvent` maintain references to multiple `Person` objects, editing a `Person` in this manner
automatically updates the `EpicEvent` objects which reference it. Similarly, editing an `EpicEvent` in this manner
automatically updates the `Attendance` objects which reference it.
** Cons: Implementation of `undo` will be more difficult.
* **Alternative 2:** Edit in an immutable manner
** Pros: Implementation of `undo` is easier, since we can just replace the current `EventPlanner` with the previous one.
** Cons: Editing a `Person/EpicEvent` will require passing a copy of the newly-created `Person/EpicEvent` to all objects
associated with the to-be-edited version, introducing significant overhead.

// end::editfeature[]

// tag::undoredo[]
=== Undo/Redo Features
==== Current Implementation

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports
undoing and redoing of commands that
modify the state of the event planner (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. <<#UCCD>> shows the class diagram for commands:

[#UCCD]
.Class Diagram for commands
image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such
as generating the opposite command before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm
in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the event planner.
The current state of the event planner is saved before the `delete 5` command executes.
The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

.How a delete command modifies the UndoRedoStack
image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute
`add n/David ...` to add a new person.

.How an add command modifies the UndoRedoStack
image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

[NOTE]
The `oppositeCommands` for the `AddPersonCommand` and `DeletePersonCommand` above are different! The former is a `DeletePersonCommand`
while the latter is an `AddPersonCommand`.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the event planner to the state before the `add` command is executed.

.How an undo command utilises the UndoRedoStack
image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

.Sequence Diagram for the undo command
image::UndoRedoSequenceDiagram.png[width="800"]

// tag::editedundoparts[]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and performs the intention of the original command).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and a `CommandException` will be thrown when popping the `redoStack`.

[NOTE]
redo() does not simply execute the `Command` with the previous parameters! This would cause indexing issues with
commands like `delete` if `filteredPersons` had been altered by a `find` or other view command.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`.
This time the `redoStack` is no longer empty. It will be purged as it no longer makes sense to redo the `add n/David` command
(this is the behavior that most modern desktop applications follow). <<#UndoRedoNewCommand2StackDiagram>> below shows how
the clear command changes the `UndoRedoStack`.

[#UndoRedoNewCommand2StackDiagram]
.How a clear command modifies the UndoRedoStack
image::UndoRedoNewCommand2StackDiagram.png[width="800"]

// end::editedundoparts[]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

.A list command does not modify the UndoRedoStack
image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarizes what happens inside the `UndoRedoStack` when a user executes a new command:

.Activity Diagram for command execution
image::UndoRedoActivityDiagram.png[width="650"]

// tag::undoredochanges[]

==== Changes from Previous Implementation

Instead of saving the entire event planner each time we execute an `UndoableCommand`, each `UndoableCommand` knows how to `undo/redo` itself.
Each `UndoableCommand` has an `oppositeCommand` field, which is another `UndoableCommand` that, when executed, reverses the changes made by the original command.
This `oppositeCommand` is generated as part of the `execute()` method, which is overridden in the `UndoableCommand` class.

The sequence diagram for the overridden `execute()` method is shown in <<#sdoverriddenexecute>>, and that for the new `undo()` implementation in <<#sdundo>>.

[#sdoverriddenexecute]
.Sequence Diagram for the overridden `execute()`
image::ExecuteSequenceDiagram.png[width="450"]

[#sdundo]
.Sequence Diagram for new undo implementation
image::UndoSequenceDiagram.png[width="450"]

The `oppositeCommand` is generated in the `execute()` method, after `preprocessUndoableCommand()`. This is because generating the `oppositeCommand`
requires knowledge of the actual `Person/EpicEvent` objects to be modified. For example, the `oppositeCommand` of a `deletePersonCommand` is an `addPersonCommand`,
but we only know the person to be deleted after the pre-processing step.

[NOTE]
Each `UndoableCommand` now requires its individual `generateOppositeCommand()` implementation. Hence, this method is made abstract in
the abstract class `UndoableCommand`.

There was no `Command` that could easily reverse the changes caused by executing a `ClearCommand`, hence a new `Command` `RestoreCommand` had to be created. Since the sole purpose
of this command is to serve as the `oppositeCommand` of a `ClearCommand`, this command is not directly accessible to the user, and can only be executed when
the user undoes a `ClearCommand`.

==== Design Considerations

===== Aspect: How Undo and Redo Executes

* **Alternative 1 (current choice):** Store the minimal knowledge required to undo each command inside itself.
** Pros: Significantly less memory is used (e.g. for `delete`, just save the person being deleted). Compatible with mutable commands.
** Cons: Implementation is more complicated.
* **Alternative 2:** Save the entire event planner after every undoable command.
** Pros: Implementation is easy.
** Cons: Performance issues may result due to high memory usage. Also, this is incompatible with the mutable `edit` and `edit-event` implementations.

// end::undoredochanges[]

===== Aspect: Implementation of `UndoableCommand`

* **Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()`
** Pros: Undo/redo functionality will now be part of the default behaviour. Classes that deal with `Command` will not have to know that `executeUndoableCommand()` exists.
** Cons: New developers will find the template pattern difficult to understand.
* **Alternative 2:** Override `execute()`
** Pros: New developers will not have to learn the above template pattern
** Cons: Command classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to be undone/redone.


===== Aspect: Type of Commands that Can be Undone/Redone

* **Alternative 1 (current choice):** Only include commands that modify the event planner (`add`, `clear`, `edit`).
** Pros: Only commands that cannot be easily reverted need to be implemented (the view can easily be re-modified as no data is lost).
** Cons: User might mistakenly think that undo also applies to view modification (e.g. filtering).
* **Alternative 2:** Include all commands.
** Pros: It might be more intuitive for the user.
** Cons: User has no way of skipping such commands if he or she just want to reset the state of the event planner and not the view.
**Additional Info:** See the discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].


===== Aspect: Data Structure to Support the Undo/Redo Commands

* **Alternative 1 (current choice):** Use separate stack for undo and redo
** Pros: This will be easier to understand for new Computer Science undergraduates, who are likely to be the incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `UndoRedoStack`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate stack, and just reuse what is already in the codebase.
** Cons: This requires dealing with commands that have already been undone - we must remember to skip these commands. This also violates the Single Responsibility Principle (SRP) and Separation of Concerns (SoC) as `HistoryManager` now needs to do two different things.

// end::undoredo[]

// tag::registerpersons[]

=== Register/Deregister Features

==== Current Implementation

Each `EpicEvent` class maintains a `UniqueAttendanceList`, which contains references to the `Persons`
registered for that event. The association between `EpicEvent` and `Person` is unidirectional i.e.
a `Person` does not maintain references to the `EpicEvents` he/she has registered for.

When a `register` command is called, we first find the `PersonToRegister` using the index provided,
and the `EventToRegisterFor` using the name provided. Then, we call `registerPersonForEvent()` through
the `ModelManager`, which eventually calls the `registerPerson()` method of the `EpicEvent`.

This method not only adds the reference of the `Person` to the `EpicEvent`, but also increments a counter inside
the `Person`. This counter is used to check whether a `Person` is still registered for some event
when the user attempts to delete that `Person`.

The entire process is illustrated using the sequence diagram (<<#registerseq>>) below.

[#registerseq]
.Sequence Diagram for the `register` command
image::RegisterPersonCommandSequenceDiagram.png[width="650"]

==== Design Considerations

===== Aspect: Association Links between EpicEvent and Person

* **Alternative 1 (current choice):** Make the EpicEvent-Person association unidirectional
** Pros: Implementation of the association is easier.
** Cons: Some features might need the backward association link in future.
* **Alternative 2:** Make the EpicEvent-Person association bidirectional
** Pros: Features needing the backward association link can be more easily implemented - there is no
need to implement the link later.
** Cons: Implementation of the association is much more complicated. Violates the `You Aren't Gonna Need It (YAGNI)` principle.

==== Aspect: Deletion of Persons still Registered for an Event

* **Alternative 1 (current choice):** Disallow deletion of persons still registered for an event
** Pros: This ensures that all persons' details will be safeguarded until they are no longer required.
** Cons: Implementation is more complicated.
* **Alternative 2:** Allow deletion of persons still registered for an event
** Pros: The user will not have to deregister persons/delete events before a person can be deleted.
Implementation is easier.
** Cons: The user might absentmindedly delete a person when his/her details are still required
(by an upcoming event he/she is registered for).

=== List Registered Persons Feature

==== Current Implementation

To list the persons registered for an event, we create a `Predicate` that tests whether a `Person`
is in an `EpicEvent`, then pass it to `updateFilteredPersonList()`. `Predicate` is a new feature in Java 8
that supports the filtering of lists in a functional style. Incoming developers can learn how to use
this feature at https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html[the official Java site].

// end::registerpersons[]

// tag::markattendance[]

=== Toggle Attendance Feature

==== Current Implementation

The implementation uses a class called `Attendance`. An instance of `Attendance` is created
every time a `EpicEvent` registers to an `EpicEvent` and the instance stores references to the corresponding
`Person` and `Person`. It also stores a `BooleanProperty` called `hasAttendedEventProperty`
that represents whether the `Person` has attended the `EpicEvent`.
The `Attendance` object is then added to the `UniqueAttendanceList` inside the `EpicEvent`.
This structure reduces coupling between the `Person` and `EpicEvent` class and allows the
`EpicEvent` to have access to all its registrants so that adding, removing and listing registrants are
easy to implement.

When the `toggle` command is called, the command is passed to the `EventPlannerParser` object, which reads and parses the input to return a `ToggleAttendanceCommand` object.
The command then uses the index provided to find and save a reference to the `Attendance` object
to be toggled. This is done so that the command can be undone by toggling the same
`Attendance` object. <<#TCD>> below shows how the `toggle` command is processed
in the Logic component.

[#TCD]
.Sequence Diagram for toggle command
image::ToggleAttendanceCommandSequenceDiagram.png[width="800"]

When the `ToggleAttendanceCommand` is executed, it obtains the relevant `Person` and
`EpicEvent` objects from the stored `Attendance` object and triggers `toggleAttendance` from
the `Model`. After which, the relevant `Attendance` object is replaced with a copy
where the `hasAttendedEventProperty` is toggled.

==== Design Considerations

===== Aspect: Location of `Attendance` Objects

* **Alternative 1 (current choice):** Store in `EpicEvent` object
** Pros: There is less coupling between the `Person` and `EpicEvent` classes.
Instances of `EpicEvent` are also able to keep track of changes in the attendance list more easily,
making it easier for the UI  to reflect these changes when required.
** Cons: It is more difficult for `EventPlanner` to track which `EpicEvents` a
`Person` is registered for. In this case, deleting a `Person` requires
checking through all the `EpicEvents` to determine whether the `Person` is still
registered for any `EpicEvents` and this might be slow if there is a large number `EpicEvents` in
the `EventPlanner`
* **Alternative 2:** Store in `EventPlanner` object
** Pros: The `EventPlanner` can easily track which `EpicEvent` a `Person` is registered for, making
the implementation of some person-related commands, such as `delete`, easier.
** Cons: In order to find out which `Persons` are registered to an `EpicEvent`,
an instance of `EpicEvent` would have to search through the entire list of `Attendance`
objects in `EventPlanner`. This can be very slow if the number of `Attendance` objects is very large.

==== Aspect: Mutability of `Attendance` Objects

* **Alternative 1 (current choice):** Make `Attendance` objects immutable
** Pros: Changes to the `Attendance` objects in the attendance list are more easily
tracked, which makes updating of the UI more striaghtforward.
This is because changes need to be made by replacing the object
with a new copy that contains the updated properties, and this replacement can be tracked using listeners.
** Cons: Implementation of the `toggle` command is more difficult as the entire object has to be replaced whenever
a change needs to be made. For example, toggling the attendance would have to be done
by replacing the entire object with a new copy which only has its `hasAttendedEventProperty` changed.
* **Alternative 2:** Make `Attendance` objects mutable
** Pros: Implementation of the `toggle` command is easier as the `hasAttendedEventProperty`
of the `Attendance` object can be directly accessed and modified.
** Cons: Changes to the `Attendance` objects in the attendance list are harder to track
as mutating the object cannot be tracked using a listener. In this case, specialised events
would have to be used to trigger changes in the UI.

==== Aspect: Method of Marking Attendance

* **Alternative 1 (current choice):** Have one command to toggle attendance from attended to not attended and vice versa
** Pros: Undoing the `toggle` command is easier as toggling is always valid. In constrast, marking a registrant
as attended may not always be valid since that registrant may have already been marked as attended so
the undo command has to account for that.
** Cons: Users may find it less intuitive to toggle the attendance of a registrant
compared to directly marking a registrant as attended or not attended.
* **Alternative 2:** Have two separate commands: one for marking registrants as attended and one for marking
them as not attended
** Pros: Users may find it more intuitive compared to toggling the attendance of a registrant.
** Cons: Undoing the command is more difficult as the undo commmand has to account for the case where
a user tries to mark a registrant as attended when he/she has already been marked as attended.
// end::markattendance[]

// tag::findregistrant[]
=== Find Registrant Feature

The `find-registrant` command enables users to filter registrants of an event with keywords. Only registrants
whose names contain any of the given keywords will be listed. The user can further toggle the attendance of the
registrants with the `toggle` command.

<<#SDSEC>> below shows how the `find-registrant` command is processed in the Logic component.

[#SDSEC]
.Sequence Diagram for `find-registrant` command
image::FindRegistrantSequenceDiagram.png[width="650"]

==== Current Implementation

The `find-registrant` command is passed to the `EventPlannerParser` object which then reads the parses the input and
returns a `FindRegistrantCommand` object. When the `FindRegistrantCommand` object is executed, the Model filters the
list of registrants and the Attendance Paneis updated.

==== Design Considerations

===== Aspect: Keyword Matching Pattern

* **Alternative 1 (current choice)**: Match any of the keywords
** Pros: The user can find multiple registrants using multiple keywords.
** Cons: The user will not be able to search by full name as other registrants might be matched as well.
* **Alternative 2**: Match all keywords
** Pros: The user can search by full name.
** Cons: Matching all keywords might be too restrictive and would not be a useful filter to narrow down registrants.
* **Alternative 3**: Fuzzy Search
** Pros: The user can filter registrants with approximate keywords.
** Cons: It is harder to implement fuzzy search.
// end::findregistrant[]


// tag::threepaneui[]
=== Three-Pane UI

The new UI is a three-pane UI consisting of a list of persons, events, and registrants for the selected event. Being able to
 view all three panes will allow the user to read off the desired command parameters without having to switch between
  lists.

In addition, `edit` and `edit-event` commands are now implemented in a mutable manner
 (see <<edit-curr-implementation>>). As a result, the `ObservableList` that wraps the people and event data will no
 longer be notified of changes. The new UI must be notified of changes to data so it can refresh itself to reflect
 such changes. The UI will also have to respond to new commands such as the `select-event` and `toggle`.
 The `select-event` could invoke a change in the contents of the Attendance Pane and `toggle` will toggle the
 attendance status and is reflected in the UI in the form of the attendance icon change.

==== Current Implementation

The UI now consists of 3 list panes: `PersonListPanel`, `EpicEventListPanel` and `AttendanceListPanel`. Each pane is a list of `PersonCard`, `EpicEventCard` and `AttendanceCard` respectively. Since the `AttendanceCard` has the same UI as `PersonCard` with the addition of the toggle icon, it extends `PersonCard`. The `model` maintains a `selectedEpicEvent` variable whose registrants will be displayed in the `AttendancePanel`.

In order to get the `AttendanceListPanel` to instantly update its elements, we employ the JavaFX Bean Pattern. We listen to changes to object properties by using the JavaBeans API to represent the properties.

The `Person` class is implemented this way:

[source,java]
----
public class Person extends SimpleObjectProperty {

    // ... Person logic ...

    /**
     * Edits this person by transferring the fields of dummyPerson over.
     * Used for the mutable edit command
     */
    public void setPerson(Person dummyPerson) {
        // ... setPerson logic ...
        fireValueChangedEvent();
    }
}
----

This way, editing `Person` calls `fireValueChangedEvent()` which informs JavaFX of the content change and triggers an UI refresh.

To listen to changes in attendance. We enable the `AttendanceList` to report changes on the element by providing a properties extractor. First, we use the JavaBeans API to represent properties of `Attendance` that we want to listen to, which is the `hasAttendedEventProperty`, a `BooleanProperty` object.

We use an Extractor which is a Callback containing an array of `Observables` which are then observed by the `ObservableList`.

[source,java]
----
Callback<Attendance, javafx.beans.Observable[]> extractor = attendance -> new javafx.beans.Observable[] {
                attendance.getPerson(), attendance.getHasAttendedEventProperty()};
----

By using the JavaBeans API to handle UI updates, the programmer does not have to care about manually refreshing the UI upon data updates.

//.Sequence Diagram for Panel initialisation
//image::CreatePersonListPanelSequenceDiagram.png[width="650"]

==== Design Considerations

When deciding on the UI, the following aspects of user experience were considered:

===== Aspect: Overall UI Design

- *Alternative 1 (current choice)*: A three-pane UI consisting of list of persons, events, and registrants for the selected event
    * Pros: The user can view all 3 lists at the same time. He would know what arguments to supply when typing commands as he can read them off the list.
    * Cons: The UI might become too cluttered as there are too many UI elements. However, given that EPIC is meant for modern computers with large displays, this should not be an issue.
- *Alternative 2 (previous choice)*: two-pane UI where the left pane is a two tab pane consisting of a list of persons and events, and the right pane is a list of registrants
    * Pros: Merging the horizontal space for the list of persons and events will create more space for the list of registrants. The user is likely to be more interested in the registrants' details.
    * Cons: If the user needs to access data for some tabbed pane that is not in focus to fill out a command, he would have to delete his current command, and execute a command to set focus to the desired tab. He must then memorize the required details and reenter his previous command. This would break his workflow and be a great inconvenience.
- *Alternative 3*: A common list that can display either list of persons, events or registrants for the selected event
    * Pros: We only have to make minimal changes to the UI layout.
    * Cons: Events, persons, and registrants must be displayed using the same `Card` class. This would result in tight coupling of the display graphics logic  for the three lists.

===== Aspect: Updating UI when Data Changes

Previously, changes to `Person` would create a new `Person` object that would replace the previous object, triggering a UI refresh. Now that such changes to `Peron`, `EpicEvent` and `Attendance` objects only mutate it, the `ListView` is unable to listen to such changes.

- **Alternative 1 (current choice)**: Use the JavaFX Beans Convention
    * Pros: Using the JavaBeans API to represent a property of an object allows property changes to be propagated to property change listeners. This is an elegant way to get the `ListView` to instantly update its elements.
    * Cons: Using the JavaBeans API to represent object properties introduces coupling between the Model and UI components.
- Alternative 2: Force all commands that change data to invoke a UI refresh
    * Pros: It is straightforward to force a `ListView` UI refresh by invoking its `refresh()` method.
    * Cons: We will have to ensure that any action that could modify data forces a UI refresh. In addition, constantly invoking a UI refresh could become a resource hog.

==== Binding Data to Attendance Pane

- **Alternative 1 (current choice)**: Bind `ObservableEpicEvent` to the Attendance Pane
    * Pros: As `ObservableEpicEvent` extends `Observable`, it can listen to when the selected event changes and update the Attendance Pane accordingly.
    * Cons: More code has to be written and maintained as we are introducing an additional layer of abstraction.
- Alternative 2: Bind `ObservableList<Attendance>` to the Attendance Pane
    * Pros: Binding data to the Attendance Pane is straightforward and the approach used to bind data to the People and Events Panels can be used here too.
    * Cons: Logic to handle the switching of selected events is moved up to the `MainWindow`, increasing coupling between the `MainWindow` and `AttendanceListPanel`. It is a violation of Single Responsibility Principle as the `MainWindow` should only be concerned with displaying the main layout.
// end::threepaneui[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[TIP]
Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

// tag::massregistration[]

=== [Proposed] Mass Registration

==== Proposed Implementation

This feature is proposed to allow mass registration of multiple persons, with
the same tag, to a single event. For example, a user can register all persons tagged with
`computing` for a computing-related seminar.

The proposed implementation is to make use of tags to select a group persons to register for an event.
Currently, the `Tag` class has been split into `PersonTag` and `EpicEventTag` so as to
differentiate between the two. This allows searching for persons by `PersonTag` and searching for events by `EpicEventTag`.

By doing so, a `register-by-tag` command can be implemented that takes in a `PersonTag` as an argument.
The persons can be filtered by `PersonTag` and the list of filtered persons can be registered
to an `EpicEvent` without requiring the user to register each person individually.

// end::massregistration[]

// tag::exporteventdevguide[]

=== [Proposed] Export an Event

The proposed export command exports their contact information and their attendance information of a particular
event to a csv file into a file path specified by the user. Having all the information of a
particular event in a csv file would enable the user to analyse the data using other tools.

==== [Proposed] Implementation

The `export-event` command input is first parsed in `EventPlannerParser` to create an `ExportEventCommand`.
The execution of it creates a `CsvEventPlannerStorage`. The subsequent export mechanism is handled by a `CsvEventPlannerStorage` where event data is parsed by `CsvUtil` and then exported as a file through `CsvFileStorage` using the file path specified by the user.

<<#SDCSV>> below shows how the csv event export is processed in the storage component.

[#SDCSV]
.Sequence Diagram for csv export
image::ExportEventSequenceDiagram.png[width="650"]

==== Design Considerations

When deciding on the export options, the following aspects of the user experience are considered.

===== Aspect: Data to be Exported

- *Alternative 1 (current choice)*: Name of the registrants, their phone number, their email address, their home address and their attendance information for the event
    * Pros: The information includes almost all the data users need for an event. The parsing of the data is straight forward.
    * Cons: The tags of the registrants are not exported.
- *Alternative 2*: All information for registrants including their tags
    * Pros: More information for users as compared to current implementation.
    * Cons: The registrants may have zero or multiple tags. The uncertainty in the number of tags makes parsing messy.

==== Aspect: Format of Exported Files

- *Alternative 1 (current choice)*: csv files
    * Pros: The format can be imported and then processed by most data processing applications in the market.
    * Cons: The files are not reader friendly if they are opened directly as a text file.
- *Alternative 2*: excel files
    * Pros: Excel files are well-formatted when opened with Microsoft Excel.
    * Cons: Even though Microsoft Excel is used by many people, some may prefer other data processing applications that support csv files but not excel files.

// end::exporteventdevguide[]

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF Format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Testing]]
== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of Tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews
When a pull request has changes to asciidoc files, you can use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of those asciidoc files will look like when the pull request is merged. See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, EPIC depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Product Scope

*Target user profile*:

* has to plan school events with a large attendance size
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: streamline attendance taking and registration of event registrants, far superior to traditional pen and paper registration

*Feature Contribution*:

* Raynold Ng:
** Minor: Add commands for searching list of registrants and displaying all registrants. This allows the user to filter list of registrants from a list of keywords.
** Major: Implemented a three pane view (persons, events, and event registrant). The user should be able to view persons, events and registrants of an event at the same time. That would also allow the user to execute event administration commands as he can view both events and contacts at the same time.

* Wei Liang:
** Minor: Add EpicEvent class to keep track of events and a command to add an event. This facilitates the implementation of the other commands to manipulate events.
** Major: Add Attendance class and a command to toggle attendance for each event registrant. This facilitates the attendance portion of the event planner.

* Jiang Yue:
** Minor: Persistent storage. The user should be able to have their data retained after the app is closed so that they can continue their edits when they open the app next time.
** Major: Adding commands to modify EpicEvents in the eventlist. The commands implemented include `delete-event`, `find-event` and `edit-event`. The commands allow user to locate an event with `find-event` and then to modify the located event by deleting the event or editing the information of the event with `delete-event` and `edit-event` respectively.

* Wei Heng:
** Minor: Adding commands for Person-EpicEvents interactions, which includes adding new fields/methods to the EpicEvent class. The commands implemented include `register`, `deregister` and `list-registered`. The commands allow user to register/deregister a person to/from an event, as well as list an event's register in the UI.
** Major: Revamp of undo/redo feature. Currently, the entire EventPlanner is saved every time an UndoableCommand is executed, which is a huge drain on memory and violates important non-functional requirements relating to capacity of EventPlanner. Each UndoableCommand will have an UndoableCommand oppositeCommand, which it will execute to reverse the changes made by the original command. This will also allow edit's behavior to be mutable, so we may modify an event/person directly without passing a new copy to every single person/event that is in it/it is in.

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *`|new user |see an onboarding guide |familiarize myself with the application

|`* * *` |event planner |add a new registrant |

|`* * *` |event planner |delete a registrant |remove a registrant that has withdrawn from the event

|`* * *` |event planner |list all registrants for the event |

|`* * *` |event planner |edit a registrant’s details |update a registrant’s details upon request

|`* * *` |event planner |mark attendance for a registrant |know who attended the event

|`* * *` |event planner |find a registrant by name |locate a registrant without going through the entire list of registrants

|`* * *` |event planner |have all registrant’s data in persistent storage |close the program without losing my data

|`* *` |event planner |set privacy settings |meet PDPA guideline

|`* *` |event planner |create multiple events|

|`* *` |event planner |add the same user to multiple events |use the same, stored information across multiple events

|`* *` |event planner managing large events |import registrant contact information from csv |quickly add registrants without manual typing

|`* *` |event planner managing large events |export registrant contact information as csv |use the data for other applications (e.g. presentation, data analysis)

|`* *` |event planner managing many registrants |find a registrant by his/her initials |find persons quickly

|`* *` |event planner |manage registrants based on tags |mass register/delete registrants belonging to a certain group

|`*` |registrant |mark my attendance by scanning a QR code |make the process of marking attendance quicker

|`*` |registrant |mark my attendance by scanning a card with an RFID chip |make the process of marking attendance quicker

|`*` |event planner |fuzzy search contacts |find the relevant contact even if I do not know his/her complete name

|`*` |registrant |mark my attendance by scanning an NFC tag |make the process of marking attendance quicker

|`*` |registrant |see where I should be seated at the venue when I mark my attendance |find my seating location quicker

|`*` |event planner |synchronize application data across multiple devices |collaboratively edit registrant information

|`*` |registrant |add feedback for the event |

|`*` |event planner |send out a mass email to all registrants |send out information such as event details and QR codes quickly

|`*` |event planner |make my edits synchronized in real time across all devices |parallelize the registration and attendance taking process

|`*` |event planner |automatically email a reminder to all registrants near the event date |ensure registrants do not accidentally forget about the event

|`*` |event planner |type commands in natural language |do without memorising the syntax for every command

|`*` |tech-savvy event planner |set hotkeys for commands |shorten frequently used commands

|`*` |event planner |export event details (attendance rate, feedback etc) in a presentable format |do an after action review of the event

|`*` |event planner |conduct a lucky draw for event registrants |
|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `EventPlanner` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use Case: Find Person by Name

*MSS*

1.  User requests to find persons with a particular name
2.  EventPlanner shows a list of persons with entered name
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
** 2a1. EventPlanner alerts the user that there is no such person with name
+
Use case ends.

[discrete]
=== Use Case: Delete Person

*MSS*

1.  User requests to list persons
2.  EventPlanner shows a list of persons
3.  User requests to delete a specific person in the list
4.  EventPlanner deletes the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. EventPlanner shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use Case: Edit Person

*MSS*

1. User requests to list persons
2. EventPlanner shows a list of persons
3. User requests to edit a specific person in the list
4. EventPlanner edits the person’s details
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. EventPlanner shows an error message.
+
Use case resumes at step 2.

* 3b. The edit string following the command is invalid.
+
[none]
** 3b1. EventPlanner shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use Case: Mark Event Attendee's Attendance

*MSS*

1. User requests to find persons by name
2. EventPlanner shows a list of persons
3. User requests to mark the attendance of that person
4. EventPlanner marks the attendance of that person
+
Use case ends.

*Extensions*

[none]
* 2a. No persons are found.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. EventPlanner shows an error message.
+
Use case resumes at step 2.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 50000 persons.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Should come with automated unit tests and open source code.
.  Should work on both 32-bit and 64-bit environments.
.  Should respond to any command within one second
.  Should be able to be used by programmers and non-programmers alike
.  Should not result in a large binary (more than 5mb)
.  Packaging should take care of dependencies

[appendix]
== Glossary

[[cli]] Command Line Interface (CLI) :: Means of interacting with a computer program where the user issues commands to the program in the form of typed text

[[csv]] Comma Separated Values (CSV) :: A file that stores tabular data in plain text

[[fuzzy-search]] Fuzzy Search :: process that locates terms that are likely to be relevant to a search argument even when the argument does not exactly correspond to the desired information

[[hotkeys]] Hotkeys :: A combination of keys that what pressed together, executes a command

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[natural-language]] Natural Language :: any language that has evolved naturally in humans through use and repetition without conscious planning or premeditation

[[nfc]] NFC (Near-Field Communication) :: Radio communication technology standard to send data over short distances

[[pdpa]] PDPA (Personal Data Protection Act) ::
A Singapore law that governs collection, use and disclosure of personal data by all private organisations

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others

[[qr-code]] Quick Response (QR) code:: A machine-readable matrix (or two-dimensional barcode) that contains information about the item to which it is attached

[[rfid]] Radio-frequency identification (RFID) :: A technology to record the presence of an object using radio signals

[appendix]
== Product Survey

*Guestday*

Author: Tinkertanker Pte Ltd

Website: https://guestday.com

Pros:

* Fast Contextual Search
** Search for guests by name, table, department, or any other parameter of your choosing.
* Quick, easy check-in
** Effortlessly check the guest in with a simple swipe. Guests can also find out where they’re seated and whom they’re seated with. Display custom data to aid your receptionists, such as information on VIP registrants.
* Even faster: QR scanning
** Send out QR codes on physical invitation cards or by email, and guests can simply wave their codes at the iPad camera to check in.
* Synchronization across multiple devices
** Multiple devices can be setup to parallelize the registration process and increase the efficiency of the reception
* Elegant and easy to use interface


Cons:

* Requires specific hardware (iPads loaned out by the company).
* Expensive, and not reusable (payment for each event).
* Proprietary software, not open source.
* registrant contact information cannot be reused across multiple events - has to be re-entered.
* Editing guest list has to go through the company and hence is slow and a large hassle.

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a Person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving Data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_

