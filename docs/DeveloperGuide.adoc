= CoinBook - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/CS2103JAN2018-F09-B3/main

By: `Team CS2103JAN2018-F09-B3` Since: `Feb 2018` Licence: `MIT`

== Setting Up

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` -> `Settings` -> `Plugins` to re-enable them.


=== Setting Up the Project in Your Computer

. Fork this repo, and clone the fork to your computer.
. Open IntelliJ. If you are not in the welcome screen, click `File` -> `Close Project` to close the existing project dialog first.
. Set up the correct JDK version for Gradle.
.. Click `Configure` -> `Project Defaults` -> `Project Structure`.
.. Click `New...` and find the directory of the JDK.
. Click `Import Project`.
. Locate the `build.gradle` file and select it. Click `OK`.
. Click `Open as Project`.
. Click `OK` to accept the default settings.
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the Setup

. Run the `seedu.address.MainApp` and try a few commands.
. <<Testing,Run the tests>> to ensure they all pass.

=== Configurations To Do Before Writing Code

==== Configuring the Coding Style

This project follows [ext]#https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]#. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify this:

. Go to `File` -> `Settings...` (Windows/Linux), or `IntelliJ IDEA` -> `Preferences...` (macOS).
. Select `Editor` -> `Code Style` -> `Java`.
. Click on the `Imports` tab, and set the following options within.

* Set `Class count to use import with '\*'` and `Names count to use static import with '*'` to `999` to prevent IntelliJ from contracting the import statements.
* Set the order for `Import Layout`: `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`.

Optionally, you can follow the [exref]##<<UsingCheckstyle#, UsingCheckstyle.adoc>>## document to configure Intellij to check style-compliance as you write code.

==== Updating Documentation to Match Your Fork

After forking the repo, links in the documentation will still point to the `CS2103JAN2018-F09-B3/main` repo. If you plan to develop this as a separate product (instead of contributing to `CS2103JAN2018-F09-B3/main`), you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting Up Continuous Integration

See [exref]##<<UsingTravis#, UsingTravis.adoc>>## to learn how to set up Travis to perform Continuous Integration (CI) for your fork.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see [exref]##<<UsingCoveralls#, UsingCoveralls.adoc>>##).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see [exref]##<<UsingAppVeyor#, UsingAppVeyor.adoc>>##).

[NOTE]
Having both Travis and AppVeyor ensures that your app works on both Unix-based platforms and Windows-based platforms. Travis is Unix-based and AppVeyor is Windows-based.

==== Getting Started With Coding

When you are ready to start coding, get some sense of the overall design by reading the next section on _CoinBook_'s <<Design-Architecture>>.

== Design

[[Design-Architecture]]
=== Architecture

The *_Architecture Diagram_* below (Fig. 1) explains the high-level design of the App.

.Architecture Diagram
image::Architecture.png[width="600"]

Following is a quick overview of each component:

`*Main*` has only one class called [exref]#link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]#. It is responsible for:

* (On app launch) Initializing the components in the correct sequence, and connecting them up with one another
* (On shut down) Shutting down the components and invoking cleanup methods where necessary

`*Commons*` represents a collection of classes used by multiple other components. Two of these classes play important roles at the architectural level.

* `EventsCenter` : This class (written using [ext]#https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]#) is used by components to communicate with other components using events (i.e. a form of <<event-driven-design,Event Driven Design>>)
* `LogsCenter` : Used by classes to write log messages to the App's log file.

These classes are located in the [exref]#link:{repoURL}/src/main/java/seedu/address/commons[`seedu.address.commons`]# package.

The rest of the App consists of four components: +
<<Design-Ui,*`UI`*>>: The UI of the App. +
<<Design-Logic,*`Logic`*>>: Executes commands. +
<<Design-Model,*`Model`*>>: Holds the data of the App in memory. +
<<Design-Storage,*`Storage`*>>: Reads data from and writes data to the hard disk.

Each of these four components:

* Defines its [gloss]#<<API,_API_>># in an interface with the same name as the component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see Fig. 2 below) defines its API in the `Logic.java` interface and exposes its functionality via the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[width="800"]

[discrete]
[[event-driven-design]]
==== Event-Driven nature of the design

The _Sequence Diagram_ below (Fig. 3) shows the interaction between the various components when the user issues the command `delete 1`.

.Component interactions for `delete 1` command (part 1)
image::SDforDeleteCoin.png[width="800"]

[NOTE]
Note how the `Model` simply raises `AddressBookChangedEvent` when the data is changed, instead of asking `Storage` to save the updates to the hard disk.

Fig. 4 below shows how `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

.Component interactions for `delete 1` command (part 2)
image::SDforDeletePersonEventHandling.png[width="800"]

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be [gloss]#<<coupling,coupled>># to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The following sections give more details about each component.

[[Design-Ui]]
=== UI Component

*API* : [exref]#link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]#

The `UI` component:

* Executes user commands using the `Logic` component
* Binds itself to data in the `Model` so that the UI can update itself automatically when data in the `Model` changes
* Responds to events raised from various parts of the App and updates the UI accordingly

The following diagram (Fig. 5) illustrates the structure of this component:

.Structure of the UI Component
image::UiClassDiagram.png[width="800"]

The user interface (UI) consists of a `MainWindow` that is made up of several parts, e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of the UI parts are defined in matching `.fxml` files located in the `src/main/resources/view` folder. For example, the layout of the
[exref]#link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`]# is specified in
[exref]#link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]#

[[Design-Logic]]
=== Logic Component

*API* :
[exref]#link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]#

The `Logic` component:

* Parses and executes user commands
* Manages command history and undo/redo information

The following diagrams (Fig. 6, 7) illustrate the structure of this component:

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[width="800"]

.Structure of Commands in the Logic Component. Example of `XYZCommand` and `Command` in <<fig-LogicClassDiagram,Fig. 6>>
image::LogicCommandClassDiagram.png[width="800"]

When a user issues a command, the following steps are performed:

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a coin) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is then passed back to the UI.

Given below is the Sequence Diagram (Fig. 8) for interactions within the `Logic` component for the `execute("delete{nbsp}1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeletePersonSdForLogic.png[width="800"]

[[Design-Model]]
=== Model Component

*API* :
[exref]#link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]#

The `Model` component:

* Stores a `UserPref` object that represents the user's preferences
* Stores the CoinBook data
* Exposes an unmodifiable `ObservableList<Coin>` that can be _observed_ e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list changes
* Does not depend on any of the other three components

The following diagram (Fig. 9) illustrates the structure of this component:

.Structure of the Model Component
image::ModelClassDiagram.png[width="800"]

[[Design-Storage]]
=== Storage component

*API* :
[exref]#link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]#

The `Storage` component:

* Can save `UserPref` objects in JSON format and read it back
* Can save the CoinBook data in XML format and read it back

The following diagram (Fig. 10) illustrates the structure of this component:

.Structure of the Storage Component
image::StorageClassDiagram.png[width="800"]

== Implementation

This section describes some noteworthy details on how certain features are implemented.

=== Condition Parser feature

==== Current implementation
The general parser for the SQL-like arguments for the find command can be broken down into a few sub-components, namely
the `Lexer`, `SyntaxParser`, `SemanticParser`, and a `ConditionGenerator`, while using classes such as `Condition`,
`Token`, `TokenType`, `TokenStack` to model the data that is to be operated on throughout the process. Their tasks are
delegated as follows:

* `Lexer` : Lexically analyzes the input string, then creates a list of tokens.
* `SyntaxParser` : Parses the input by matching the tokens versus a list of rules to ensure they fit the desired
structure.
* `SemanticParser` : Parses the input by matching the tokens versus a list of rules to ensure their meaning is semantically valid
* `ConditionGenerator` : Uses the list of tokens to create the equivalent lambda function to evaluate `Coin` objects against.

[NOTE]
The distinction between the SyntaxParser and the Semantic Parser is that the syntax parser is oblivious as to what the
input actually means, and only cares whether the structure is correct, whereas the semantic parser verifies the meaning behind the
input. For example, `n/BTC AND OR p/>500` would not even be valid syntatically, whereas `n/BTC or p/>BTC` would be valid syntatically
but not semantically, since it would not make sense to search for `Coin` objects whose price attribute was more than
"BTC" since a price cannot be compared to a name.

Below is the UML
describing the classes and their relationships.

.Class UML diagram for the Condition Parser
image::ParserClassDiagram.png[]

The general flow of the parser is very linear in nature, an input string is first broken up into reasonable sections by
the lexer based on their possible meaning, then the syntax and semantic parser ensure that the input follows the
structure required and then finally a condition objects is generated representing the statement that can be used to
evaluate Coin objects.

.Sequence diagram for the `ConditionParser` class on correct inputs
image::mainSequence.png[width=800]

We will illustrate the flow of the CommandParser on an example input:
```
> n/BTC OR ( t/fav AND p/>100 )
```
===== Lexer
Firstly, the lexer would tokenize this into:

```
> [n/,OPTION][BTC,STRING][OR,BINARYOP][(,LEFTPAREN][t/,OPTION][fav,STRING][AND,BINRARYOP][p/,OPTION][>,COMPARATOR][100,NUMBER][),RIGHTPAREN]
```
Notice how the whitespace has now been discarded, since it is not used for the purposes of parsing. Also each section of
the input has now been grouped with a type.

Below is a sequence diagram describing the behaviour of `Lexer` on the input:

.Sequence diagram for the `Lexer` class
image::Lexer.png[]


===== Syntax Parser

Next, the syntax parser has to ensure that the sequence of tokens is actually structurally valid.
This is done by matching the tokens off based on the following rules, expressed in Backus Naur form:

. `EXPRESSION` := `TERM` | `TERM` `BINARYOP` `EXPRESSION`
. `TERM` := `LEFTPAREN` `EXPRESSION` `RIGHTPAREN` | `UNARYOP` `TERM` | `CONDITION`
. `CONDITION` := `OPTION` `COMPARATOR` `NUM` | `OPTION` `STRING`


Using our example, we will illustrate how we can sequentially express the argument based on the provided rules:

. `EXPRESSION`
. `TERM` `BINARYOP` `EXPRESSION`
. `CONDITION` `BINARYOP` `EXPRESSION`
. `OPTION` `STRING` `BINARYOP` `EXPRESSION`
. n/`STRING` `BINARYOP` `EXPRESSION`
. n/BTC `BINARYOP` `EXPRESSION`
. n/BTC OR `EXPRESSION`
. n/BTC OR `TERM`
. n/BTC OR ( `EXPRESSION` )
. n/BTC OR ( `TERM` `BINARYOP` `EXPRESSION` )
. n/BTC OR ( `CONDITION` `BINARYOP` `EXPRESSION` )
. n/BTC OR ( `OPTION` `STRING` `BINARYOP` `EXPRESSION` )
. n/BTC OR ( t/ `STRING` `BINARYOP` `EXPRESSION` )
. n/BTC OR ( t/fav `BINARYOP` `EXPRESSION` )
. n/BTC OR ( t/fav AND `EXPRESSION` )
. n/BTC OR ( t/fav AND `TERM` )
. n/BTC OR ( t/fav AND `CONDITION` )
. n/BTC OR ( t/fav AND `OPTION` `COMPARATOR` `NUM` )
. n/BTC OR ( t/fav AND p/ `COMPARATOR` `NUM` )
. n/BTC OR ( t/fav AND p/ > `NUM` )
. n/BTC OR ( t/fav AND p/>100 )

The recursive methods `Expression`, `Term`, `Condition` in the syntax parser class will match their own respective tokens
as necessary. In fact the method calls in the parser are exactly the same as the matches made in the previously stated sequence.
For example, here is the implementation for `EXPRESSION`.

[source,java]
----
boolean expression() {
    if (!term()) {
        return false;
    }
    while (tokenStack.matchAndPopTokenType(TokenType.BINARYBOOL)) {
        if (!term()) {
            return false;
        }
    }
    return true;
}
----

Visually we can represent it with the following parse tree, which also serves as the recursion tree:

.Parse and recursion tree for the example input
image::parsetree.png[]

===== Semantic Parser

Following up, the Semantic Parser has to verify that the conditions are correct. This can be done by verifying the
type of the condition versus the parameters that follow. For example, a name condition should only be followed by a string.
This can be done by checking the corresponding option class versus the type of token that follows.

===== Condition Generator

Lastly, the condition generator creates lambdas based on the type of conditions found, and then recursively composes each
condition based on the binary operators encounters up the recursion tree.

==== Error handling
On syntactically invalid inputs, the `ConditionParser` will retrieve the expected and actual type of Token that were not a math
during the parsing phase from the `TokenStack` and raise an exception before returning.

Below is the sequence diagram depicting the `ConditionParser` control flow when the `SyntaxParser` has identified an error in the input.
Since the `SemanticParser` has similar structure, the sequence diagram would look very similar the the one below.

.Sequence diagram for the `ConditionParser` class on erroneous inputs
image::failSequence.png[]

==== Design Considerations

===== Aspect: Specification of syntax

* **Alternative 1 (current choice):** Have the structure of the methods reflect exactly the syntax.
** Pros: Since the syntax is apparent, any subsequent changes can be easily done by having the code reflect the new syntax.
** Cons: Cumbersome to have to alter the code every time there is a change in syntax.
* **Alternative 2:** Specify the syntax in a separate file (e.g. EBNF file), and metaprogram the parser based on the file.
** Pros: Requires 0 code change whenever the syntax has to be modified.
** Cons: The code to support this would be very complicated and not apparent to developers immediately.

===== Aspect: Implementation of `SyntaxParser`, `SemanticParser`, `ConditionGenerator`

* **Alternative 1 (current choice):** Have separate classes that have the same structure but with different return values.
** Pros: Maintains SRP.
** Cons: A change in syntax requires change across 3 classes. It is also very redundant having similar code.
* **Alternative 2:** Have a single implementation that performs syntax parsing, semantic parsing and the condition generation.
** Pros: Removal of redundant code.
** Cons: Clearly violates SRP.

// tag::undoredo[]
=== Undo/Redo feature
==== Current Implementation

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports the undoing and redoing of commands that modify the stored data (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. Here is the inheritance diagram for commands (Fig. 11):

.Class Diagram for Logic
image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the App data before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks, while the child classes implement the details for executing the specific command. This technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the [ext]#https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern]#.

Commands that are not undoable are implemented in this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented in this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` is empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th entry. The current state of the App data is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command). Fig. 12 below illustrates this.

.Undo/Redo Stack Part 1
image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to issue more commands, they are added into the `undoStack`. For example, the user may execute `add BTC ...` to add a new coin, resulting in the below picture (Fig. 13):

.Undo/Redo Stack Part 2
image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the coin was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it to the `redoStack`. At the same time, the data is restored to the state before the `add` command executed. The figure below (Fig. 14) illustrates the result:

.Undo/Redo Stack Part 3
image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, i.e., there are no other commands left to be undone, an `Exception` will be thrown when trying to pop the `undoStack`.

The following sequence diagram shows how the undo operation works:

.Sequence Diagram for Undo
image::UndoRedoSequenceDiagram.png[width="800"]

The `redo` command does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the data to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. However, now the `redoStack` is not empty, and it will be purged as it no longer makes sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow). Refer to Fig. 16 below:

.Undo/Redo Stack Part 4
image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution (Fig. 17):

.Undo/Redo Stack Part 5
image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarizes the logic for `UndoRedoStack` when a user executes a new command:

.Activity Diagram for Undo/Redo
image::UndoRedoActivityDiagram.png[width="650"]

==== Design Considerations

===== Aspect: Implementation of `UndoableCommand`

* **Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()`
** Pros: We will not lose any undo/redo functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist.
** Cons: Hard for new developers to understand the template pattern.
* **Alternative 2:** Just override `execute()`
** Pros: Does not involve the template pattern, easier for new developers to understand.
** Cons: Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire state.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual commands know how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the coin being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.


===== Aspect: Type of commands that can be undone/redone

* **Alternative 1 (current choice):** Only include commands that modify the App data (e.g. `add`, `clear`, `edit`).
** Pros: We only revert changes that are hard to do manually (the view can easily be re-modified as no data is lost).
** Cons: User might think that undo also applies when the list is modified (undoing filtering for example), only to realize otherwise after executing `undo`.
* **Alternative 2:** Include all commands.
** Pros: Might be more intuitive for the user.
** Cons: User has no way of skipping such commands if he or she just wants to reset changes made to the data and not the view.
**Additional Info:** See the discussion  [ext]#https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here]#.


===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use separate stack for undo and redo
** Pros: Easier to understand for new Computer Science undergraduates, who represent the majority of incoming developers to our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `UndoRedoStack`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate stack, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone; we must remember to skip these commands. This approach violates the Single Responsibility Principle and the Separation of Concerns Principle as `HistoryManager` now needs to do two different things.
// end::undoredo[]

// tag::notifications[]
=== User-Set Notifications

==== Current Implementation

The notification system is facilitated by a `RuleBook`, which is located with the `Model` component as part of the App data. `RuleBook` holds a set of rules which define, in this case, conditions to trigger notifications on. A `NotificationManager` also does the work of checking and generating notifications.

Let us walk through the implementation of notifications by considering a typical scenario involving this feature. Suppose the user wants to keep track of a certain coin's price, say `BTC`.

The user adds a new notification using `NotifyCommand`, e.g. `notify BTC p/15000`, which sets a new notification to be triggered for when the price of `BTC` crosses $15000 (from either direction). The corresponding rule is added to the notification `RuleBook`.

Later on, the user may add other notifications. So now, there are a list of different rules stored in _CoinBook_. When the price data is synced with latest data from the web, whether from the regular update or triggered by the user with the `update` command, a `CoinChangedEvent` is sent out for each updated coin.

`NotificationManager` catches these events, and checks against the notifications `RuleBook`. If any match, a notification pops up to alert the user.

The diagram below (Fig. 20) summarises these interactions:

image::NotificationsSequenceDiagram1.png[width="800"]
.Sequence Diagram for Notifications
image::NotificationsSequenceDiagram2.png[width="800"]

==== Design Considerations

===== Aspect: Module to put notification handling in

* Alternative 1 (current choice): Make a new package for notifications.
** Pros: All the notification handling can be encapsulated in its own component.
** Cons: Notification handling alone seems too narrow a scope for a top-level component.

* Alternative 2: Put it in `Commons`.
** Pros: No need to make a new module.
** Cons: Notifications is not an integral component and no other classes depend on it directly so it is not very appropriate to place it here.

* Alternative 3: Put it in `Model` along with the implementation of `RuleBook` itself.
** Pros: Rules management and notifications management in the same place which has better code readability.
** Cons: Violates Separation of Concerns and Single Responsibility Principles as `Model` then manages both data, and user interaction / platform features.

[TIP]
The `RuleBook` is actually made general-purpose in the sense that it can hold other types of rules for future extensions, e.g. Automated Task Rules, etc. +
Later on, the `Notification` component may morph into a general "rules execution" component which manages different types of rules and performs their associated actions.

===== Aspect: Which kind of notification to use

* Alternative 1: Platform-side notifications, e.g. system tray.
** Pros: User can integrate these into their own workflow, such as setting other programs to listen in on system notifications and forward them to their other device, generate emails, take actions, etc. User has some control over how notifications look and behave.
** Cons: May not work on every platform; heavily dependent on implementation of Java features. For example, some distributions of Linux may not include system trays.

* Alternative 2 (current choice): Application-side notifications.
** Pros: Uses the same framework which displays the App window itself, so is guaranteed to work alongside the App.
** Cons: Less flexibility in customisation and availability of integration into user's preferred workflow.

===== Aspect: Undo-ability of `NotifyCommand`

* Alternative 1 (current choice): Not an `UndoableCommand`.
** Pros: We can keep notification rule data separate from coin data. The basic functionality of `RuleBook` is implemented inside `Model` which deals with data, but the rules are instantiated only in the `Notifications` component itself. A rule manager window will be available for editing or deleting existing notifications.
** Cons: Not as intuitive as users have to manage coins and rules slightly differently.

* Alternative 2: Undoable just like `add`, `edit`, etc.
** Pros: Intuitive, single interface for similar operations.
** Cons: Since the current implementation of `UndoableCommand` requires saving
the state of `Model`, which is a wrapper for just the coin data, this would
increase the coupling between the coin data and the rule data parts of `Model`. We want to keep `Model` as an interface for just the coin data itself.

// end::notifications[]

// tag::organisation[]

[[Implementation-Organisation]]
=== Organisation Features

==== Sorting

The sorting mechanism is facilitated by `Collections.sort`. It supports sorting of the coins when the unsorted coin list is passed into the sort method to arrange the coins in a manner that the user chooses.

The way `Collections.sort` works is that it takes the collection's underlying array and calls its sort method to sort the actual elements. The sorting algorithm used by Java is Timsort.

The method returns void because it sorts the collection in-place and thus it modifies the collection you give it as a parameter by sorting its elements. As a result, a sorted copy need not be returned, thus saving resources.

* Sort by coin value

** We can use `Comparator.comparingDouble()` for comparing double values. For _CoinBook_, we want to order our list of coins by value, from the highest to the lowest.
** We can use the `reversed` function on the `Comparator` to invert default, to arrange coins from lowest to highest instead.
** `Double` is used because coin values have several decimal places and so using `comparingInt()` would not suffice.

* Sort by string field (coin code)

** If we want to sort our `CoinList` by coin code we can use `Comparator.comparing()` and pass a function that extracts the 3 letter coin code.
** One does not have to pass any comparator for the list to be correctly sorted because the 3-letter coin code is a string and `String` implements the `Comparable` _interface_.

==== Grouping

We can use the `Collectors` class, which provides methods for grouping data stored in collections. Grouping would permit the user to organise coin data based on a common field, e.g coins prices equal to or over 1000 dollars per coin.

The `GroupingBy` method from the `Collectors` class is responsible for organising the coin data into groups. In this case the group is defined by the value of the coin. The `Collect` method from the `Stream` class accepts the `GroupingBy` method as its argument and returns a map containing the results. The results are then displayed.

Using the `GroupingBy` collector from the `Collector` class, it takes a single parameter (classifier) that assigns a grouping key to every stream element.

By default, elements with the same key are inserted into `List<T>`, although this can be changed by specifying a second parameter to `GroupingBy`.

==== Design Considerations

===== Aspect: Implementation of Sort

* Alternative 1 (current choice): Make use of `Collections.sort`

** Pros: `String` implements `Comparable` interface so there is no need to pass any comparator for the coin list.
** Cons: Developer needs to understand the relationship between array lists and collections.

* Alternative 2: Add a new sorting function (e.g. Selection Sort)

** Pros: Possibly allows us to reduce the time required to execute the sorting command.
** Cons: Need more time to incorporate it into the address book since we are not using Javaâ€™s in-built sorting method.

===== Aspect: Implementation of Groups

* Alternative 1 (current choice): Make use of GroupingBy method

** Pros: User has an additional option where he can view coins based on a specified attribute.
** Cons: Developer needs to understand the relationship between `Stream`, `ArrayList` and `Collector` classes.

* Alternative 2: Adding additional tags in lieu of grouping

** Pros: Codebase already has support for tags and so not a lot of changes will be required.
** Cons: Unable to execute commands at a group level because tags merely depict the attribute of the coins, but groups act as a tool to manage several coins at the same time.

// end::organisation[]

// tag::autocomplete[]
=== [Proposed] Autocomplete feature

The autocomplete mechanism is facilitated by a `RadixTree`, which resides inside `LogicManager`. It supports the predicting of a word or phrase that the user may type based on a partial text query.

Suppose the user has 3 coins added to his account currently, namely `BTC`, `ETH`, `BCG` and `BCH` in that order.

Say the user is trying to use the `find` command to look up `BCH`.

The user will first type `find` into the command line followed by a whitespace and `B`.
```
find B
```

Now, when the user presses kbd:[Tab], the autocomplete feature will then complete the query by suggesting the first matching item it finds.
```
find BTC
```

When the user then presses kbd:[C] to complete his query, the autocomplete feature will suggest the next matching item of the input `BC` so far.
```
find BCG
```

The user can then press kbd:[Tab] again to cycle through the other items that match the current input `BC`.
```
find BCH
```

At this point the user has found `BCH`, which is the coin that the user wanted to look up and can now kbd:[Enter] his command.

==== Design Considerations

===== Aspect: Which fields autocomplete work on

* **Alternative 1 (current choice):** Only applicable for command parameters.
** Pros: Less to implement.
** Cons: May not satisfy every user.
* **Alternative 2:** Applicable for both command word and command parameters.
** Pros: Slightly better user experience.
** Cons: Lower value to effort ratio to implement given that aliases are already implemented.

===== Aspect: Data structure to support the autocomplete feature

* **Alternative 1 (current choice):** Use a Radix Tree
** Pros: Easier to understand for new Computer Science undergraduates, who represent the majority of incoming developers to our project.
** Cons: Implementation could be non-trivial.
* **Alternative 2:** Use a linear data structure
** Pros: Easy to implement.
** Cons: Inefficient, higher time complexity incurred.
// end::autocomplete[]

=== Logging

We are using the `java.util.logging` package for logging. The `LogsCenter` class is used to manage logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class `Class` can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently, log messages are output through `Console` and written to a `.log` file

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the App
* `WARNING` : Can continue, but with caution
* `INFO` : Information regarding noteworthy actions by the App
* `FINE` : Details that are not usually noteworthy but may be useful in debugging e.g. printing the list contents instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file. By default, this is `config.json`.

== Documentation

We use AsciiDoc for writing documentation.

[NOTE]
We chose AsciiDoc over Markdown because AsciiDoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See [exref]#<<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>># to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See [exref]#<<UsingTravis#deploying-github-pages, UsingTravis.adoc>># to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use [ext]#https://www.google.com/chrome/browser/desktop/[Google Chrome]# for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in [exref]#<<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>># to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Find the generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  In Chrome's menu, click on the `Print` option.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot (Fig. 19) below.

.Options for Saving Documentation as PDF Files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Testing]]
== Testing

=== Running Tests

There are three ways to run tests.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, right-click on a test package, test class, or a test, e.g. `ABC`, and choose `Run 'ABC'`

*Method 2: Using Gradle*

Open a console and run the following command:

Windows
```
> gradlew clean allTests
```
Mac/Linux
```
$ ./gradlew clean allTests
```

[NOTE]
See [exref]#<<UsingGradle#, UsingGradle.adoc>># for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the [ext]#https://github.com/TestFX/TestFX[TestFX]# library we use, our GUI tests can be run in _headless_ mode. In headless mode, GUI tests do not show up on the screen. This means the developer can do other things on their computer while the tests are running.

To run tests in headless mode, open a console and run the following command:

Windows
```
> gradlew clean headless allTests
```
Mac/Linux
```
$ ./gradlew clean headless allTests
```

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might cause some GUI tests to fail due to platform/resolution-specific idiosyncrasies.

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include:
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in the `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include:
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that check the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These tests check multiple code units as well as the connections between them. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See [exref]#<<UsingGradle#, UsingGradle.adoc>># to learn how to use Gradle for build automation.

=== Continuous Integration

We use [ext]#https://travis-ci.org/[Travis CI]# and [ext]#https://www.appveyor.com/[AppVeyor]# to perform _Continuous Integration_ on our projects. See [exref]#<<UsingTravis#, UsingTravis.adoc>># and [exref]#<<UsingAppVeyor#, UsingAppVeyor.adoc>># for more details.

=== Coverage Reporting

We use [ext]#https://coveralls.io/[Coveralls]# to track the code coverage of our projects. See [exref]#<<UsingCoveralls#, UsingCoveralls.adoc>># for more details.

=== Documentation Previews
When a pull request has changes to AsciiDoc files, you can use [ext]#https://www.netlify.com/[Netlify]# to see a preview of the HTML version of those AsciiDoc files when the pull request is merged. See [exref]#<<UsingNetlify#, UsingNetlify.adoc>># for more details.

=== Making a Release

Here are the steps to creating a new release.

.  Update the version number in
[exref]#link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`]#.
.  Generate a JAR file [exref]#<<UsingGradle#creating-the-jar-file, using Gradle>>#.
.  Tag the repo with the version number, e.g. `v0.1`.
.  [ext]#https://help.github.com/articles/creating-releases/[Create a new release using GitHub]# and upload the JAR file you created in step 2.

=== Managing Dependencies

A project often depends on third-party libraries. For example, _CoinBook_ depends on the [ext]#http://wiki.fasterxml.com/JacksonHome[Jackson library]# for XML parsing. Gradle can manage these _dependencies_ for you by downloading the them automatically, instead of having to: +

* Include those libraries in the repo (this bloats the repo size), or +
* Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Product Scope

*Target user profile*:

* has a need to manage a significant number of cryptocurrencies
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps
* requires various analysis and visualisation tools for decision-making

*Value proposition*: manage cryptocurrencies faster than a typical mouse/GUI driven app

=== Feature contribution
*Eldon Chung*

* Major: Search enhancement. Support for SQL-like queries with logical operators as well as additional search specifiers besides name, such as tags and price. This lets users manage their large portfolio easily through efficient filtering.
* Minor: Fetch news. Fetches news related to cryptocurrencies from sources such as RSS feeds. This lets users keep track of latest developments in the scene to aid their decision making.

*Ewald Hew*

* Major: Sync and notifications. Updates price data periodically and make notifications based on user-set rules. This helps users stay on top of what's happening and obtain important information at the right time.
* Minor: Charts panel for data visualization. This lets users analyse price trends for decision making.

*Lai Cheng Yu*

* Major: User experience. Create smoother workflow via GUI hints, view modes, command autocompletion, and data visualization. This helps users manage their portfolio quickly and efficiently, and lets them focus on the more important tasks.
* Minor: Data fetching system. Updates the price data, etc., in the model from a source. This lets users keep up to date on latest developments.

*Neil Mehta*

* Major: Organization options. Sorting options and groups. This lets users switch between different contexts to fit in with their objectives at the moment, and helps them focus on only what is relevant.
* Minor: Various refactoring work.

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="80%",cols="20%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |figure out how to use the application.
|`* * *` |user |see my personal portfolio |track gains/losses.
|`* * *` |user |add new coin accounts |
|`* * *` |user |delete coin accounts | remove unwanted information.
|`* * *` |user |have a tagging system |simplify and categorize my accounts.
|`* * *` |user actively trading |be able to store up to 2000 cryptocurrencies |maintain my extensive portfolio.
|`* * *` |user |have a search and find feature |avoid going through all coins manually.
|`* * *` |user who values privacy |use a program without making accounts |keep it simple.
|`* * *` |user who values privacy |store my data only on local storage |avoid having my data on potentially insecure servers.
|`* * *` |user |avoid lots of manual entry |save time.
|`* *` |user |not to have to exit the current search results before entering a new command |operate on my search results efficiently.
|`* *` |user |have a sorting feature for names, coin prices, account values, etc. |quickly rank my choices.
|`* *` |user |have a bookmarks or favourites watchlist |prioritise certain coins.
|`* *` |user |have different color themes | customise my program.
|`* *` |user |have multilingual support |understand the program better.
|`* *` |user |be able to import/export my data |transfer it to other computers.
|`* *` |user |have a fixed interval backups, that can also be manually set |ensure my data will not be lost.
|`* *` |user |macro and write custom aliasing for commands |customize my experience.
|`* *` |user |track price, market cap, and circulating supply from coinmarket |get all my information in one place.
|`* *`  |user |see <<RSI,RSI>>/<<MACD,MACD>> graphs |analyse price trends for decision-making.
|`* *` |user |see Overbought/Oversold lines | do as above.
|`*` |user |be able to set support and resistance lines | do as above.
|`*` |user |have candlestick graphs with simple/exponential moving average overlay | do as above.
|`*` |user |be able to search information on a specific coin |get all my information in one place.
|`*` |user |have desktop notifications |be informed when something needs my attention.
|`*` |user |have a daily/hourly report |keep track of the current state of my accounts.
|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `CoinBook` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Delete coin listings

*MSS*

1. User requests to delete a coin listing
2. CoinBook deletes the specified coin
+
Use case ends.

*Extensions*

[none]
* 2a. The specified coin does not exist in the storage.
+
[none]
** 2a1. CoinBook shows an error message.
+
Use case resumes at step 1.

=== Use case: Export storage data

*MSS*

1.  User requests to export storage data
2.  CoinBook requests for the file destination
3.  User specifies the file destination
4.  CoinBook exports the file
+
Use case ends.

*Extensions*

[none]
* 2a. The storage is empty.
+
Use case ends.

* 3a. The given file destination is invalid.
+
[none]
** 3a1. CoinBook shows an error message.
+
Use case resumes at step 2.

_{More to be added}_

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 2000 Coin accounts without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Should be accurate in the representation of Coin amounts, free of numerical errors.
.  All sensitive data should be stored locally.
.  Should only make configuration files in the local directory to remain fully portable.
.  Should not take more than one minute to generate summary reports.
.  Should update news and charts automatically at the user-specified frequency, with tolerance of 1% (e.g. +/-18s for 30min interval)

[appendix]
== Glossary

[[API] API::
Short for Application-Programmer Interface.

[[alias]] Alias::
Alternative forms of commands that are usually shorter for typing efficiency.

[[coinmarketcap]] Coinmarketcap::
A website that hosts <<cryptocurrency,cryptocurrency>> information, including cap rankings, prices, volumes and circulating supplies.

[[coin]] Coin::
See <<cryptocurrency, Cryptocurrency>>.

[[cryptocurrency]] Cryptocurrency::
Digital currency. Examples are: Bitcoin, Dogecoin, Etherium.

[[cryptopanic]] Cryptopanic::
An online news platform for cryptocurrencies.

[[exponential-moving-average]] Exponential moving average::
A moving average window of closing prices over a past period that places more weight on the more recent days considered. Since cryptocurrencies do not have a closing price, this defaults to their price at 23:59:59 at the timezone of the exchange.

[[MACD]] Moving Average Convergence Divergence (MACD)::
Moving Average Convergence Divergence is an indicator that is the difference between two moving averages.

[[macros]] Macros::
A set of commands that can be executed under a single custom command is a macro. For example, if a user wishes to only view coins of a specific tag in a certain sorted order, he can set create a custom macro (e.g. `sortfavourites`) such that upon entering it at a command, the program will internally first call the `search` command on the user set tags, then call the `sort` command.

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[resistance-lines]] Resistance Lines::
When the price of a coin has risen to a certain amount, the price may eventually sustain its value at this point for a period of time. This is when it obtains "resistance".

[[RSI]] Relative Strength Index::
Relative Strength Index is used as an indicator to compare the current strength of cryptocurrency versus its historical strength. The strength is calculated based on the closing prices over a period of time.

[[sensitive-data]] Sensitive Data::
Refers to data that is not meant to be shared with others.

[[simple-moving-average]] Simple Moving Average::
A moving average window of closing prices over a past period that places equal weight on all days considered. Since cryptocurrencies do not have a closing price, this defaults to their price at 23:59:59 at the timezone of the exchange.

[[support-lines]] Support lines::
When the price of a coin has fallen to a certain amount, the price may eventually sustain its value at this point for a period of time. This is when it obtains "support".

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the App manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

=== Deleting a coin

. Deleting a coin while all coins are listed

.. Prerequisites: List all coins using the `list` command. Multiple coins in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No coin is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
