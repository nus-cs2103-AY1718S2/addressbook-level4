= CoinBook - Developer Guide
:toc:
:toc-title: Contents
:toc-placement: preamble
:sectnums:
:sectnumlevels: 5
:imagesDir: images
:stylesDir: stylesheets
:pdf-stylesdir: stylesheets
:pdf-style: pdf
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/CS2103JAN2018-F09-B3/main

By: `Team CS2103JAN2018-F09-B3` Since: `Feb 2018` Licence: `MIT`

== Introduction
__CoinBook__ is a desktop application written in Java with JavaFX. You may refer to the [exref]##<<UserGuide#, User Guide>>## for more information regarding the application itself.

This guide is for developers interested in contributing to the current project, forking their own project,
or those who are just interested in the internal design and implementation details of _CoinBook_.

To set up the project and work environment, read the next section, <<Getting Started with CoinBook>>. New developers should also read about the overall <<Design>> to apprise
themselves of the architecture in this software. Existing developers may also find it useful as a reference.

If you wish to extend the key features in _CoinBook_, the chapter on <<Implementation>> delves into non-trivial details involving these features.

New developers should also read the <<Documentation>>, <<Testing>>, and <<DevOps>>
sections to learn more about the workflow, tools and frameworks currently being used in the project.
You must follow the existing workflow if you are keen on contributing to the project.

The appendices serve as a useful reference for both new and existing developers alike. Any new feature contribution
under consideration should be aligned with the design philosophies and product direction, to be considered for inclusion.

== Getting Started with CoinBook
Follow the instructions given in this section to get up and running with _CoinBook_. To summarise:

. Make sure you have the prerequisites installed. See <<prereq>> for details.
. Clone and import the project. See <<Setting Up>> for details.
. Set up additional requirements before writing your code. See <<config>> for details.

For the full details, continue reading.

=== Obtaining Prerequisites [[prereq]]

The following are required to ensure that _CoinBook_ works well.

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` -> `Settings` -> `Plugins` to re-enable them.


=== Setting Up
Follow the steps below to set up the project in your computer.

. Fork this repo, and clone the fork to your computer.
. Open IntelliJ. If you are not in the welcome screen, click `File` -> `Close Project` to close the existing project dialog first.
. Set up the correct JDK version for Gradle.
.. Click `Configure` -> `Project Defaults` -> `Project Structure`.
.. Click `New...` and find the directory of the JDK.
. Click `Import Project`.
. Locate the `build.gradle` file and select it. Click `OK`.
. Click `Open as Project`.
. Click `OK` to accept the default settings.
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. Otherwise, check that you have all the <<prereq,system requirements>> and try again. +
This will generate all resources required by the application and tests.

=== Verifying the Setup
After setting up the project by following the steps in the previous part, do the below to make sure you have everything set up nicely.

. Run the `seedu.address.MainApp` and try a few commands.
. <<Testing,Run the tests>> to ensure they all pass.

=== Configuring the Environment [[config]]
Before embarking on your modifications to _CoinBook_, you should set up the following things to facilitate a smooth development experience.

==== Configuring the Coding Style

This project follows [ext]#https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]#. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify this:

. Go to `File` -> `Settings...` (Windows/Linux), or `IntelliJ IDEA` -> `Preferences...` (macOS).
. Select `Editor` -> `Code Style` -> `Java`.
. Click on the `Imports` tab, and set the following options within.

* Set `Class count to use import with '\*'` and `Names count to use static import with '*'` to `999` to prevent IntelliJ from contracting the import statements.
* Set the order for `Import Layout`: `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`.

Optionally, you can follow the [exref]##<<UsingCheckstyle#, UsingCheckstyle.adoc>>## document to configure Intellij to check style-compliance as you write code.

==== Updating Documentation to Match Your Fork

After forking the repo, links in the documentation will still point to the `CS2103JAN2018-F09-B3/main` repo. If you plan to develop this as a separate product (instead of contributing to `CS2103JAN2018-F09-B3/main`), you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting Up Continuous Integration

See [exref]##<<UsingTravis#, UsingTravis.adoc>>## to learn how to set up Travis to perform Continuous Integration (CI) for your fork.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see [exref]##<<UsingCoveralls#, UsingCoveralls.adoc>>##).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see [exref]##<<UsingAppVeyor#, UsingAppVeyor.adoc>>##).

[NOTE]
Having both Travis and AppVeyor ensures that your app works on both Unix-based platforms and Windows-based platforms. Travis is Unix-based and AppVeyor is Windows-based.

==== Getting Started With Coding

When you are ready to start coding, get some sense of the overall design by reading the next section on _CoinBook_'s <<Design>>.

== Design
This chapter offers a high-level overview of the components in _CoinBook_ and how they interact with one another. You should read this first to get some idea of which parts you might want to modify to suit your needs.

[[Design-Architecture]]
=== Architecture

The *_Architecture Diagram_* below (Fig. 1) explains the high-level design of the App.

.Architecture Diagram
image::Architecture.png[width="600"]

Following is a quick overview of each component:

* `*Main*` has only one class called [exref]#link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]#. It is responsible for the following:

** (On app launch) Initializes the components in the correct sequence, and connecting them up with one another
** (On shut down) Shuts down all components and invoking cleanup methods where necessary

* `*Commons*` represents a collection of classes (the [exref]#link:{repoURL}/src/main/java/seedu/address/commons[`seedu.address.commons`]# package) used by multiple other components. Two of these classes play important roles at the architectural level.

** `EventsCenter` uses [ext]#https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]#, and is used by other components to communicate with one another using events (i.e. a form of <<event-driven-design,Event Driven Design>>)
** `LogsCenter` is used by classes to write log messages to the App's log file

* The rest of the App consists of:
** <<Design-Ui,*`UI`*>> which holds the UI components of the App +
** <<Design-Logic,*`Logic`*>> which processes and executes commands +
** <<Design-Model,*`Model`*>> which holds the data of the App in memory +
** <<Design-Storage,*`Storage`*>> which reads data from and writes data to the hard disk

* Each of the above four components:

** Defines its [gloss]#<<API,_API_>># in an interface with the same name as the component
** Exposes its functionality using a `{Component Name}Manager` class

[NOTE]
For example, the `Logic` component (see Fig. 2 below) defines its API in the `Logic.java` interface and exposes its functionality via the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[width="800"]

[[event-driven-design]]
We use event-driven design in order to allow communication between separate components without increasing coupling. The short section below gives a brief introduction to how events are being used in the App.

The _Sequence Diagram_ below (Fig. 3) shows the interaction between the various components when the user issues the command `delete 1`.

.Component Interactions for `delete 1` Command Part 1
image::SDforDeleteCoin.png[width="800"]

[NOTE]
Note how `Model` simply raises `CoinBookChangedEvent` when the data is changed, instead of asking `Storage` to save the updates to the hard disk.

Fig. 4 below shows how `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

.Component Interactions for `delete 1` Command Part 2
image::SDforDeletePersonEventHandling.png[]

[NOTE]
The event is propagated through `EventsCenter` to `Storage` and `UI` without `Model` having to be [gloss]#<<coupling,coupled>># to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The following sections give more details about each component.

[[Design-Ui]]
=== UI Component

*API* : [exref]#link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]#

*Responsibilities* +
The `UI` component:

* Executes user commands using the `Logic` component
* Binds itself to data in `Model` so that the UI can update itself automatically when data in `Model` changes
* Responds to events raised from various parts of the App and updates the UI accordingly

*Internals* +
The following diagram (Fig. 5) illustrates the structure of this component:

.Structure of the UI Component
image::UiClassDiagram.png[width="800"]

The user interface (UI) consists of a `MainWindow` that is made up of several parts, e.g. `CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses the JavaFx UI framework. The layout of the UI parts are defined in matching `.fxml` files located in the `src/main/resources/view` folder. For example, the layout of the
[exref]#link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`]# is specified in
[exref]#link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]#.

[[Design-Logic]]
=== Logic Component

*API* :
[exref]#link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]#

*Responsibilities* +
The `Logic` component:

* Parses and executes user commands
* Manages command history and undo/redo information

*Internals* +
The following diagrams (Fig. 6, 7) illustrate the structure of this component:

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[width="800"]

.Structure of Commands in the Logic Component. Example of `XYZCommand` and `Command` in <<fig-LogicClassDiagram,Fig. 6>>
image::LogicCommandClassDiagram.png[width="800"]

When a user issues a command, the following steps are performed by `Logic` through `LogicManager`:

. Parse the user command using the `CoinBookParser` class.
. Run the `execute` method on the resulting `Command` object.
.  Encapsulate the result of the execution as a `CommandResult` object which is then passed back to the UI.

[NOTE]
 The command execution can affect `Model` (e.g. adding a coin) and/or raise events.

Given below is the Sequence Diagram (Fig. 8) for interactions within the `Logic` component for the `execute("delete{nbsp}1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeletePersonSdForLogic.png[width="800"]

[[Design-Model]]
=== Model Component

*API* :
[exref]#link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]#

*Responsibilities* +
The `Model` component:

* Stores a `UserPref` object that represents the user's preferences
* Stores the CoinBook data
* Exposes an unmodifiable `ObservableList<Coin>` that can be _observed_ e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list changes

[NOTE]
 `Model` does not depend on any of the other three components

*Internals* +
The following diagram (Fig. 9) illustrates the structure of this component:

.Structure of the Model Component
image::ModelClassDiagram.png[width="800"]


[[Design-Storage]]
=== Storage Component

*API* :
[exref]#link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]#

*Responsibilities* +
The `Storage` component:

* Saves `UserPref` objects in JSON format or reads it back into the App
* Saves the CoinBook data in XML format or reads it back into the App

*Internals* +
The following diagram (Fig. 10) illustrates the structure of this component:

.Structure of the Storage Component
image::StorageClassDiagram.png[width="800"]

== Implementation

This chapter describes some noteworthy details on how certain features and components have been implemented. It is highly recommended to read the previous chapter on <<Design>> first so that you have some picture of where these features fit in.
//tag::condition[]
=== Condition Parser Component

==== Current implementation
The general parser for the SQL-like arguments for the find command can be broken down into a few sub-components, namely `ArgumentTokenizer`, `SyntaxParser`, `SemanticParser`, and a `ConditionGenerator`, while using classes such as `Condition`,
`Token`, `TokenType`, `TokenStack` to model the data that is to be operated on throughout the process. Their tasks are
delegated as follows:

* `ArgumentTokenizer` : Lexically analyzes the input string, then creates a list of tokens
* `SyntaxParser` : Parses the input by matching the tokens versus a list of rules to ensure they fit the desired
structure
* `SemanticParser` : Parses the input by matching the tokens versus a list of rules to ensure their meaning is semantically valid
* `ConditionGenerator` : Uses the list of tokens to create the equivalent lambda function to evaluate `Coin` objects against.
* `Condition` : Serves as a wrapper/container for the boolean lambdas used to evaluate coins for filtering purposes.
* `Token` : Serves as a container for the sectioned input strings.

[NOTE]
The distinction between the Syntax Parser and the Semantic Parser is that the former is oblivious as to what the
input actually means, and only cares whether the structure is correct, whereas the latter verifies the meaning behind the
input. +
For example, `n/BTC AND OR p/>500` is invalid syntatically, whereas `n/BTC or p/>BTC` is valid syntatically
but not semantically, since it would not make sense to search for `Coin` objects whose price attribute was more than
"BTC" (prices cannot be compared to names).

The following sequence diagram (Fig. 11) will show how input arguments accompanying the `find` command are parsed:

.Sequence Diagram for Argument Parsing
image::FindCommandSequence.png[]

The `SyntaxParser`, `SemanticParser` and `ConditionGenerator` classes reside in a separate module that will be called by the
`ParserUtil` class during the ParseCondition method.

The following activity diagram (Fig. 12) expands on the Parse Sequence block in the previous diagram.

.Activity Diagram for Parser Operations
image::FindActivityDiagram.png[]

The `Condition` object that is generated at the end is actually just a `Predicate` object that evaluates properties of
the Coin objects and returns a true/false value.

==== Error handling
On syntactically and semantically invalid inputs, `ConditionParser` will retrieve the expected and actual type of
`Token` that were not a match during the parsing phase from `TokenStack` and raise a `ParseException` before returning.

In the event that strings intended to represent tags or numbers are not valid, an `IllegalValueException` instead,
as per convention from `ParserUtil`.

==== Design Considerations

===== Aspect: Specification of syntax

* **Alternative 1 (current choice):** Have the structure of the methods reflect exactly the syntax.
** Pros: Any subsequent changes can be easily made by having the code reflect the new syntax, since the syntax is apparent.
** Cons: It is more cumbersome to have to alter the code every time there is a change in syntax.
* **Alternative 2:** Specify the syntax in a separate file (e.g. EBNF file), and metaprogram the parser based on the file.
** Pros: This requires no code change whenever the syntax has to be modified.
** Cons: The code to support this would be more complicated and not apparent to developers immediately.

===== Aspect: Implementation of `SyntaxParser`, `SemanticParser`, `ConditionGenerator`

* **Alternative 1 (current choice):** Have separate classes that have the same structure but with different return values.
** Pros: This approach maintains SRP.
** Cons: A change in syntax will require changes across 3 classes. It is also very redundant to have similar code.
* **Alternative 2:** Have a single implementation that performs syntax parsing, semantic parsing and the condition generation.
** Pros: There will be less redundant code.
** Cons: This approach clearly violates SRP.

==== Advanced details

===== Argument Tokenizing
We will illustrate the flow of tokenizing an example input:
```
> n/BTC OR ( t/fav AND p/>100 )
```
The Lexer would tokenize this into:

```
> [n/,OPTION][BTC,STRING][OR ,BINARYOP][(,LEFTPAREN][t/,OPTION][fav,STRING][AND,BINRARYOP][p/,OPTION][>,COMPARATOR][100,NUMBER][),RIGHTPAREN]
```
Notice how the whitespace has now been discarded, since it is not used for the purposes of parsing. Also each section of
the input (i.e. token) has now been grouped with a type.

Below is a sequence diagram (Fig. 13) describing the behaviour of `ArgumentTokenizer` on the input:

.Sequence Diagram for the `ArgumentTokenizer` Class
image::Lexer.png[]

===== Syntax Parser

Next, the syntax parser has to ensure that the sequence of tokens is actually structurally valid.
This is done by matching the tokens off based on the following rules, expressed in Backus-Naur form:

. `EXPRESSION` := `TERM` | `TERM` `BINARYOP` `EXPRESSION`
. `TERM` := `LEFTPAREN` `EXPRESSION` `RIGHTPAREN` | `UNARYOP` `TERM` | `CONDITION`
. `CONDITION` := `OPTION` `COMPARATOR` `NUM` | `OPTION` `STRING`


```
> [n/,OPTION][BTC,STRING][ OR ,BINARYOP][(,LEFTPAREN][t/,OPTION][fav,STRING][AND,BINRARYOP][p/,OPTION][>,COMPARATOR][100,NUMBER][),RIGHTPAREN]
```

Using our example, we will illustrate how we can sequentially express the above tokenized argument based on the provided rules:

. `*EXPRESSION*`
. `*TERM*` `*BINARYOP*` `*EXPRESSION*`
. `*CONDITION*` `*BINARYOP*` `*EXPRESSION*`
. `*OPTION*` `*STRING*` `*BINARYOP*` `*EXPRESSION*`
. `n/` `*STRING*` `*BINARYOP*` `*EXPRESSION*`
. `n/` `BTC` `*BINARYOP*` `*EXPRESSION*`
. `n/` `BTC` `OR` `*EXPRESSION*`
. `n/` `BTC` `OR` `*TERM*`
. `n/` `BTC` `OR` `(` `*EXPRESSION*` `)`
. `n/` `BTC` `OR` `(` `*TERM*` `*BINARYOP*` `*EXPRESSION*` `)`
. `n/` `BTC` `OR` `(` `*CONDITION*` `*BINARYOP*` `*EXPRESSION*` `)`
. `n/` `BTC` `OR` `(` `*OPTION*` `*STRING*` `*BINARYOP*` `*EXPRESSION*` `)`
. `n/` `BTC` `OR` `(` `t/` `*STRING*` `*BINARYOP*` `*EXPRESSION*` `)`
. `n/` `BTC` `OR` `(` `t/` `fav` `*BINARYOP*` `*EXPRESSION*` `)`
. `n/` `BTC` `OR` `(` `t/` `fav` `AND` `*EXPRESSION*` `)`
. `n/` `BTC` `OR` `(` `t/` `fav` `AND` `*TERM*` `)`
. `n/` `BTC` `OR` `(` `t/` `fav` `AND` `*CONDITION*` `)`
. `n/` `BTC` `OR` `(` `t/` `fav` `AND` `*OPTION*` `*COMPARATOR*` `*NUM*` `)`
. `n/` `BTC` `OR` `(` `t/` `fav` `AND` `p/` `*COMPARATOR*` `*NUM*` `)`
. `n/` `BTC` `OR` `(` `t/` `fav` `AND` `p/` `>` `*NUM*` `)`
. `n/` `BTC` `OR` `(` `t/` `fav` `AND` `p/` `>` `100` `)`

The recursive methods `Expression`, `Term`, `Condition` in the syntax parser class will match their own respective tokens
as necessary. In fact the method calls in the parser are exactly the same as the matches made in the previously stated sequence.
For example, here is the implementation for `EXPRESSION`.

[source,java]
----
boolean expression() {
    if (!term()) {
        return false;
    }
    while (tokenStack.matchAndPopTokenType(TokenType.BINARYBOOL)) {
        if (!term()) {
            return false;
        }
    }
    return true;
}
----

Visually we can represent sequence of matching with the following parse tree (Fig. 14), which also serves as the recursion tree:

.Parse and Recursion Tree for the Example Input
image::parsetree.png[]

===== Semantic Parser

Following up, the Semantic Parser has to verify that the conditions are correct. This can be done by verifying the
type of the condition versus the parameters that follow. For example, a name condition should only be followed by a string.
This can be done by checking the corresponding option class versus the type of token that follows.

Thus, the checks that are made are just to ensure every string type option is followed by a string and every number type
option is followed by a number.

===== Condition Generator

Lastly, the condition generator creates lambdas based on the type of conditions found, and then recursively composes each
condition based on the binary operators encounters up the recursion tree.

The final `Condition` object is actually just a composition of many individual `Condition` objects. This can be done
as a back call at the end of each recursion tree.

For example, consider the following argument:

```
p/>100 AND t/fav
```

`p/>100` is a condition on price whereas `t/fav` is a condition on tags, and they can be composed using the `Predicate`
method `and()` to return a logical conjunction of the two conditions.
//end::condition[]
// tag::undoredo[]
=== Undo/Redo Feature
==== Current Implementation

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports the undoing and redoing of commands that modify the stored data (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. Here is the inheritance diagram for commands (Fig. 15):

.Class Diagram for Logic
image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the App data before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks, while the child classes implement the details for executing the specific command. This technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the [ext]#https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern]#.

Commands that are not undoable are implemented in this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented in this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. `UndoRedoStack` is empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th entry. The current state of the App data is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto `undoStack` (the current state is saved together with the command). Fig. 16 below illustrates this.

.Undo/Redo Stack Part 1
image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to issue more commands, they are added into `undoStack`. For example, the user may execute `add n/BTC` to add a new coin, resulting in the below picture (Fig. 17):

.Undo/Redo Stack Part 2
image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to `UndoRedoStack` at all.

The user now decides that adding the coin was a mistake, and decides to undo that action using `undo`.

The `Logic` component will pop the most recent command out of `undoStack` and push it to `redoStack`. At the same time, the data is restored to the state before the `add` command executed. The figure below (Fig. 18) illustrates the result:

.Undo/Redo Stack Part 3
image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If `undoStack` is empty, i.e., there are no other commands left to be undone, an `Exception` will be thrown when trying to pop `undoStack`.

The following sequence diagram (Fig. 19) shows how the undo operation works:

.Sequence Diagram for Undo
image::UndoRedoSequenceDiagram.png[width="800"]

The `redo` command does the exact opposite (pops from `redoStack`, pushes to `undoStack`, and restores the data to the state after the command is executed).

[NOTE]
If `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when attempting to pop `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into `undoStack`. However, now that `redoStack` is not empty, it will be purged as it no longer makes sense to redo the `add n/BTC` command (this is the behavior that most modern desktop applications follow). Refer to Fig. 20 below:

.Undo/Redo Stack Part 4
image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution (Fig. 21):

.Undo/Redo Stack Part 5
image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram (Fig. 22) summarizes the logic for `UndoRedoStack` when a user executes a new command:

.Activity Diagram for Undo/Redo
image::UndoRedoActivityDiagram.png[width="650"]

==== Design Considerations

===== Aspect: Implementation of `UndoableCommand`

* **Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()`
** Pros: No undo/redo functionality is lost as it is now part of the default behaviour. +
Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist.
** Cons: It may be harder for new developers to understand the template pattern.
* **Alternative 2:** Override `execute()`
** Pros: It is easier for new developers to understand as it does not involve the template pattern.
** Cons: Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

===== Aspect: Execution of undo & redo

* **Alternative 1 (current choice):** Save the entire state
** Pros: It is much easier to implement.
** Cons: This may bring about performance issues in terms of memory usage.
* **Alternative 2:** Make each command implement specific undo/redo operations
** Pros: This will use less memory (e.g. for `delete`, just save the coin being deleted).
** Cons: It is crucial that the implementation of each individual command is correct.


===== Aspect: Type of commands that can be undone/redone

* **Alternative 1 (current choice):** Include only commands that modify the App data (e.g. `add`, `clear`, `edit`)
** Pros: Only changes that are hard to do manually can be reverted like this. +
e.g. The view can easily be re-modified as no data is lost, so not undoable with `undo`.
** Cons: The user might think that undo also applies when the list is modified (filtering for example), only to realize otherwise after executing `undo`.
* **Alternative 2:** Include all commands
** Pros: This might be more intuitive for the user.
** Cons: The user has no way of skipping such commands if he or she just wants to reset changes made to the data and not the view. +
**Additional Info:** See the discussion  [ext]#https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here]#.


===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use separate stack for undo and redo
** Pros: This implementation will be easier to understand for new Computer Science undergraduates, who represent the majority of incoming developers to the project.
** Cons: It introduces duplicated logic. Whenever a new command is executed, both `HistoryManager` and `UndoRedoStack` must be updated separately.
* **Alternative 2:** Use `HistoryManager` for both undo/redo
** Pros: There will be no need to maintain a separate stack, by just reusing what is already in the codebase.
** Cons: We must remember to skip already undone commands. +
This approach also violates the Single Responsibility Principle and the Separation of Concerns Principle as `HistoryManager` now needs to do two different things.
// end::undoredo[]

// tag::notifications[]
=== User-Set Notifications

==== Current Implementation

The notification system is facilitated by a `RuleBook`, which is located with the `Model` component as part of the App data. `RuleBook` holds a set of rules which define, in this case, conditions to trigger notifications on. A `RuleChecker` in `Logic` also does the work of checking rules and executing the associated actions.

Let us walk through the implementation of notifications by considering a typical scenario involving this feature. Suppose the user wants to keep track of a certain coin's price, say `BTC`.

The user adds a new notification using `NotifyCommand`, e.g. `notify c/BTC p/>15000`, which sets a new notification to be triggered for when the price of `BTC` crosses $15000. The corresponding rule is added to the `RuleBook`.

Later on, the user may add other notifications. So now, there are a list of different rules stored in _CoinBook_. When the price data is synced with latest data from the web, whether from the regular update or triggered by the user with the `sync` command, a `CoinChangedEvent` is sent out for each updated coin.

`RuleChecker` catches these events, and checks against the `RuleBook`. If any match, the corresponding action is executed. Here, a notification pops up to alert the user.

The diagram below (Fig. 23a,23b) summarises these interactions:

image::NotificationsSequenceDiagram1.png[width="800"]
.Sequence Diagram for Notifications
image::NotificationsSequenceDiagram2.png[width="800"]

==== Design Considerations

===== Aspect: Implementation of rules

* **Alternative 1 (current choice):** Make them generalized trigger-action pairs
** Pros: Later extension is easy to make by simply defining new condition and command parsers along with associated input.
** Cons: This design pattern (Strategy pattern) is more advanced and may be hard for new developers to understand. Code readability may also suffer.

* **Alternative 2:** Make only a single `NotificationRule` type
** Pros: This is quicker to implement as the behavious is hard-coded.
** Cons: It will be more difficult to extend rules to handle other events in the future.

[TIP]
`RuleBook` is actually made general-purpose in the sense that it can hold other types of rules for future extensions, e.g. Automated Task Rules, etc.

===== Aspect: Type of notification to use

* **Alternative 1:** Use platform-side notifications, e.g. system tray
** Pros: The user can integrate these into their own workflow, such as setting other programs to listen in on system notifications and forward them to their other device, generate emails, take actions, etc. The user has some control over how notifications look and behave.
** Cons: They may not work on every platform; they are heavily dependent on implementation of Java features. For example, some distributions of Linux may not include system trays.

* **Alternative 2 (current choice):** Use application-side notifications.
** Pros: This will only require the same framework which displays the App window itself, so is guaranteed to work alongside the App.
** Cons: There will be less flexibility in customisation and availability of integration into user's preferred workflow.

===== Aspect: Undo-ability of `NotifyCommand`

* **Alternative 1 (current choice):** Leave it non-undoable
** Pros: Notification rule data can be kept separate from coin data. +
The basic functionality of `RuleBook` is implemented inside `Model` which deals with data, but the rules are instantiated only in the `Notifications` component itself. A rule manager window will be available for editing or deleting existing notifications.
** Cons: The UI will be less intuitive as users have to manage coins and rules in slightly different manners.

* **Alternative 2:** Make it an `UndoableCommand` just like `add`, `edit`, etc.
** Pros: This offers an intuitive, single interface for similar operations.
** Cons: This would increase the coupling between the coin data and the rule data parts of `Model`, since the current implementation of `UndoableCommand` requires saving the state of `Model`, which is a wrapper for just the coin data. +
We want to keep `Model` as an interface for just the coin data itself.

// end::notifications[]

// tag::organisation[]

[[Implementation-Organisation]]
=== Organisation Features

==== Sorting

The sorting mechanism is facilitated by `Collections.sort`. It supports sorting the coin list passed into the sort method to arrange the coins in a manner that the user chooses.

The way `Collections.sort` works is that it takes the collection's underlying array and calls its sort method to sort the actual elements. The sorting algorithm used by Java is Timsort.

This sorts the collection in-place, i.e., it modifies the given collection by sorting its elements directly. As a result, a sorted copy need not be made, saving resources.

Following are some example sort procedures:

* Sort by coin value

** We can use `Comparator.comparingDouble()` for comparing double values. For _CoinBook_, we want to order our list of coins by value, from the highest to the lowest.
** We can use the `reversed` function on `Comparator` to invert the default and arrange coins from lowest to highest instead.
** `Double` is used because coin values have several decimal places and so the `comparingInt()` function would not suffice.

* Sort by string field (e.g. coin code)

** If we want to sort our `CoinList` by coin code, we can use `Comparator.comparing()` and pass a function that extracts the 3 letter coin code.
** We do not have to pass in any comparator for the list to be correctly sorted because the 3-letter coin code is a `String` which implements the `Comparable` _interface_, and hence guarantees its own implementation of the sort comparator.

==== Grouping

The group feature can use the `Collectors` class, which provides methods for grouping data stored in collections. Grouping would permit the user to organise coin data based on a common field, e.g coins prices equal to or over 1000 dollars per coin.

The `GroupingBy` method from the `Collectors` class is responsible for organising the coin data into groups. In this case the group is defined by the value of the coin. The `Collect` method from the `Stream` class accepts the `GroupingBy` method as its argument and returns a map containing the results. The results are then displayed.

Using the `GroupingBy` collector from the `Collector` class, it takes a single parameter (or classifier) that assigns a grouping key to every stream element.

By default, elements with the same key are inserted into a `List<T>`, although this can be changed by specifying a second parameter to `GroupingBy`.

==== Design Considerations

===== Aspect: Implementation of Sort function

* **Alternative 1 (current choice):** Use `Collections.sort`

** Pros: There is no need to pass any comparator for the coin list since `String` already implements the `Comparable` interface.
** Cons: The developer needs to understand the relationship between array lists and collections.

* **Alternative 2:** Add a new sorting function (e.g. Selection Sort)

** Pros: This possibly allows us to reduce the time required to execute the sorting command.
** Cons: This takes more time to incorporate into the App since we are not using Javaâ€™s in-built sorting method.

===== Aspect: Implementation of Groups function

* **Alternative 1 (current choice):** Use `GroupingBy` method

** Pros: The user has an additional option where he can view coins based on a specified attribute.
** Cons: The developer needs to understand the relationship between `Stream`, `ArrayList` and `Collector` classes.

* **Alternative 2:** Add additional tags in lieu of grouping

** Pros: The codebase already has support for tags and so not a lot of changes will be required.
** Cons: Commands will not be executable at a group level because tags merely depict the attribute of the coins, but groups act as a tool to manage several coins at the same time.

// end::organisation[]

// tag::autocomplete[]
=== Autocomplete Feature

The autocomplete mechanism is facilitated by a `RadixTree`, which resides inside `LogicManager`. It supports the predicting of a word or phrase that the user may type based on a partial text query.

Suppose the user has 3 coins added to his account currently, namely `BTC`, `ETH`, `BCG` and `BCH` in that order.

Say the user is trying to use the `find` command to look up `BCH`.

The user will first type `find` into the command line followed by a whitespace and `B`.
```
find c/B
```

Now, when the user presses kbd:[Tab], the autocomplete feature will then complete the query by suggesting the first matching item it finds.
```
find c/BTC
```

When the user then presses kbd:[C] to complete his query, the autocomplete feature will suggest the next matching item of the input `BC` so far.
```
find c/BCG
```

The user can then press kbd:[Tab] again to cycle through the other items that match the current input `BC`.
```
find c/BCH
```

At this point the user has found `BCH`, which is the coin that the user wanted to look up. The user can now press kbd:[Enter] to execute his command.

==== Design Considerations

===== Aspect: The fields which autocomplete works on

* **Alternative 1 (current choice):** Apply only for command parameters.
** Pros: This reduces the implementation cost.
** Cons: The reduced functionality may not satisfy every user.
* **Alternative 2:** Apply for both command word and command parameters.
** Pros: User experience will be slightly improved over the alternative.
** Cons: This has a lower value to effort ratio to implement given that aliases are already implemented.

===== Aspect: Data structure to support the autocomplete feature

* **Alternative 1 (current choice):** Use a Radix Tree
** Pros: This is easier to understand for new Computer Science undergraduates, who represent the majority of incoming developers to the project.
** Cons: The implementation could be non-trivial.
* **Alternative 2:** Use a linear data structure
** Pros: This is much easier to implement.
** Cons: The solution will be inefficient, with a higher time complexity incurred.

// end::autocomplete[]

=== Logging

We are using the `java.util.logging` package for logging. The `LogsCenter` class is used to manage _logging levels_ and logging destinations.

Log messages are categorized into four logging levels of varying importance:

* `SEVERE` : Indicates critical problems which may possibly cause the termination of the App
* `WARNING` : Indicates the App can continue running, but the user should take caution
* `INFO` : Indicates information regarding noteworthy actions by the App
* `FINE` : Indicates details that are not usually noteworthy but may be useful in debugging e.g. printing the list contents instead of just its size

The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>).

The `Logger` for a class `Class` can be obtained using `LogsCenter.getLogger(Class)`, which will log messages according to the specified logging level. Currently, log messages are output through `Console` as well as written to a `.log` file.

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file. By default, this is `config.json`.

== Documentation

We use AsciiDoc for writing documentation.

[NOTE]
We chose AsciiDoc over Markdown because AsciiDoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See [exref]##<<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>>## to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See [exref]##<<UsingTravis#deploying-github-pages, UsingTravis.adoc>>## to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF Format

We use [ext]#https://www.google.com/chrome/browser/desktop/[Google Chrome]# for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in [exref]##<<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>>## to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Find the generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  In Chrome's menu, click on the `Print` option.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot (Fig. 24) below.

.Options for Saving Documentation as PDF Files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Testing]]
== Testing

When developing new features it is always important to write tests so that you can verify whether the features are working as intended, alone or with one another. This chapter introduces the basics of testing.

=== Types of Tests

We use two types of tests in _Coinbook_:

*Type 1: GUI Tests* - These are tests involving the GUI. They include:

.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in the `seedu.address.ui` package.

*Type 2: Non-GUI Tests* - These are tests not involving the GUI. They include:

..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that check the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These tests check multiple code units as well as the connections between them. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Running Tests

There are three ways to run tests on your computer before sharing your changes to source control.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, right-click on a test package, test class, or a test, e.g. `ABC`, and choose `Run 'ABC'` (see Fig. 25)

.Running Tests
image::RunningTests.png[]

*Method 2: Using Gradle*

Open a console and run the following command:

Windows
```
> gradlew clean allTests
```
Mac/Linux
```
$ ./gradlew clean allTests
```

[NOTE]
See [exref]##<<UsingGradle#, UsingGradle.adoc>>## for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the [ext]#https://github.com/TestFX/TestFX[TestFX]# library we use, our GUI tests can be run in _headless_ mode. In headless mode, GUI tests do not show up on the screen. This means the developer can do other things on their computer while the tests are running.

To run tests in headless mode, open a console and run the following command:

Windows
```
> gradlew clean headless allTests
```
Mac/Linux
```
$ ./gradlew clean headless allTests
```

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might cause some GUI tests to fail due to platform/resolution-specific idiosyncrasies.

[NOTE]
<<Continuous Integration>> also automatically runs the tests specified with Gradle, but it is a good habit to test things on your own machine first.

=== Troubleshooting Testing

Here are some common problems you may face when trying to run tests locally.

**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== DevOps

This chapter introduces various systems we can put in place to unify the tasks of _development_ and _operations_, or _DevOps_ in short. We are mostly concerned with ways to reduce turnaround time through simple automation, and ways to manage the distribution of the completed App.

=== Build Automation

See [exref]##<<UsingGradle#, UsingGradle.adoc>>## to learn how to use Gradle for build automation.

=== Continuous Integration

We use [ext]#https://travis-ci.org/[Travis CI]# and [ext]#https://www.appveyor.com/[AppVeyor]# to perform _Continuous Integration_ on our projects. See [exref]##<<UsingTravis#, UsingTravis.adoc>>## and [exref]##<<UsingAppVeyor#, UsingAppVeyor.adoc>>## for more details.

=== Coverage Reporting

We use [ext]#https://coveralls.io/[Coveralls]# to track the code coverage of our projects. See [exref]##<<UsingCoveralls#, UsingCoveralls.adoc>>## for more details.

=== Documentation Previews
When a pull request contains changes to AsciiDoc files, you can use [ext]#https://www.netlify.com/[Netlify]# to see a preview of the HTML version of those AsciiDoc files when the pull request is merged. See [exref]##<<UsingNetlify#, UsingNetlify.adoc>>## for more details.

=== Release Procedure

Here are the steps to creating a new release.

.  Update the version number in
[exref]#link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`]#.
.  Generate a JAR file [exref]##<<UsingGradle#creating-the-jar-file, using Gradle>>##.
.  Tag the repo with the version number, e.g. `v0.1`.
.  [ext]#https://help.github.com/articles/creating-releases/[Create a new release using GitHub]# and upload the JAR file you created in step 2.

=== Dependency Management

A project often depends on third-party libraries. For example, _CoinBook_ depends on the [ext]#http://wiki.fasterxml.com/JacksonHome[Jackson library]# for XML parsing. Gradle can manage these _dependencies_ for you by downloading the them automatically, instead of having to: +

* Include those libraries in the repo (this bloats the repo size), or +
* Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Product Scope
=== Goals

*Target user profile*:

* has a need to manage a significant number of cryptocurrencies
* prefers desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps
* requires various analysis and visualisation tools for decision-making

*Value proposition*: manage cryptocurrencies faster than a typical mouse/GUI driven app

=== Feature contribution
*Eldon Chung*

* Major: Search enhancement. Support for SQL-like queries with logical operators as well as additional search specifiers besides name, such as tags and price. This lets users manage their large portfolio easily through efficient filtering.
* Minor: Fetch news. Fetches news related to cryptocurrencies from sources such as RSS feeds. This lets users keep track of latest developments in the scene to aid their decision making.

*Ewald Hew*

* Major: Sync and notifications. Updates price data periodically and make notifications based on user-set rules. This helps users stay on top of what's happening and obtain important information at the right time.
* Minor: Charts panel for data visualization. This lets users analyse price trends for decision making.

*Lai Cheng Yu*

* Major: User experience. Create smoother workflow via GUI hints, view modes, command autocompletion, and data visualization. This helps users manage their portfolio quickly and efficiently, and lets them focus on the more important tasks.
* Minor: Data fetching system. Updates the price data, etc., in the model from a source. This lets users keep up to date on latest developments.

*Neil Mehta*

* Major: Organization options. Sorting options and groups. This lets users switch between different contexts to fit in with their objectives at the moment, and helps them focus on only what is relevant.

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="80%",cols="20%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |figure out how to use the application.
|`* * *` |user |see my personal portfolio |track gains/losses.
|`* * *` |user |add new coin accounts |
|`* * *` |user |delete coin accounts | remove unwanted information.
|`* * *` |user |have a tagging system |simplify and categorize my accounts.
|`* * *` |user actively trading |be able to store up to 2000 cryptocurrencies |maintain my extensive portfolio.
|`* * *` |user |have a search and find feature |avoid going through all coins manually.
|`* * *` |user who values privacy |use a program without making accounts |keep it simple.
|`* * *` |user who values privacy |store my data only on local storage |avoid having my data on potentially insecure servers.
|`* * *` |user |avoid lots of manual entry |save time.
|`* *` |user |not to have to exit the current search results before entering a new command |operate on my search results efficiently.
|`* *` |user |have a sorting feature for names, coin prices, account values, etc. |quickly rank my choices.
|`* *` |user |have a bookmarks or favourites watchlist |prioritise certain coins.
|`* *` |user |be able to import/export my data |transfer it to other computers.
|`*` |user |have different color themes | customise my program.
|`*` |user |have multilingual support |understand the program better.
|`*` |user |have a fixed interval backups, that can also be manually set |ensure my data will not be lost.
|`*` |user |macro and write custom aliasing for commands |customize my experience.
|`*` |user |track price, market cap, and circulating supply from coinmarket |get all my information in one place.
|`*`  |user |see <<RSI,RSI>> or <<MACD,MACD>> graphs |analyse price trends for decision-making.
|`*` |user |see Overbought/Oversold lines | do as above.
|`*` |user |be able to set support and resistance lines | do as above.
|`*` |user |have candlestick graphs with simple/exponential moving average overlay | do as above.
|`*` |user |be able to search information on a specific coin |get all my information in one place.
|`*` |user |have desktop notifications |be informed when something needs my attention.
|`*` |user |have a daily/hourly report |keep track of the current state of my accounts.
|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is `CoinBook` and the *Actor* is the `User`, unless specified otherwise)

=== Use case: Delete coin listings

*MSS*

1. User requests to delete a coin listing
2. CoinBook deletes the specified coin
+
Use case ends.

*Extensions*

[none]
* 2a. The specified coin does not exist in the storage.
+
[none]
** 2a1. CoinBook shows an error message.
+
Use case resumes at step 1.

=== Use case: Export storage data

*MSS*

1.  User requests to export storage data.
2.  CoinBook requests for the file destination.
3.  User specifies the file destination.
4.  CoinBook exports the file.
+
Use case ends.

*Extensions*

[none]
* 2a. The storage is empty.
+
Use case ends.

* 3a. The given file destination is invalid.
+
[none]
** 3a1. CoinBook shows an error message.
+
Use case resumes at step 2.

=== Use case: Set notifications

*MSS*

1. User sets the condition under which he/she wishes to be notified.
2. CoinBook notifies the user the condition has been acknowledged.
+
Use case ends.

*Extensions*

[none]
* 2a. The condition argument was invalid.
[none]
** 2a1. CoinBook shows an error message.
+
Use case ends.

=== Use case: Tag items for group commands

*MSS*

1. User finds the coins that he wishes to group using the `Find` command.
2. CoinBook shows a list of coins.
3. User tags all the found using the `TagAll` command.
4. CoinBook updates the tags on the coins and the list view.
5. User then operates on all coins that were tagged. e.g. `buy tag 50`
6. CoinBook shows the result to the User.

*Extensions*

[none]
* 2a. The tag name was invalid.
[none]
** 2a1. CoinBook shows an error message.
+
Use case ends.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 2000 Coin accounts without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Should be accurate in the representation of Coin amounts, free of numerical errors.
.  All sensitive data should be stored locally.
.  Should only make configuration files in the local directory to remain fully portable.
.  Should not take more than one minute to generate summary reports.
.  Should update news and charts automatically at the user-specified frequency, with tolerance of 1% (e.g. +/-18s for 30min interval)

[appendix]
== Glossary

[[API]] API::
Short for Application-Programmer Interface.

[[alias]] Alias::
Alternative forms of commands that are usually shorter for typing efficiency.

[[coinmarketcap]] Coinmarketcap::
A website that hosts <<cryptocurrency,cryptocurrency>> information, including cap rankings, prices, volumes and circulating supplies.

[[coin]] Coin::
See <<cryptocurrency, Cryptocurrency>>.

[[coupling]] Coupling::
Two classes are coupled if a change in the implementation of one may necessitate a change in the other.

[[cryptocurrency]] Cryptocurrency::
Digital currency. Examples are: Bitcoin, Dogecoin, Etherium.

[[exponential-moving-average]] Exponential moving average::
A moving average window of closing prices over a past period that places more weight on the more recent days considered. Since cryptocurrencies do not have a closing price, this defaults to their price at 23:59:59 at the timezone of the exchange.

[[MACD]] Moving Average Convergence Divergence (MACD)::
Moving Average Convergence Divergence is an indicator that is the difference between two moving averages.

[[macros]] Macros::
A set of commands that can be executed under a single custom command is a macro. For example, if a user wishes to only view coins of a specific tag in a certain sorted order, he can set create a custom macro (e.g. `sortfavourites`) such that upon entering it at a command, the program will internally first call the `search` command on the user set tags, then call the `sort` command.

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[resistance-lines]] Resistance Lines::
When the price of a coin has risen to a certain amount, the price may eventually sustain its value at this point for a period of time. This is when it obtains "resistance".

[[RSI]] Relative Strength Index::
Relative Strength Index is used as an indicator to compare the current strength of cryptocurrency versus its historical strength. The strength is calculated based on the closing prices over a period of time.

[[sensitive-data]] Sensitive Data::
Refers to data that is not meant to be shared with others.

[[simple-moving-average]] Simple Moving Average::
A moving average window of closing prices over a past period that places equal weight on all days considered. Since cryptocurrencies do not have a closing price, this defaults to their price at 23:59:59 at the timezone of the exchange.

[[support-lines]] Support lines::
When the price of a coin has fallen to a certain amount, the price may eventually sustain its value at this point for a period of time. This is when it obtains "support".

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the App manually. This is a way to supplement the automated testing and find bugs through some concerted effort to break the software.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launching and Shutting Down

. Initial launch

.. Download the jar file and copy into an empty folder.
.. Double-click the jar file. +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

=== Deleting a coin

. Deleting a coin while all coins are listed

.. Prerequisites: List all coins using the `list` command. Multiple coins in the list.
.. Test case: `delete 1` +
   Expected: First coin is deleted from the list. Details of the deleted entry shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No coin is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect commands to try: `delete`, `delete x` (where x is larger than the list size), `delete -1` +
   Expected: Similar to previous.

. Deleting a coin while its details are being displayed

.. Prerequisites: List coins as above. Select the second coin using the `view 2` command. The detail window should be open on the right side.
.. Test case: `delete 2` +
   Expected: The coin is removed from the list. The detail window should return to a blank one, as when no coin is selected.

=== Saving data

. Dealing with missing/corrupted data files

.. Start the App so that it is ready to run some commands.
.. Navigate to the location of the data file, `data/coinbook.xml`, and rename or delete it. +
Expected: The coin list in App memory remains the same, and a new data file is created upon the next command that modifies it.

. Transferring data files to another computer

.. Download _CoinBook_ to the new computer.
.. Copy the `data/` folder in the old installation to the new installation folder.
.. Launch the App as in F.1.1. +
Expected: All data from the old installation should be preserved and appear in the listing when the App is launched.
