= EduBuddy - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/se-edu/addressbook-level4/tree/master

By: `CS2103JAN2018-T09-B1`      Since: `Mar 2018`      Licence: `MIT`

== Introduction
Welcome to _EduBuddy_! This application is based on a Command Line Interface(CLI),
and is designed for secondary school teachers to manage student profiles in
a simple and efficient manner.

This developer guide will help to provide you with a detailed walk-through of _EduBuddy_,
from the application set up procedure, to the explanation of the features and
troubleshooting methods.

== Setting up
This section helps to guide you through the necessary steps to launch our application.

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands
. <<Testing,Run the tests>> to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `se-edu/addressbook-level4` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `se-edu/addressbook-level4`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see <<UsingCoveralls#, UsingCoveralls.adoc>>).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading <<Design-Architecture>>.
2. Read up on the individual design parts from Model, Storage, UI and Logic.

*_return to <<toc,Table of Contents>>_*

== Design
This section illustrates the overall design of our application and provides
the details of its individual components.

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::Architecture.png[width="600"]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[width="800"]

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command (part 1)
image::SDforDeletePerson.png[width="800"]

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

.Component interactions for `delete 1` command (part 2)
image::SDforDeletePersonEventHandling.png[width="800"]

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The UI Browser window uses HTML's w3.css framework. The layout of the Browser Panel is defined from `src/main/resources/StudentPage/template.html`.

The UI Browser window then reflects the user profile's respective HTML file when a user is selected, found in {user.home}/StudentPage.

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[width="800"]

.Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in <<fig-LogicClassDiagram>>
image::LogicCommandClassDiagram.png[width="800"]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeletePersonSdForLogic.png[width="800"]

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

*_return to <<toc,Table of Contents>>_*

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo feature
==== Current Implementation

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new person.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="650"]

==== Design Considerations

===== Aspect: Implementation of `UndoableCommand`

* **Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()`
** Pros: We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist.
** Cons: Hard for new developers to understand the template pattern.
* **Alternative 2:** Just override `execute()`
** Pros: Does not involve the template pattern, easier for new developers to understand.
** Cons: Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.


===== Aspect: Type of commands that can be undone/redone

* **Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`).
** Pros: We only revert changes that are hard to change back (the view can easily be re-modified as no data are * lost).
** Cons: User might think that undo also applies when the list is modified (undoing filtering for example), * only to realize that it does not do that, after executing `undo`.
* **Alternative 2:** Include all commands.
** Pros: Might be more intuitive for the user.
** Cons: User have no way of skipping such commands if he or she just want to reset the state of the address * book and not the view.
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].


===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use separate stack for undo and redo
** Pros: Easy to understand for new Computer Science student undergraduates to understand, who are likely to be * the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update * both `HistoryManager` and `UndoRedoStack`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate stack, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two * different things.
// end::undoredo[]

*_return to <<toc,Table of Contents>>_*

// tag::Sorting[]
=== Sort feature

==== Current Implementation

The sorting feature allows the user to sort the list of students according to certain
parameters like name and tag. After the sorting process has completed, the user will be
presented with a read only view of the sorted list on the `UI`, and the state of the
list will not be modified.

The figure below shows the Sequence Diagram for the interactions within the `Logic`
component when "sort name" is typed into the `CommandBox` by the user.

image::SortCommandSequenceDiagram.png[width="650"]

. `Logic` uses `AddressBookParser` class to parse the user command,
. A `SortCommand` object is created which is then executed by the `LogicManager`.
. The command executes and calls the `sortPersonList(parameter)` method, which then affects
  the `Model`.
. After the sorting process has been completed, the result is encapsulated as a
  `CommandResult` object, which is then passed back to the `Ui` as a message shown
  to the user.

Below is an example of how the list looks like before and after the command "sort name"
is executed.

image::SortCommandByName.png[width="650"]

==== Design Considerations

===== Aspect: How the list appears after sorting is done and the app is restarted
* ** Alternative 1 (current choice): ** List remains in its initial state after each
                                        restart of the app
** Pros: Some users might prefer the default list that was created by themselves e.g. the need
         to track which student was added last.
** Cons: It will be a hassle to sort the list every time the app starts up if there
         are not many changes to the list.
* ** Alternative 2: ** List is in the sorted form after the app is restarted every time
** Pros: Reduces the time taken to sort the list for each start up of the app.
** Cons: If the default list is required, `SortCommand` will have to be implemented
         as an `UndoableCommand` as well.
// end::Sorting[]

*_return to <<toc,Table of Contents>>_*

// tag::TagReplace[]
=== TagReplace feature

==== Current Implementation
The tag replace is a command that replaces the target tag with the tag that we want.
The tags would be passed in via the argument multimap which would extract the tags with t/ prefix.
It would then be separated into two different tags, tag to be replaced and the tag to be placed.
Then the Addressbook would proceed to look for the persons with the unwanted tag to remove the unwanted
tag and to add the new tag to the person.

The figure below shows the Sequence Diagram for the interactions within the `Logic`
component when "tagreplace t/TAGNAME t/TAGNAME" is typed into the `CommandBox` by the user.

image::TagReplaceCommandSequenceDiagram.png[width="650"]

.  `Logic` uses the `AddressBookParser` class to parse the  command.
.  This results in a `TagReplaceCommand` object which is executed by the `LogicManager`.
.  The command execution calls the `replaceTag` method which then affects the `Model`.
.  The tag is then replaced and the result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Below is an example of how the list looks like before and after the command "tagreplace t/3G t/4G"
is executed.

image::TagReplaceCommand.png[width="650"]

==== Design Considerations.
===== Aspect: Data structure to support the tag replace command
* ** Alternative 1: ** Reuse the set that exist in the Addressbook.
** Pros: Need not introduce a new data structure to store the tags that are passed in.
** Cons: A set arranges its elements in alphabetical order. This disrupts the order in which the user has entered,
         and it would cause the wanted tag to be removed instead of the unwanted one.

// end::TagReplace[]

*_return to <<toc,Table of Contents>>_*

// tag::subject[]
=== Subject streaming calculation feature
==== Current Implementation
The subject streaming calculation features will be supported by calculation algorithms, `calculateL1R5`, `calculateL1B4A`, `calculateL1B4B, `calculateL1B4C` and `calculateL1B4D, which will be located in `Person.java`. The calculation algorithm will be called by the `SelectCommand`.
It will help to analyse the subjects that are assigned to the student, and determine which combination of subjects will produce the lowest `L1R5`, `L1B4A`, `L1B4B`, `L1B4C` or `L1B4D` score respectively. The score will then be projected in the `Command Box`.

.Sequence Diagram of implementation of Subject streaming calculation
image::StreamCommand.png[width="700"]

** In `StreamCommandParser`
. The user will key in the necessary command, `stream INDEX STREAM_TYPE` to call the `StreamCommand`.
. The Logic uses the AddressBookParser to parse the command to `StreamCommandParser`.
. The `StreamCommandParser` will take in the values and return a new `StreamCommand` object, with the parameters, `index` and `type`.
** In `StreamCommand`
. When the `StreamCommand` is executing, it retrieves the `Person` object that the user was referencing to using the `index` parameter
 and pass in the `Person` object and `type` parameter into a `scoreCalculation()` method.
. In the `scoreCalculation` method, the method will determine what type of streaming score the user wants to get using the `type` paramter.
. Then the necessary calculation algorithm in the `Person.java` will be called.
** In `Person.java`
. In the calculation algorithm, it will store the subject list of the student in `List<Subject> subjects` and loop through the list according to the `L1` subject category.
. The relevant subjects of the subject category will be saved in a temporary `List<Subject> subjectsToCheck` and the list will be passed into a `checkLowest()` method.
. In `checkLowest()`, the subject grades will be compared and the best subject will be removed from the list `subjects`.
. The best grade will be returned back to `calculateL1R5/L1B4` and stored in a temporary `int` variable, `score`. The function will then move on to check the other subject categories.
. After the calculation, `score` will be returned to the `SelectCommand` which will project the result in the `Command Box`.

[NOTE]
The subjects and their respective grades can be assigned to the students by the `AddCommand`, `EditCommand` or `AddSubjectCommand`, with a subject prefix `sub/` followed by the `Subject Name` and `Subject Grade`.
As the students are required to take at least 6 subjects, the subjects will be stored in as a parameter of each individual student as a `List<Subject>`.

===== Aspect: Implementation of command to call `calculateL1R5` and `calculateL1B4`

* **Alternative 1 (current choice):** Add new command class `StreamCommand`
** Pros: It would be easy to implement as there is no need to worry about affecting other classes.
** Cons: More commands for the user to remember.
* **Alternative 2 :** Just override `execute()` of `SelectCommand`
** Pros: Easier to update the `Display Panel` later on when the user wants to access the `Student's` details.
** Cons: Need to update the test cases accordingly due to the change in the `execute()` function.

===== Aspect: Implementation of calculation function `L1R5` and `L1B4`

* **Alternative 1 (current choice):** Add the calculation function in `Person.java`
** Pros: Easier to understand as the function needs to access the subject list of the student for calculation.
** Cons:
* **Alternative 2 :** Implement the calculation function in `execute()` of `SelectCommand`
** Pros: Reduce the amount of coupling between `SelectCommand` and `Model`.
** Cons: Makes the `SelectCommand` more complicated as it is performing more than it should.
// end::subject[]

*_return to <<toc,Table of Contents>>_*

// tag::masstagremoval[]
=== Mass Tag Removal feature
==== Current Implementation

The Mass Tag Removal feature is supported through the suggested Tag Removal feature in the Model Component.
The command `TagDeleteCommand` is implemented to call the `deleteTag()` function in the `Model` interface.
The `deleteTag()` function will loop through the students in the `AddressBook` and will remove the specified Tag from every student that has the specified Tag and the students' `Tag List` will be updated.

A `TagDeleteCommand` is where the user inputs `tagdelete [TAG_NAME]` or `td [TAG_NAME]` in the `Command Box`. When the user input fulfils the criteria of the expected input format, the command will execute.
The `deleteTag()` function will be called and loops through the students in the `AddressBook`.

* If the specified tag is not found tagged to any student, a `TagNotFoundException` will be thrown and a error message will be returned to the user.
* Else, the `Tag List` of each student will be loaded and stored in a temporary `List` variable and the specified tag will be removed from it.
Then a new student object with the updated `Tag List` will be replace the original student object. Thus the `AddressBook` will eventually have the updated list of students where the specified tag have been removed.

** `Parser`
. Logic uses the AddressBookParser class to parse the command into `TagDeleteCommandParser`.
. The parser will then return a new TagDeleteCommand object with the parameter `tagName` which is executed by the LogicManager.
. The command execution calls the deleteTag method which then cycle through the list of students in the _EduBuddy_ and removes the tags containing the `tagName` from the students.
. The tag is then deleted and the result of the command execution will be returned as a CommandResult object which is passed back to the Ui.
. The user will see a message on the `Command Box` in the format: `Deleted Tag: [TAG_NAME]` and the `Tag` will be removed.

.Sequence Diagram of TagDeleteCommand if the specified tag exists.
image::TagDeleteCommandSequenceDiagram.png[width="800"]

==== Design Considerations

===== Aspect: Implementation of `TagDeleteCommand`

* **Alternative 1:** Create a new method in `TagDeleteCommand` to delete tag
** Pros: Easier to understand the structure of `TagDeleteCommand`.
** Cons: The `deleteTag()` function that was implemented would be redundant.
* **Alternative 2 (current choice):** Call the `deleteTag()` function
** Pros: Implementation of the command would be easier as the main algorithm to delete the tag is within the code.
** Cons: Increases coupling between `Model` and `TagDeleteCommand`.

// end::masstagremoval[]

*_return to <<toc,Table of Contents>>_*

// tag::addsubjects[]
=== AddSubjectCommand feature
==== Current Implementation

The AddSubjectCommand feature is located in the `Logic` component.
The `AddSubjectCommand` can be used when the user inputs `addsub INDEX sub/[SUBJECT_NAME SUBJECT_GRADE...]` in the `Command Box`. When the user input fulfils the criteria of the expected input format, the command will execute.
The command will then find the student located at the specified `INDEX` and creates a new student with the previous details of the selected student.
The new student will have the updated `Set<Subject>` and will replace the selected student in the _EduBuddy_.

* If the student already possess the subject that was keyed in, the subject will not be added to the subject list of the student. This is to prevent the student having duplicate subjects assigned to him/her.
* If the user typed in duplicate subjects in the input, for example: `addsub 1 sub/English A1 English A1`, an `IllegalValueException` will be thrown and an error message, "There should not be duplicate subject(s) assigned to student."

** `Parser`
. Logic uses the `AddressBookParser` class to parse the command into `AddSubjectCommandParser`.
. The parser will first parse the `INDEX` and `subjects` using the `parseIndex` and `parseSubjects` in the `ParserUtil` class, to check if they are valid inputs.
. The parser will then creates a new `AddSubjectCommand` object with the attributes `index` and `editPersonDescriptor`, which is executed by the LogicManager.
** In `AddSubjectCommand`
. The command execution of `AddSubjectCommand` will create a new student object using a `createEditedPerson()` method, which will call `checkIfSubjectExists()` method.
. The method will check if the subjects to be added exist in the original list of subjects assigned to the student. A boolean variable `isPresent` will keep be used to indicate if the subjects exist.
. If `isPresent` is false, the subjects will be added to a new `Set<Subject>` object which contains the both the new and old subjects of the student.
. A new student containing the previous details and the updated subject list will be created and replace the selected student in the _EduBuddy_.
. The result of the command execution will be returned as a CommandResult object which is passed back to the Ui.
. The user will see a message on the `Command Box` in the format: `Edited Person: [NAME]. Updated Subjects: [SUBJECT_NAME SUBJECT_GRADE]...` will be removed.

.Sequence Diagram of AddSubjectCommand
image::AddSubjectCommandActivityDiagram.png[width="800"]

==== Design Considerations

===== Aspect: Implementation of `AddSubjectCommand`

* **Alternative 1:** The user continues to use the `AddCommand` to add all the subjects at one time or use `EditCommand` to change the subjects details.
** Pros: More intuitive for the user as the commands do what the user expects from their names.
** Cons: The user have to key in a long command line as each student has to be assigned to at least 6 subjects.
* **Alternative 2 (current choice):** Create a new `AddSubjectCommand`
** Pros: The user just needs to type in the subjects that he/she did not add earlier.
** Cons: More commands for the user to remember.

===== Aspect: The number of people that the user can add subjects to using the command

* **Alternative 1:** The command can be implemented as a mass adding command, where the subjects keyed in can be added to all the students in _EduBuddy_.
** Pros: It would be convenient as the teacher do not need to key in similar subjects for everyone.
** Cons: The students may have different subject combination and different grades for different subjects, and this consideration neglects this fact.
* **Alternative 2 (current choice):** The command can only add to one specified student at a time.
** Pros: The algorithm will be slightly less complicated and easier to implement.
** Cons: Depending on the situation, the user may want a mass adding feature implemented as it would be more convenient.

// end::addsubjects[]

*_return to <<toc,Table of Contents>>_*

// tag::dataencryption[]

=== [Proposed] Data Encryption

_{Explain here how the data encryption feature will be implemented}_

// end::dataencryption[]

// tag::browserpanel[]
=== Browser Panel Revamp

.First Half of Browser Panel
image::browser1.png[width="600"]
.Second Half of Browser Panel
image::browser2.png[width="600"]

We will use a html page with w3.css framework support to implement the new Browser Panel.
The browser panel can be controlled from the CLI interface, which manipulates the data in the browser panel.

The browser will be invoked by the selection of a student from ui/BrowserPanel. loadPersonPage() invokes the html file
of the student selected stored in resources/StudentPage.

Creation of a html StudentPage file:

After add command is called successfully, a template file from StudentPage will be duplicated as a backup,
and renamed as the name that is called from the add command.

Editing StudentPage file:
After any command that changes the data in the BrowserPanel is called, the HTML file will be stored as a string and edited accordingly.
The file is then output to {user.home}/StudentPage.

 When a user inputs new data, the selected 'logic' command invokes the addPage and deletePage method from ModelManager.
 From the 'model''s addPage command, 'template.html' from resources/StudentPage is called.
 A new folder is created in {user.home}/StudentPage which creates a 'storage' for the user profile pages.
 These user-profile pages are updated in real time when called by the UI BrowserPanel object.

// end::browserpanel[]

*_return to <<toc,Table of Contents>>_*

// tag::theme[]
=== Theme Feature
==== Current Implementation
The theme command is a command that changes the theme of the program.
The input from the user would be parsed with a dedicated parser class 'ChangeThemeCommandParser'.
We will implement a HashMap to choose the right theme to use from the user input.
The themes are found in resources/view.

.  `Logic` uses the `ChangeThemeCommandParser` class to parse the command.
.  This results in a `ChangeThemeCommand` object which is executed by the `LogicManager`.
.  The command execution calls the `ThemeColourUtil` method which then affects the `Model`, which calls the appropriate theme from /view/.
.  The theme is then changed, passed back to the ChangeThemeCommand object which changes the 'UI'.


==== Design Considerations.
===== Aspect: Data structure to support the tag replace command
* ** Alternative 1: ** Reuse the set that exist in the Addressbook.
** Pros: Need not introduce a new data structure to store the tags that are passed in.
** Cons: A set arranges its elements in alphabetical order. This disrupts the order in which the user has entered,
         and it would cause the wanted tag to be removed instead of the unwanted one.

// end::Theme[]

*_return to <<toc,Table of Contents>>_*

// tag::remark[]
=== Remark Feature
==== Current Implementation

A new remark component is added to the person model.

This remark feature allows the user to add remarks to the student profile of the specified student.

image::RemarkClassSequenceDiagram.png[width="800"]

Figure 15. Sequence Diagram of AddRemarkCommand

==== Design Considerations
===== Aspect: Implementation of the `Remark` feature
* ** Alternative 1:** Using just one method to add and delete the remark.
** Pros: Need not create 2 command just to add and delete the remarks.
** Cons: The remark attached to the student in our student profile would not be able to exceed one line.

*_return to <<toc,Table of Contents>>_*
// end::remark[]

// tag::InjuriesHistory[]
=== Injuries History Feature
==== Current Implementation

A new injuries history component is added to the person model.

This injuries history feature allows the user to add injuries history to the student profile of the specified student.

//image::InjuriesHistoryClassSequenceDiagram.png[width="800"]

//Figure 15. Sequence Diagram of AddInjuriesCommand

==== Design Considerations
===== Aspect: Implementation of the `Injuries History` feature
* ** Alternative 1:** Using just one method to add and delete the injuries history.
** Pros: Need not create 2 command just to add and delete the injuries history.
** Cons: The injuries history attached to the student in our student profile would not be able to exceed one line.

*_return to <<toc,Table of Contents>>_*
// end::InjuriesHistory[]

// tag::Cca[]
=== Cca Feature
==== Current Implementation

A new cca component is added to the person model.

This cca feature allows the user to add cca and the position to the student profile of the specified student.

//image::CcaClassSequenceDiagram.png[width="800"]

//Figure 15. Sequence Diagram of CcaCommand

==== Design Considerations
===== Aspect: Implementation of the `Cca` feature
* ** Alternative 1:** Using just two methods to add and delete the details of the cca.
** Pros: More than 1 details of the student cca can be added.
** Cons: The user has to type separate commands just to add or delete the details.

*_return to <<toc,Table of Contents>>_*
// end::Cca[]

// tag::NOK[]
=== NextOfKin Feature
==== Current Implementation

A new next of kin component is added to the person model.

This NextOfKin feature allows the user to add the details of the student's next of kin into the student profile of the specified student.

//image::NextOfKinClassSequenceDiagram.png[width="800"]

//Figure 15. Sequence Diagram of NextOfKinCommand

==== Design Considerations
===== Aspect: Implementation of the `NextOfKin` feature
* ** Alternative 1:** Using just two methods to add and delete the details of the next of kin of the student.
** Pros: More than 1 details of the student's next of kin can be added.
** Cons: The user has to type separate commands just to add or delete the details.

*_return to <<toc,Table of Contents>>_*
// end::NOK[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

*_return to <<toc,Table of Contents>>_*

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

*_return to <<toc,Table of Contents>>_*

[[Testing]]
== Testing
This section explains the various testing methods available in our application
and also provides some troubleshooting techniques.

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

*_return to <<toc,Table of Contents>>_*

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews
When a pull request has changes to asciidoc files, you can use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of those asciidoc files will look like when the pull request is merged. See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

*_return to <<toc,Table of Contents>>_*

[[GetStartedProgramming]]
[appendix]
== Suggested Programming Tasks to Get Started

Suggested path for new programmers:

1. First, add small local-impact (i.e. the impact of the change does not go beyond the component) enhancements to one component at a time. Some suggestions are given in <<GetStartedProgramming-EachComponent>>.

2. Next, add a feature that touches multiple components to learn how to implement an end-to-end feature across all components. <<GetStartedProgramming-RemarkCommand>> explains how to go about adding such a feature.

[[GetStartedProgramming-EachComponent]]

== Product Scope

*Target user profile*:

* is a secondary school teacher
* needs to know more about the students that they have taught
* has a need to track results
* has a need to manage a significant number of students
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: manage contacts faster than a typical mouse/GUI driven app

*_return to <<toc,Table of Contents>>_*

[appendix]
== Feature Contribution

[width="85%",cols="22%,<23%,<40%",options="header",]
|=======================================================================
|Name | Major |Minor
|Johnny  |Display Panel: Add display panel functionalities to UI window | Data Integration: Integrate data input from user into display window

|Xin Hui |Academic Section: Help teachers to view and manage students' academic information | Subject Class Database: Create subject class and integrate input into command. Add L1R5 calculation support into subject inputs.

|Kun Hong |Administrative Information: Add student administrative information into EduBuddy | Tag Support: Enhance tag functionalities in EduBuddy



|Keng Seng |Calendar: Add calendar features which supports different administrative tasks | Sorting feature: Add sorting functionalities based on various parameters

|=======================================================================

*_return to <<toc,Table of Contents>>_*

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |teacher |update students' classes |know which classes they are in easily

|`* * *` |teacher |update students' academic results |view and obtain students' streaming score (eg.L1R5)

|`* * *` |teacher |access student's academic and non-academic achievements |stream the students properly (e.g. Normal Academic, Normal Technical, Express)


|`* * *` |teacher |access student profiles easily  | have first hand information on all my students without going through a lot of documentation

|`* * *` |teacher |edit remarks of each individual student |update the students' individual needs that occur during class

|`* *` |teacher |filter and group students |access information of specific students

|`* *` |teacher |update student's marks |track the student's improvement in a certain subject

|`* *` |teacher |know the students' emergency contact information |know who to contact when something happens to the student

|`* *` |teacher |update student's attendance records |know if a student has been absent too frequently

|`*` |teacher |look up on student's identity |recognize who the student is

|`*` |teacher |know which subjects that I have taught them before |customize my teaching methods for different students

|`*` |teacher |can track the student's progress in the CCA |decide whether to involve the student more

|`*` |teacher |key in the levels attained by the students in the various domains in L.E.A.P.S system
|calculate the Co-Curricular Attainment achieved by the student.

|`*` |teacher |view the student's injuries history |to know the need of my students.

|=======================================================================

*_return to <<toc,Table of Contents>>_*

[appendix]
== Use Cases

(For all use cases below, the *System* is `EduBuddy` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Delete person

*Main Success Scenario*

1.  User requests to list persons
2.  AddressBook shows a list of persons
3.  User requests to delete a specific person in the list
4.  AddressBook deletes the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Retrieve information of selected person

*Main Success Scenario*

1.  User requests to list or find persons
2.  AddressBook shows a list of persons
3.  User requests to select a specific person in the list
4.  AddressBook loads the information of the selected person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Add remarks for person

*Main Success Scenario*

1.  User requests to list or find persons
2.  AddressBook shows a list of persons
3.  User requests to add remarks for a specific person in the list
4.  AddressBook shows the updated information of the selected person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Add an appointment

*Main Success Scenario*

1.  User requests to list or find persons
2.  AddressBook shows a list of persons
3.  User requests to add an appointment for a specific person in the list by typing in a date and time
4.  AddressBook shows the updated details of the appointment
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

* 3b. The given date or time is in a invalid format.
+
[none]
** 3b1. AddressBook shows an error message.
+
Use case resumes at step 2.

* 3c. The given date or time is already booked by another appointment.
+
[none]
** 3c1. AddressBook prompts user to input another date or time.
+
Use case resumes at step 2.

[discrete]
=== Use case: Add students' academic results

*Main Success Scenario*

1.  User requests to list or find persons
2.  AddressBook shows a list of persons
3.  User requests to update students' academic results using `AddCommand`
4.  AddressBook shows updated details of academic results
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
* 3b. The given subject(s) is/are invalid, for example, the name or the grade.
+
[none]
** 3b1. AddressBook shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: View students' academic results

*Main Success Scenario*

1.  User requests to list or find persons
2.  AddressBook shows a list of persons
3.  User requests to view students' academic results using `SelectCommand`
4.  AddressBook shows updated details of academic results
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
* 3b. No subjects are assigned to the student.
+
[none]
** 3b1. UI shows an empty list of subjects.
+
Use case resumes at step 2.

[discrete]
=== Use case: View students' streaming results

*Main Success Scenario*

1.  User requests to list or find persons
2.  AddressBook shows a list of persons
3.  User requests to view students' streaming results using `SelectCommand` or `StreamCommand`
4.  AddressBook shows updated details of streaming results
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index or parameter is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
* 3b. No subjects are assigned to the student.
+
[none]
** 3b1. Streaming results will be shown as zero.
+
* 3c. Not enough subjects are assigned to the student.
+
[none]
** 3c1. Streaming results will be shown as zero.
+
Use case resumes at step 2.

[discrete]
=== Use case: Update students' academic results

*Main Success Scenario*

1.  User requests to list or find persons
2.  AddressBook shows a list of persons
3.  User requests to update students' academic results using `EditCommand` or `AddSubjectCommand`
4.  AddressBook shows updated details of academic results
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
* 3b. The given subject(s) is/are invalid, for example, the name or the grade.
+
[none]
** 3b1. AddressBook shows an error message.
+
* 3c. There are duplicate subjects in the user input.
+
[none]
** 3c1. AddressBook shows an error message.
+
Use case resumes at step 2.

*_return to <<toc,Table of Contents>>_*

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1,200 students
 without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

*_return to <<toc,Table of Contents>>_*

[appendix]
== Glossary

[[CCA}} CCA::
CCA stands for Co-Curricular Activities. It functions as a non-academic activity where students can have a more enriching experience in school. Find out more by clicking https://www.moe.gov.sg/education/programmes/co-curricular-activities[here].

[[Grade]] Grade::
The grading of the subjects by the level of competence the students show during the "O-Level examination".
The level of achievement in each subject is indicated by the grade obtained, with A1 being the highest achievable grade and F9 the lowest:
[width="30%",cols="22%,<23%",options="header",]
|=======================================================================
|Grade|Percentage of Competency
|A1| 75% - 100%
|A2| 70% - 74%
|B3| 65% - 69%
|B4| 60% - 64%
|C5| 55% - 59%
|C6| 50% - 54%
|D7| 45% - 49%
|E8| 40% - 44%
|F9| 0% - 39%
|=======================================================================

[[L1B4]] L1B4::
A grading system for Secondary School students taking "O-Level Examination" at the end of their four years of studies in Secondary School.
The score obtained from the grading system will be used to determine the eligibility of the students to enter the next level of education, Polytechnic.
`L1` represents the First language subject and `B4` represents 2 relevant subjects, according to the polytechnic course applied, and 2 other best subjects.
The category the relevant subject is under(for example: L1B4-A, L1B4-B, L1B4-C, L1B4D), will determine which subjects are the relevant subjects.
The score will be calculated by considering the subjects' grades. Each subject can only be considered once.

If you want to find out more about the subject categories (L1B4-A, L1B4-B, L1B4-C, L1B4D),
please visit:

* https://www.sp.edu.sg/wps/portal/vp-spws/!ut/p/a0/04_Sj9CPykssy0xPLMnMz0vMAfGjzOJDPUxdjdxMTQws3J1cDDwt_MJMXZxDDE3cDfQLsh0VAYY7oWE!/?PC_Z7_UH5E2F540G6P00IO8K5AU61JM5027774_WCM_CONTEXT=/wps/wcm/connect/lib-spws/site-spwebsite/future+students/admissions/selection+criteria+for+gce+o+level+holders+-+aggregate+computation++%28admissions+-+course+intakes+and+cut-off+points%29[Singapore Polytechnic]
* http://www.tp.edu.sg/admissions/gce-o-level-aggregate-scores-computation[Temasek Polytechnic]
* https://www.moe.gov.sg/education/post-secondary#polytechnics[Other Polytechnics]

[[L1R5]] L1R5::
1R5 is a grading system used in Singapore to determine the secondary school students' proficiency in the subjects taken for "O-Level Examination".
The score is used for the students to enroll into Junior Colleges, which is the next higher level of education. "L1" refers to the first language subject taken by the student, while "R5" refers to the 5 relevant subjects that are examinable by the students.
The grade of L1R5 is then determined by taking the best grades of each category and summing them up, for example, if a student scores A1 for all 6 subjects are from each category, the score will be 6. Each subject can only be considered once.
For more information, please click https://www.moe.gov.sg/admissions/direct-admissions/dsa-jc/eligibility[here]

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[NRIC]] NRIC::
It stands for National Registration Identity Card, and it is an identification document for the residents in Singapore.
The `NRIC` that we are referring to in the _EduBuddy_ refers to the unique identification number that comes with each `NRIC`.
Please visit https://www.ica.gov.sg/[this website] for more details.

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others

[[Subject]] Subject::
These are the following subjects that are examinable in O-level Examinations in Singapore (as of Year 2018).
[NOTE]
The subjects in the brackets are not to be used as input. The subjects not in brackets are preferred for better efficiency in typing. +
For example, type in: `Hist A1` *not* `History A1`
[width="85%",cols="22%,<23%",options="header",]
|=======================================================================
|Subject Category|Subjects
|L1| English, HTamil(Higher Tamil), HChi(Higher Chinese), HMalay(Higher Malay)
|R1| Hist(History), Geog(Geography), ComHum(Combined Humanities), ELit(English Literature), CLit(Chinese Literature),
     MLit(Malay Literature), TLit(Tamil Literature), HArt(Higher Art), HMusic(Higher Music), BIndo(Bahasa Indonesia),
     CSP(Chinese Special Programme), MSP(Malay Special Programme)
|R2| EMath(Elementary Mathematics), AMath(Additional Mathematics), Phy(Physics), Chem(Chemistry), Bio(Biology), Sci(Combined Science)
|R3| Consist of both R1 and R2 subjects
|R4| Consist of L1, R1 and R2 subjects. French, German, Spanish, Hindi, Urdu, Gujarati, Panjabi, Bengali, Burmese,
     Thai, Jap(Japanese), Tamil, Chinese, Malay, DnT(Design and Technology), Comp(Computing), FnN(Food and Nutrition), PoA(Principles of Accounting),
     Econs(Economics), Drama, PE(Physical Education), Biz(Business Studies), Biotech(Biotechnology), Design(Design Studies)
|R5| Consist of R4 subjects
|=======================================================================

* The following subjects can be assigned to students but cannot be contributed to the results: ChiB (Chinese B), MalayB (Malay B), TamilB(Tamil B).

*_return to <<toc,Table of Contents>>_*

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

*_return to <<toc,Table of Contents>>_*
