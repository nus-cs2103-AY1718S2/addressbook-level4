# mhq199657
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public void filterFilteredPersonList(Predicate<Person> predicate) {
        requireNonNull(predicate);
        Predicate<? super Person> currPredicate = filteredPersons.getPredicate();
        filteredPersons.setPredicate(isNull(currPredicate) ? predicate : predicate.and(currPredicate));
    }

```
###### /java/seedu/address/model/util/InterviewDateUtil.java
``` java
/**
 * A utility class responsible of forming LocalDateTime from a string obtained in filter command
 */
public class InterviewDateUtil {
    public static final String MESSAGE_INTERVIEW_DATE_CONSTRAINT =
            "Interview date should be of the format yyyyMMdd. Example: 20170323. Month and day must be valid.";

    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("uuuuMMdd");
    private static final DateTimeFormatter LOWER_DATETIME_FORMATTER =
            new DateTimeFormatterBuilder().append(DATE_FORMATTER)
                    .parseDefaulting(ChronoField.HOUR_OF_DAY, 0)
                    .parseDefaulting(ChronoField.MINUTE_OF_HOUR, 0)
                    .parseDefaulting(ChronoField.SECOND_OF_MINUTE, 0)
                    .toFormatter()
                    .withResolverStyle(ResolverStyle.STRICT);
    private static final DateTimeFormatter HIGHER_DATETIME_FORMATTER =
            new DateTimeFormatterBuilder().append(DATE_FORMATTER)
                    .parseDefaulting(ChronoField.HOUR_OF_DAY, 23)
                    .parseDefaulting(ChronoField.MINUTE_OF_HOUR, 59)
                    .parseDefaulting(ChronoField.SECOND_OF_MINUTE, 59)
                    .toFormatter()
                    .withResolverStyle(ResolverStyle.STRICT);

    /**
     * Check whether the input parameter are 8 numbers which is a prerequisite of uuuuMMdd format
     * @param test
     * @return validity of test
     */
    public static boolean isValidInterviewDate(String test) {
        requireNonNull(test);
        return test.matches("^[0-9]{8}$");
    }

    public static LocalDateTime formLowerInterviewDateTime(String yyyyMMdd) throws DateTimeParseException {
        return LocalDateTime.parse(yyyyMMdd, LOWER_DATETIME_FORMATTER);
    }
    public static LocalDateTime formHigherInterviewDateTime(String yyyyMMdd) throws DateTimeParseException {
        return LocalDateTime.parse(yyyyMMdd, HIGHER_DATETIME_FORMATTER);
    }
}
```
###### /java/seedu/address/model/person/InterviewDateInKeywordsRangePredicate.java
``` java
/**
 * A Predicate testing whether a person has his/her interview date in the keywords range
 */
public class InterviewDateInKeywordsRangePredicate implements Predicate<Person> {
    private final LocalDateTime low;
    private final LocalDateTime high;
    public InterviewDateInKeywordsRangePredicate(InterviewDate low, InterviewDate high) {
        this.low = low.dateTime;
        this.high = high.dateTime;
    }

    public InterviewDateInKeywordsRangePredicate(FilterRange<InterviewDate> filterRange) {
        if (filterRange.isRange()) {
            this.low = filterRange.getLowValue().dateTime;
            this.high = filterRange.getHighValue().dateTime;
        } else {
            this.low = filterRange.getExactValue().dateTime;
            this.high = filterRange.getExactValue().dateTime;
        }
    }

    @Override
    public boolean test(Person person) {
        if (isNull(person.getInterviewDate().dateTime)) {
            return false;
        } else {
            return person.getInterviewDate().dateTime.compareTo(high) <= 0
                    && person.getInterviewDate().dateTime.compareTo(low) >= 0;
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof InterviewDateInKeywordsRangePredicate // instanceof handles nulls
                && this.low.equals(((InterviewDateInKeywordsRangePredicate) other).low)
                && this.high.equals(((InterviewDateInKeywordsRangePredicate) other).high)); // state check
    }
}
```
###### /java/seedu/address/model/person/ExpectedGraduationYearInKeywordsRangePredicate.java
``` java
/**
 * A Predicate testing whether a person has his/her expected graduation year in the keywords range
 */
public class ExpectedGraduationYearInKeywordsRangePredicate implements Predicate<Person> {
    private final String low;
    private final String high;
    public ExpectedGraduationYearInKeywordsRangePredicate(ExpectedGraduationYear low, ExpectedGraduationYear high) {
        this.low = low.value;
        this.high = high.value;
    }

    public ExpectedGraduationYearInKeywordsRangePredicate(FilterRange<ExpectedGraduationYear> filterRange) {
        if (filterRange.isRange()) {
            this.low = filterRange.getLowValue().value;
            this.high = filterRange.getHighValue().value;
        } else {
            this.low = filterRange.getExactValue().value;
            this.high = filterRange.getExactValue().value;
        }
    }

    @Override
    public boolean test(Person person) {
        return person.getExpectedGraduationYear().value.compareTo(high) <= 0
                && person.getExpectedGraduationYear().value.compareTo(low) >= 0;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ExpectedGraduationYearInKeywordsRangePredicate // instanceof handles nulls
                && this.low.equals(((ExpectedGraduationYearInKeywordsRangePredicate) other).low)
                && this.high.equals(((ExpectedGraduationYearInKeywordsRangePredicate) other).high)); // state check
    }
}
```
###### /java/seedu/address/model/person/ExpectedGraduationYear.java
``` java
/**
 * Represents a Person's expectedGraduationYear in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidExpectedGraduationYear(String)}
 */
public class ExpectedGraduationYear {
    public static final String MESSAGE_EXPECTED_GRADUATION_YEAR_CONSTRAINTS =
            "Expected graduation year can only contain numbers, and should be between 2017 to 2025.";
    private static final String EXPECTED_GRADUATION_YEAR_VALIDATION_REGEX = "\\d{4}";
    private static final int YEAR_LOWER_BOUND = 2017;
    private static final int YEAR_UPPER_BOUND = 2025;
    public final String value;
    /**
     * Constructs a {@code expectedGraduationYear}.
     *
     * @param expectedGraduationYear A valid expectedGraduationYear.
     */
    public ExpectedGraduationYear(String expectedGraduationYear) {
        requireNonNull(expectedGraduationYear);
        checkArgument(isValidExpectedGraduationYear(expectedGraduationYear),
                MESSAGE_EXPECTED_GRADUATION_YEAR_CONSTRAINTS);
        this.value = expectedGraduationYear;
    }

    /**
     * Returns true if a given string is a valid expectedGraduationYear.
     */
    public static boolean isValidExpectedGraduationYear(String test) {
        return test.matches(EXPECTED_GRADUATION_YEAR_VALIDATION_REGEX) && isInValidRange(test);
    }

    /**
     *
     * @param test An expected graduation year matching regex
     * @return whether the graduation year is in valid range
     */
    private static boolean isInValidRange(String test) {
        int year = Integer.parseInt(test);
        return year >= YEAR_LOWER_BOUND && year <= YEAR_UPPER_BOUND;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ExpectedGraduationYear // instanceof handles nulls
                && this.value.equals(((ExpectedGraduationYear) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
}
```
###### /java/seedu/address/model/person/RatingInKeywordsRangePredicate.java
``` java
/**
 * A Predicate testing whether a person has his/her rating in the keywords range
 */
public class RatingInKeywordsRangePredicate implements Predicate<Person> {
    private final double low;
    private final double high;
    public RatingInKeywordsRangePredicate(Rating low, Rating high) {
        this.low = low.getOverallScore();
        this.high = high.getOverallScore();
    }

    public RatingInKeywordsRangePredicate(FilterRange<Rating> filterRange) {
        if (filterRange.isRange()) {
            this.low = filterRange.getLowValue().getOverallScore();
            this.high = filterRange.getHighValue().getOverallScore();
        } else {
            this.low = filterRange.getExactValue().getOverallScore();
            this.high = filterRange.getExactValue().getOverallScore();
        }
    }

    @Override
    public boolean test(Person person) {
        return person.getRating().getOverallScore() <= high
                && person.getRating().getOverallScore() >= low;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof RatingInKeywordsRangePredicate // instanceof handles nulls
                && this.low == ((RatingInKeywordsRangePredicate) other).low
                && this.high == ((RatingInKeywordsRangePredicate) other).high); // state check
    }
}
```
###### /java/seedu/address/model/person/Status.java
``` java
/**
 * Represents a candidate's status of his/her application.
 * Guarantees: Status value is one of the seven predefined values.
 */
public class Status {
    public static final String MESSAGE_STATUS_CONSTRAINTS =
            "Person status should only be specified by one of the predefined status indices.";
    public static final String STATUS_NEW = "New";
    public static final String STATUS_INTERVIEW_FIRST_ROUND = "1st round";
    public static final String STATUS_INTERVIEW_SECOND_ROUND = "2nd round";
    public static final String STATUS_REJECTED = "Rejected";
    public static final String STATUS_WAITLIST = "Waitlist";
    public static final String STATUS_OFFERED = "Offered";
    public static final String STATUS_ACCEPTED = "Accepted";
    public static final String STATUS_WITHDRAWN = "Withdrawn";

    public static final int STATUS_TYPE_CONUT = 8;

    public static final int INDEX_STATUS_NEW = 1;
    public static final int INDEX_STATUS_INTERVIEW_FIRST_ROUND = 2;
    public static final int INDEX_STATUS_INTERVIEW_SECOND_ROUND = 3;
    public static final int INDEX_STATUS_REJECTED = 4;
    public static final int INDEX_STATUS_WAITLIST = 5;
    public static final int INDEX_STATUS_OFFERED = 6;
    public static final int INDEX_STATUS_ACCEPTED = 7;
    public static final int INDEX_STATUS_WITHDRAWN = 8;

    public static final Color COLOR_NEW = Color.web("#795548");
    public static final Color COLOR_INTERVIEW_FIRST_ROUND = Color.web("#AB47BC");
    public static final Color COLOR_INTERVIEW_SECOND_ROUND = Color.web("#7E57C2");
    public static final Color COLOR_REJECTED = Color.web("#EF5350");
    public static final Color COLOR_WAITLIST = Color.web("#FFA726");
    public static final Color COLOR_OFFERED = Color.web("#42A5F5");
    public static final Color COLOR_ACCEPTED = Color.web("#8BC34A");
    public static final Color COLOR_WITHDRAWN = Color.web("#9E9E9E");

    private static final HashMap<Integer, String> STATUS_MAP;
    static {
        Map<Integer, String> initMap = new HashMap<Integer, String>();
        initMap.put(INDEX_STATUS_NEW, STATUS_NEW);
        initMap.put(INDEX_STATUS_INTERVIEW_FIRST_ROUND, STATUS_INTERVIEW_FIRST_ROUND);
        initMap.put(INDEX_STATUS_INTERVIEW_SECOND_ROUND, STATUS_INTERVIEW_SECOND_ROUND);
        initMap.put(INDEX_STATUS_REJECTED, STATUS_REJECTED);
        initMap.put(INDEX_STATUS_WAITLIST, STATUS_WAITLIST);
        initMap.put(INDEX_STATUS_OFFERED, STATUS_OFFERED);
        initMap.put(INDEX_STATUS_ACCEPTED, STATUS_ACCEPTED);
        initMap.put(INDEX_STATUS_WITHDRAWN, STATUS_WITHDRAWN);
        STATUS_MAP = new HashMap<>(initMap);
    }
    private static final HashMap<String, Color> COLOR_MAP;
    static {
        Map<String, Color> initMap = new HashMap<String, Color>();
        initMap.put(STATUS_NEW, COLOR_NEW);
        initMap.put(STATUS_INTERVIEW_FIRST_ROUND, COLOR_INTERVIEW_FIRST_ROUND);
        initMap.put(STATUS_INTERVIEW_SECOND_ROUND, COLOR_INTERVIEW_SECOND_ROUND);
        initMap.put(STATUS_REJECTED, COLOR_REJECTED);
        initMap.put(STATUS_WAITLIST, COLOR_WAITLIST);
        initMap.put(STATUS_OFFERED, COLOR_OFFERED);
        initMap.put(STATUS_ACCEPTED, COLOR_ACCEPTED);
        initMap.put(STATUS_WITHDRAWN, COLOR_WITHDRAWN);
        COLOR_MAP = new HashMap<String, Color>(initMap);
    }
    public final String value;
    public final Color color;
    /**
     * Constructs a {@code Status}.
     *
     * @param statusIndex A valid status index.
     */
    public Status(int statusIndex) {
        checkArgument(isValidStatus(statusIndex), MESSAGE_STATUS_CONSTRAINTS);
        this.value = getStatus(statusIndex);
        this.color = getColor(value);
    }

    public Status(String status) {
        requireNonNull(status);
        checkArgument(isValidXmlStatus(status), MESSAGE_STATUS_CONSTRAINTS);
        this.value = status;
        this.color = getColor(value);
    }

    public Status() {
        this.value = getStatus(INDEX_STATUS_NEW);
        this.color = getColor(value);
    }

    /**
     * Returns true if a given string is a valid person major.
     */
    public static boolean isValidStatus (int test) {
        return STATUS_MAP.containsKey(test);
    }

    public static boolean isValidXmlStatus(String test) {
        return COLOR_MAP.containsKey(test);
    }

    private static String getStatus(int statusIndex) {
        return STATUS_MAP.get(statusIndex);
    }

    private static Color getColor(String status) {
        return COLOR_MAP.get(status);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Status // instanceof handles nulls
                && this.value.equals(((Status) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
}
```
###### /java/seedu/address/model/person/GradePointAverageInKeywordsRangePredicate.java
``` java
/**
 * A Predicate testing whether a person has his/her grade point average in the keywords range
 */
public class GradePointAverageInKeywordsRangePredicate implements Predicate<Person> {
    private final String low;
    private final String high;
    public GradePointAverageInKeywordsRangePredicate(GradePointAverage low, GradePointAverage high) {
        this.low = low.value;
        this.high = high.value;
    }

    public GradePointAverageInKeywordsRangePredicate(FilterRange<GradePointAverage> filterRange) {
        if (filterRange.isRange()) {
            this.low = filterRange.getLowValue().value;
            this.high = filterRange.getHighValue().value;
        } else {
            this.low = filterRange.getExactValue().value;
            this.high = filterRange.getExactValue().value;
        }
    }

    @Override
    public boolean test(Person person) {
        return Double.valueOf(person.getGradePointAverage().value).compareTo(Double.valueOf(high)) <= 0
                && Double.valueOf(person.getGradePointAverage().value).compareTo(Double.valueOf(low)) >= 0;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof GradePointAverageInKeywordsRangePredicate // instanceof handles nulls
                && this.low.equals(((GradePointAverageInKeywordsRangePredicate) other).low)
                && this.high.equals(((GradePointAverageInKeywordsRangePredicate) other).high)); // state check
    }
}
```
###### /java/seedu/address/model/person/Resume.java
``` java
/**
 * Represents a Person's resume's file name in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidResume(String)}
 */
public class Resume {
    public static final String MESSAGE_RESUME_CONSTRAINTS =
            "Resume file should be at least 1 character long, exist in the same directory as the jar programme, "
                    + "smaller than 1MB and should be a valid PDF.";
    private static final int ONEMEGABYTE = 1 * 1024 * 1024;
    private static final String RESUME_VALIDATION_REGEX = ".*\\S.*";
    public final String value;
    /**
     * Constructs a {@code Resume}.
     *
     * @param fileName A valid fileName.
     */
    public Resume(String fileName) {
        if (isNull(fileName)) {
            this.value = null;
        } else {
            checkArgument(isValidResume(fileName), MESSAGE_RESUME_CONSTRAINTS);
            this.value = fileName;
        }
    }

    /**
     * Returns true if a given string is a valid person resume.
     */
    public static boolean isValidResume(String test) {
        requireNonNull(test);
        if (!test.matches(RESUME_VALIDATION_REGEX)) {
            return false;
        }
        String userDir = System.getProperty("user.dir");
        File resumeFile = new File(userDir + File.separator + test);
        if (resumeFile.isDirectory()) {
            return false;
        } else if (!resumeFile.exists()) {
            return false;
        } else {
            if (resumeFile.length() > ONEMEGABYTE) {
                return false;
            } else {
                try {
                    byte[] resumeBytes = Files.readAllBytes(resumeFile.toPath());
                    return isPdf(resumeBytes);
                } catch (IOException ioe) {
                    return false;
                }
            }
        }
    }
    /**
     * Returns true if a given byte array is of pdf type.
     */
    private static boolean isPdf(byte[] data) {
        if (data != null && data.length > 4
                && data[0] == 0x25 && // %
                data[1] == 0x50 && // P
                data[2] == 0x44 && // D
                data[3] == 0x46 && // F
                data[4] == 0x2D) { // -
            // version 1.3 file terminator
            if (data[5] == 0x31 && data[6] == 0x2E && data[7] == 0x33
                    && data[data.length - 7] == 0x25 && // %
                    data[data.length - 6] == 0x25 && // %
                    data[data.length - 5] == 0x45 && // E
                    data[data.length - 4] == 0x4F && // O
                    data[data.length - 3] == 0x46 && // F
                    data[data.length - 2] == 0x20 && (// SPACE
                    data[data.length - 1] == 0x0A || data[data.length - 1] == 0x0D)) { // EOL or CR
                return true;
            }
            // version 1.3 file terminator
            if (data[5] == 0x31 && data[6] == 0x2E && data[7] == 0x33
                    && data[data.length - 6] == 0x25 && // %
                    data[data.length - 5] == 0x25 && // %
                    data[data.length - 4] == 0x45 && // E
                    data[data.length - 3] == 0x4F && // O
                    data[data.length - 2] == 0x46 && (// F
                    data[data.length - 1] == 0x0A || data[data.length - 1] == 0x0D)) { // EOL
                return true;
            }
            // version 1.4 file terminator
            if (data[5] == 0x31 && data[6] == 0x2E && data[7] == 0x34
                    && data[data.length - 6] == 0x25 && // %
                    data[data.length - 5] == 0x25 && // %
                    data[data.length - 4] == 0x45 && // E
                    data[data.length - 3] == 0x4F && // O
                    data[data.length - 2] == 0x46 && (// F
                    data[data.length - 1] == 0x0A || data[data.length - 1] == 0x0D)) { // EOL
                return true;
            }
            // version 1.5 file terminator
            if (data[5] == 0x31 && data[6] == 0x2E && data[7] == 0x35
                    && data[data.length - 6] == 0x25 && // %
                    data[data.length - 5] == 0x25 && // %
                    data[data.length - 4] == 0x45 && // E
                    data[data.length - 3] == 0x4F && // O
                    data[data.length - 2] == 0x46 && (// F
                    data[data.length - 1] == 0x0A || data[data.length - 1] == 0x0D)) { // EOL
                return true;
            }
            if (data[5] == 0x31 && data[6] == 0x2E && data[7] == 0x35
                    && data[data.length - 5] == 0x25 && // %
                    data[data.length - 4] == 0x25 && // %
                    data[data.length - 3] == 0x45 && // E
                    data[data.length - 2] == 0x4F && // O
                    data[data.length - 1] == 0x46) { // F
                return true;
            }
        }
        return false;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Resume // instanceof handles nulls
                && ((isNull(this.value) && isNull(((Resume) other).value)) //both value are null
                    || this.value.equals(((Resume) other).value))); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/address/logic/commands/FilterCommand.java
``` java
/**
 * Filters and lists all persons in address book whose graduation year is before or equal to the specified year..
 */
public class FilterCommand extends Command {
    public static final String COMMAND_WORD = "filter";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Filter according the predicates specified. "
            + "Display all persons with fields in the range specified by the input keyword.\n"
            + "Range is either a single predicate, or an interval in the format of `low - high`, "
            + "or a combination of both using commas.\n"
            + "Filterable field is expected graduation year."
            + "Parameters: "
            + "[" + PREFIX_EXPECTED_GRADUATION_YEAR + "EXPECTED GRADUATION YEAR] "
            + "Example: " + COMMAND_WORD + " "
            + PREFIX_EXPECTED_GRADUATION_YEAR + " 2020, 2021-2024";

    private final Predicate<Person> predicate;
    public FilterCommand(Predicate<Person> predicate) {
        this.predicate = predicate;
    }

    @Override
    public CommandResult execute() {
        model.filterFilteredPersonList(predicate);
        return new CommandResult(getMessageForPersonListShownSummary(model.getFilteredPersonList().size()));
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof FilterCommand // instanceof handles nulls
                && this.predicate.equals(((FilterCommand) other).predicate)); // state check
    }

}
```
###### /java/seedu/address/logic/commands/StatusCommand.java
``` java
/**
 * Update status of an existing person in HR+.
 */
public class StatusCommand extends UndoableCommand {
    public static final String COMMAND_WORD = "status";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Update status for the person "
            + "by the index number used in the last person listing. "
            + "Existing status will be overwritten by the input value.\n"
            + "Parameters: INDEX (must be a positive integer) "
            + "STATUS_INDEX(by the list below)\n"
            + "1. " + Status.STATUS_NEW + "\n"
            + "2. " + Status.STATUS_INTERVIEW_FIRST_ROUND + "\n"
            + "3. " + Status.STATUS_INTERVIEW_SECOND_ROUND + "\n"
            + "4. " + Status.STATUS_REJECTED + "\n"
            + "5. " + Status.STATUS_WAITLIST + "\n"
            + "6. " + Status.STATUS_OFFERED + "\n"
            + "7. " + Status.STATUS_ACCEPTED + "\n"
            + "8. " + Status.STATUS_WITHDRAWN + "\n"
            + "Example: " + COMMAND_WORD + " 1 2";

    public static final String MESSAGE_STATUS_SUCCESS =
            "Status of person named %1$s has been updated to '%2$s'";

    private final Index index;
    private final Status updatedStatus;

    private Person personToUpdateStatus;
    private Person updatedPerson;
    /**
     * @param index of the person in the filtered person list to update status
     * @param updatedStatus updatedStatus
     */
    public StatusCommand(Index index, Status updatedStatus) {
        requireNonNull(index);
        requireNonNull(updatedStatus);

        this.index    = index;
        this.updatedStatus = updatedStatus;
    }

    public Index getIndex() {
        return index;
    }

    public Status getUpdatedStatus() {
        return updatedStatus;
    }

    public Person getPersonToUpdateStatus() {
        return personToUpdateStatus;
    }

    @Override
    public CommandResult executeUndoableCommand() {
        try {
            model.updatePerson(personToUpdateStatus, updatedPerson);
        } catch (DuplicatePersonException dpe) {
            throw new AssertionError("The target person cannot become a duplicate of another person "
                    + "via updating status.");
        } catch (PersonNotFoundException pnfe) {
            throw new AssertionError("The target person cannot be missing.");
        }

        return new CommandResult(String.format(MESSAGE_STATUS_SUCCESS,
                updatedPerson.getName(), updatedStatus.value));
    }

    @Override
    protected void preprocessUndoableCommand() throws CommandException {
        List<Person> lastShownList = model.getFilteredPersonList();

        if (index.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }

        personToUpdateStatus = lastShownList.get(index.getZeroBased());
        updatedPerson = createUpdatedPerson(personToUpdateStatus, updatedStatus);
    }

    /**
     * Creates and returns a {@code Person} with the details of {@code personToUpdateStatus}
     * with updated with {@code statusIndex}.
     */
    private static Person createUpdatedPerson(Person personToUpdateStatus, Status updatedStatus) {
        requireAllNonNull(personToUpdateStatus);

        return new Person(personToUpdateStatus.getName(), personToUpdateStatus.getPhone(),
                personToUpdateStatus.getEmail(), personToUpdateStatus.getAddress(),
                personToUpdateStatus.getUniversity(), personToUpdateStatus.getExpectedGraduationYear(),
                personToUpdateStatus.getMajor(), personToUpdateStatus.getGradePointAverage(),
                personToUpdateStatus.getJobApplied(), personToUpdateStatus.getRating(),
                personToUpdateStatus.getResume(), personToUpdateStatus.getProfileImage(),
                personToUpdateStatus.getComment(), personToUpdateStatus.getInterviewDate(),
                updatedStatus, personToUpdateStatus.getTags());
    }

    @Override
    public boolean equals(Object other) {
        // Short circuit if same object
        if (other == this) {
            return true;
        }

        // instanceof handles nulls
        if (!(other instanceof StatusCommand)) {
            return false;
        }

        // State check
        StatusCommand i = (StatusCommand) other;
        return getIndex().equals(i.getIndex())
                && getUpdatedStatus().equals(i.getUpdatedStatus())
                && Objects.equals(getPersonToUpdateStatus(), i.getPersonToUpdateStatus());
    }
}
```
###### /java/seedu/address/logic/parser/FilterUtil.java
``` java
/**
 * A utility class for parsing FilterCommand
 */
public class FilterUtil {
    /**
     * Parses a Optional of  predicateString to a Predicate used to filter Person
     * @param predicateString a predicate string read from user input
     * @return a Predicate for filter command
     * @throws IllegalValueException
     */
    public static Predicate<Person> parseExpectedGraduationYear(Optional<String> predicateString)
            throws IllegalValueException {
        requireNonNull(predicateString);
        if (predicateString.isPresent()) {
            return parseExpectedGraduationYear(predicateString.get());
        } else {
            return null;
        }
    }

    /**
     * Parses a predicateString to a Predicate used to filter Person
     * @param predicateString a predicate string read from user input
     * @return a Predicate for filter command
     * @throws IllegalValueException
     */
    public static Predicate<Person> parseExpectedGraduationYear(String predicateString)
            throws IllegalValueException {
        requireNonNull(predicateString);
        String[] predicateStrings = predicateString.split(",");
        Arrays.stream(predicateStrings).map(String::trim).toArray(unused -> predicateStrings);
        if (predicateStrings.length == 0) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
        }
        Predicate<Person> predicate = processExpectedGraduationYearPredicateStrings(predicateStrings);
        return predicate;
    }

    /**
     * Parses the string array of all single predicate strings to a predicate
     * @param predicateStrings array of predicateString
     * @return the predicate user demanded
     * @throws IllegalValueException
     */
    private static Predicate<Person> processExpectedGraduationYearPredicateStrings(String[] predicateStrings)
            throws IllegalValueException {
        List<Predicate<Person>> allPredicates = new ArrayList<Predicate<Person>>();
        for (String s: predicateStrings) {
            Predicate<Person> predicate = formExpectedGraduationYearPredicateFromPredicateString(s);
            allPredicates.add(predicate);
        }
        return combineAllPredicates(allPredicates);
    }

    /**
     * Combines a list of predicate into a single predicate
     * @param predicateList list of predicates
     * @return a single equivalent predicate
     */
    private static Predicate<Person> combineAllPredicates(List<Predicate<Person>> predicateList) {
        assert(predicateList.size() >= 1);
        Predicate<Person> allPredicates = predicateList.get(0);
        for (int i = 1; i < predicateList.size(); i++) {
            allPredicates = allPredicates.or(predicateList.get(i));
        }
        return allPredicates;
    }

    /**
     * Form a single predicate from a single predicate string
     * @param s a single predicate string
     * @return a single predicate
     * @throws IllegalValueException
     */
    private static Predicate<Person> formExpectedGraduationYearPredicateFromPredicateString(String s)
            throws IllegalValueException {
        FilterRange<ExpectedGraduationYear> filterRange;
        if (s.contains("-")) { //It is a range
            String[] range = s.split("-");
            if (range.length != 2) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
            } else if (ExpectedGraduationYear.isValidExpectedGraduationYear(range[0].trim())
                    && ExpectedGraduationYear.isValidExpectedGraduationYear(range[1].trim())) {
                filterRange = new FilterRange<ExpectedGraduationYear>(
                        new ExpectedGraduationYear(range[0].trim()), new ExpectedGraduationYear(range[1].trim()));
            } else {
                throw new IllegalValueException(ExpectedGraduationYear.MESSAGE_EXPECTED_GRADUATION_YEAR_CONSTRAINTS);
            }

        } else { //It is a value instead
            if (ExpectedGraduationYear.isValidExpectedGraduationYear(s.trim())) {
                filterRange = new FilterRange<ExpectedGraduationYear>(new ExpectedGraduationYear(s));
            } else {
                throw new IllegalValueException(ExpectedGraduationYear.MESSAGE_EXPECTED_GRADUATION_YEAR_CONSTRAINTS);
            }
        }
        Predicate<Person> predicate = new ExpectedGraduationYearInKeywordsRangePredicate(filterRange);
        return predicate;
    }

    /**
     * Parses a Optional of  predicateString to a Predicate used to filter Person
     * @param predicateString a predicate string read from user input
     * @return a Predicate for filter command
     * @throws IllegalValueException
     */
    public static Predicate<Person> parseRating(Optional<String> predicateString) throws IllegalValueException {
        requireNonNull(predicateString);
        if (predicateString.isPresent()) {
            return parseRating(predicateString.get());
        } else {
            return null;
        }
    }

    /**
     * Parses a predicateString to a Predicate used to filter Person
     * @param predicateString a predicate string read from user input
     * @return a Predicate for filter command
     * @throws IllegalValueException
     */
    public static Predicate<Person> parseRating(String predicateString)
            throws IllegalValueException {
        requireNonNull(predicateString);
        String[] predicateStrings = predicateString.split(",");
        Arrays.stream(predicateStrings).map(String::trim).toArray(unused -> predicateStrings);
        if (predicateStrings.length == 0) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
        }
        Predicate<Person> predicate = processRatingPredicateStrings(predicateStrings);
        return predicate;
    }

    /**
     * Parses the string array of all single predicate strings to a predicate
     * @param predicateStrings array of predicateString
     * @return the predicate user demanded
     * @throws IllegalValueException
     */
    private static Predicate<Person> processRatingPredicateStrings(String[] predicateStrings)
            throws IllegalValueException {
        List<Predicate<Person>> allPredicates = new ArrayList<Predicate<Person>>();
        for (String s: predicateStrings) {
            Predicate<Person> predicate = formRatingPredicateFromPredicateString(s);
            allPredicates.add(predicate);
        }
        return combineAllPredicates(allPredicates);
    }

    /**
     * Form a single predicate from a single predicate string
     * @param s a single predicate string
     * @return a single predicate
     * @throws IllegalValueException
     */
    private static Predicate<Person> formRatingPredicateFromPredicateString(String s)
            throws IllegalValueException {
        FilterRange<Rating> filterRange;
        if (s.contains("-")) { //It is a range
            String[] range = s.split("-");
            if (range.length != 2) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
            } else {
                double lowerRating = Rating.DEFAULT_SCORE;
                double higherRating = Rating.DEFAULT_SCORE;
                try {
                    lowerRating = Double.valueOf(range[0].trim());
                    higherRating = Double.valueOf(range[1].trim());
                } catch (NumberFormatException nfe) {
                    throw new IllegalValueException(Rating.MESSAGE_RATING_CONSTRAINTS);
                }
                if (Rating.isValidScore(lowerRating)
                        && Rating.isValidScore(higherRating)) {
                    filterRange = new FilterRange<Rating>(
                            new Rating(lowerRating, lowerRating, lowerRating, lowerRating),
                            new Rating(higherRating, higherRating, higherRating, higherRating));
                } else {
                    throw new IllegalValueException(Rating.MESSAGE_RATING_CONSTRAINTS);
                }
            }
        } else { //It is a value instead
            double exactRating = Rating.DEFAULT_SCORE;
            try {
                exactRating = Double.valueOf(s.trim());
            } catch (NumberFormatException nfe) {
                throw new IllegalValueException(Rating.MESSAGE_RATING_CONSTRAINTS);
            }
            if (Rating.isValidScore(exactRating)) {
                filterRange = new FilterRange<Rating>(new Rating(exactRating, exactRating, exactRating, exactRating));
            } else {
                throw new IllegalValueException(Rating.MESSAGE_RATING_CONSTRAINTS);
            }
        }
        Predicate<Person> predicate = new RatingInKeywordsRangePredicate(filterRange);
        return predicate;
    }

    /**
     * Parses a Optional of predicateString to a Predicate used to filter Person
     * @param predicateString a predicate string read from user input
     * @return a Predicate for filter command
     * @throws IllegalValueException
     */
    public static Predicate<Person> parseGradePointAverage(Optional<String> predicateString)
            throws IllegalValueException {
        requireNonNull(predicateString);
        if (predicateString.isPresent()) {
            return parseGradePointAverage(predicateString.get());
        } else {
            return null;
        }
    }

    /**
     * Parses a predicateString to a Predicate used to filter Person
     * @param predicateString a predicate string read from user input
     * @return a Predicate for filter command
     * @throws IllegalValueException
     */
    public static Predicate<Person> parseGradePointAverage(String predicateString)
            throws IllegalValueException {
        requireNonNull(predicateString);
        String[] predicateStrings = predicateString.split(",");
        Arrays.stream(predicateStrings).map(String::trim).toArray(unused -> predicateStrings);
        if (predicateStrings.length == 0) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
        }
        Predicate<Person> predicate = processGradePointAveragePredicateStrings(predicateStrings);
        return predicate;
    }

    /**
     * Parses the string array of all single predicate strings to a predicate
     * @param predicateStrings array of predicateString
     * @return the predicate user demanded
     * @throws IllegalValueException
     */
    private static Predicate<Person> processGradePointAveragePredicateStrings(String[] predicateStrings)
            throws IllegalValueException {
        List<Predicate<Person>> allPredicates = new ArrayList<Predicate<Person>>();
        for (String s: predicateStrings) {
            Predicate<Person> predicate = formGradePointAveragePredicateFromPredicateString(s);
            allPredicates.add(predicate);
        }
        return combineAllPredicates(allPredicates);
    }

    /**
     * Form a single predicate from a single predicate string
     * @param s a single predicate string
     * @return a single predicate
     * @throws IllegalValueException
     */
    private static Predicate<Person> formGradePointAveragePredicateFromPredicateString(String s)
            throws IllegalValueException {
        FilterRange<GradePointAverage> filterRange;
        if (s.contains("-")) { //It is a range
            String[] range = s.split("-");
            if (range.length != 2) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
            } else {
                try {
                    Double.valueOf(range[0].trim());
                    Double.valueOf(range[1].trim());
                } catch (NumberFormatException nfe) {
                    throw new IllegalValueException(GradePointAverage.MESSAGE_GRADE_POINT_AVERAGE_CONSTRAINTS);
                }
                if (GradePointAverage.isValidGradePointAverage(range[0].trim())
                        && GradePointAverage.isValidGradePointAverage(range[1].trim())) {
                    filterRange = new FilterRange<GradePointAverage>(
                            new GradePointAverage(range[0].trim()),
                            new GradePointAverage(range[1].trim()));
                } else {
                    throw new IllegalValueException(GradePointAverage.MESSAGE_GRADE_POINT_AVERAGE_CONSTRAINTS);
                }
            }
        } else { //It is a value instead
            try {
                Double.valueOf(s.trim());
            } catch (NumberFormatException nfe) {
                throw new IllegalValueException(GradePointAverage.MESSAGE_GRADE_POINT_AVERAGE_CONSTRAINTS);
            }
            if (GradePointAverage.isValidGradePointAverage(s.trim())) {
                filterRange = new FilterRange<GradePointAverage>(new GradePointAverage(s.trim()));
            } else {
                throw new IllegalValueException(GradePointAverage.MESSAGE_GRADE_POINT_AVERAGE_CONSTRAINTS);
            }
        }
        Predicate<Person> predicate = new GradePointAverageInKeywordsRangePredicate(filterRange);
        return predicate;
    }

    /**
     * Parses a Optional of  predicateString to a Predicate used to filter Person
     * @param predicateString a predicate string read from user input
     * @return a Predicate for filter command
     * @throws IllegalValueException
     */
    public static Predicate<Person> parseInterviewDate(Optional<String> predicateString)
            throws IllegalValueException {
        requireNonNull(predicateString);
        if (predicateString.isPresent()) {
            return parseInterviewDate(predicateString.get());
        } else {
            return null;
        }
    }

    /**
     * Parses a predicateString to a Predicate used to filter Person
     * @param predicateString a predicate string read from user input
     * @return a Predicate for filter command
     * @throws IllegalValueException
     */
    public static Predicate<Person> parseInterviewDate(String predicateString)
            throws IllegalValueException {
        requireNonNull(predicateString);
        String[] predicateStrings = predicateString.split(",");
        Arrays.stream(predicateStrings).map(String::trim).toArray(unused -> predicateStrings);
        if (predicateStrings.length == 0) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
        }
        Predicate<Person> predicate = processInterviewDatePredicateStrings(predicateStrings);
        return predicate;
    }

    /**
     * Parses the string array of all single predicate strings to a predicate
     * @param predicateStrings array of predicateString
     * @return the predicate user demanded
     * @throws IllegalValueException
     */
    private static Predicate<Person> processInterviewDatePredicateStrings(String[] predicateStrings)
            throws IllegalValueException {
        List<Predicate<Person>> allPredicates = new ArrayList<Predicate<Person>>();
        for (String s: predicateStrings) {
            Predicate<Person> predicate = formInterviewDatePredicateFromPredicateString(s);
            allPredicates.add(predicate);
        }
        return combineAllPredicates(allPredicates);
    }

    /**
     * Form a single predicate from a single predicate string
     * @param s a single predicate string
     * @return a single predicate
     * @throws IllegalValueException
     */
    private static Predicate<Person> formInterviewDatePredicateFromPredicateString(String s)
            throws IllegalValueException {
        FilterRange<InterviewDate> filterRange;
        if (s.contains("-")) { //It is a range
            String[] range = s.split("-");
            if (range.length != 2) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
            } else if (InterviewDateUtil.isValidInterviewDate(range[0].trim())
                    && InterviewDateUtil.isValidInterviewDate(range[1].trim())) {
                try {
                    filterRange = new FilterRange<InterviewDate>(
                            new InterviewDate(InterviewDateUtil.formLowerInterviewDateTime(range[0].trim())),
                            new InterviewDate(InterviewDateUtil.formHigherInterviewDateTime(range[1].trim())));
                } catch (DateTimeParseException dtpe) {
                    throw new ParseException(InterviewDateUtil.MESSAGE_INTERVIEW_DATE_CONSTRAINT);
                }
            } else {
                throw new IllegalValueException(InterviewDateUtil.MESSAGE_INTERVIEW_DATE_CONSTRAINT);
            }

        } else { //It is a value instead
            if (InterviewDateUtil.isValidInterviewDate(s.trim())) {
                try {
                    filterRange = new FilterRange<InterviewDate>(
                            new InterviewDate(InterviewDateUtil.formLowerInterviewDateTime(s.trim())),
                            new InterviewDate(InterviewDateUtil.formHigherInterviewDateTime(s.trim())));
                } catch (DateTimeParseException dtpe) {
                    throw new ParseException(InterviewDateUtil.MESSAGE_INTERVIEW_DATE_CONSTRAINT);
                }
            } else {
                throw new IllegalValueException(InterviewDateUtil.MESSAGE_INTERVIEW_DATE_CONSTRAINT);
            }
        }
        Predicate<Person> predicate = new InterviewDateInKeywordsRangePredicate(filterRange);
        return predicate;
    }

}
```
###### /java/seedu/address/logic/parser/StatusCommandParser.java
``` java
/**
 * Parses input arguments and creates a new StatusCommand object
 */
public class StatusCommandParser implements Parser<StatusCommand> {
    /**
     * Parses the given {@code String} of arguments in the context of the StatusCommand
     * and returns an StatusCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public StatusCommand parse(String args) throws ParseException {
        try {
            // Parse the arguments
            String[] arguments = args.trim().split("\\s+", 2);
            if (arguments.length != 2) {
                throw new IllegalValueException("Invalid command, expected 2 arguments");
            }
            // Parse the index
            Index index = ParserUtil.parseIndex(arguments[0]);

            // Parse the status
            int statusIndex = Integer.valueOf(arguments[1]);
            Status status = null;
            if (Status.isValidStatus(statusIndex)) {
                status = new Status(statusIndex);
            } else {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, StatusCommand.MESSAGE_USAGE));
            }

            return new StatusCommand(index, status);

        } catch (NumberFormatException nfe) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, StatusCommand.MESSAGE_USAGE));
        } catch (ParseException pe) {
            throw pe;

        } catch (IllegalValueException ive) {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, StatusCommand.MESSAGE_USAGE));
        }
    }
}
```
###### /java/seedu/address/logic/parser/FilterRange.java
``` java
/**
 * A range recorder for PredicateParsing
 * @param <E> a filterable field
 */
public class FilterRange<E> {
    private boolean isRange;
    private E lowValue;
    private E highValue;
    private E exactValue;
    public FilterRange(E exactValue) {
        this.isRange = false;
        this.lowValue = null;
        this.highValue = null;
        this.exactValue = exactValue;
    }

    public FilterRange(E lowValue, E highValue) {
        this.isRange = true;
        this.lowValue = lowValue;
        this.highValue = highValue;
        this.exactValue = null;
    }

    public boolean isRange() {
        return isRange;
    }

    public E getExactValue() {
        assert(!isRange);
        return exactValue;
    }

    public E getLowValue() {
        assert(isRange);
        return lowValue;
    }

    public E getHighValue() {
        assert(isRange);
        return highValue;
    }
}
```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
    /**
     * Parses a {@code String expectedGraduationYear} into an {@code ExpectedGraduationYear}.
     * Leading and trailing whitespaces will be trimmed.
     *
     * @throws IllegalValueException if given {@code expectedGraduationYear} is invalid.
     */
    public static ExpectedGraduationYear parseExpectedGraduationYear(String expectedGraduationYear)
            throws IllegalValueException {
        requireNonNull(expectedGraduationYear);
        String trimmedExpectedGraduationYear = expectedGraduationYear.trim();
        if (!ExpectedGraduationYear.isValidExpectedGraduationYear(trimmedExpectedGraduationYear)) {
            throw new IllegalValueException(ExpectedGraduationYear.MESSAGE_EXPECTED_GRADUATION_YEAR_CONSTRAINTS);
        }
        return new ExpectedGraduationYear(trimmedExpectedGraduationYear);
    }
    /**
     * Parses a {@code Optional<String> expectedGraduationYear}
     * into an {@code Optional<ExpectedGraduationYear>} if {@code expectedGraduationYear} is present.
     * See header comment of this class regarding the use of {@code Optional} parameters.
     */
    public static Optional<ExpectedGraduationYear> parseExpectedGraduationYear(Optional<String> expectedGraduationYear)
            throws IllegalValueException {
        requireNonNull(expectedGraduationYear);
        return expectedGraduationYear.isPresent() ? Optional.of(parseExpectedGraduationYear(
                expectedGraduationYear.get())) : Optional.empty();
    }

```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
    /**
     * Parses a {@code String resume} into an {@code Resume}.
     * Leading and trailing whitespaces will be trimmed.
     *
     * @throws IllegalValueException if the given {@code resume} is invalid.
     */
    public static Resume parseResume(String resume) throws IllegalValueException {
        requireNonNull(resume);
        String trimmedResume = resume.trim();
        if (!Resume.isValidResume(trimmedResume)) {
            throw new IllegalValueException(Resume.MESSAGE_RESUME_CONSTRAINTS);
        }
        return new Resume(trimmedResume);
    }

    /**
     * Parses a {@code Optional<String> resume} into an {@code Optional<Resume>} if {@code resume} is present.
     * See header comment of this class regarding the use of {@code Optional} parameters.
     */
    public static Optional<Resume> parseResume(Optional<String> resume) throws IllegalValueException {
        requireNonNull(resume);
        return resume.isPresent() ? Optional.of(parseResume(resume.get())) : Optional.empty();
    }

```
###### /java/seedu/address/logic/parser/EditCommandParser.java
``` java
    /**
     * Parses {@code Optional<Resume> resume} into a {@code Optional<Resume>} if {@code resume} is non-empty.
     * If resume is present and equals to empty string, it will be parsed into a
     * {@code Resume} containing null value.
     */
    private Optional<Resume> parseResumeForEdit(Optional<String> resume) throws IllegalValueException {
        assert resume != null;
        if (!resume.isPresent()) {
            return Optional.empty();
        }
        if (resume.get().equals("")) {
            return Optional.of(new Resume(null));
        } else {
            return ParserUtil.parseResume(resume);
        }
    }

```
###### /java/seedu/address/logic/parser/FilterCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FilterCommand object
 */
public class FilterCommandParser implements Parser<FilterCommand> {
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public FilterCommand parse(String args) throws ParseException {
        ArgumentMultimap argMultimap =
                ArgumentTokenizer.tokenize(args, PREFIX_EXPECTED_GRADUATION_YEAR, PREFIX_RATING,
                        PREFIX_GRADE_POINT_AVERAGE, PREFIX_INTERVIEW_DATE);

        if (!isValidFilterCommandInput(argMultimap,
                PREFIX_EXPECTED_GRADUATION_YEAR, PREFIX_RATING, PREFIX_GRADE_POINT_AVERAGE, PREFIX_INTERVIEW_DATE)
                || !argMultimap.getPreamble().isEmpty()) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
        }

        try {
            Predicate<Person> expectedGraduationYearPredicate = FilterUtil.parseExpectedGraduationYear(argMultimap
                    .getValue(PREFIX_EXPECTED_GRADUATION_YEAR));
            Predicate<Person> ratingPredicate = FilterUtil.parseRating(argMultimap.getValue(PREFIX_RATING));
            Predicate<Person> gpaPredicate =
                    FilterUtil.parseGradePointAverage(argMultimap.getValue(PREFIX_GRADE_POINT_AVERAGE));
            Predicate<Person> interviewDatePredicate =
                    FilterUtil.parseInterviewDate(argMultimap.getValue(PREFIX_INTERVIEW_DATE));
            // combine all predicates together using and
            Predicate<Person> combinedPredicate = combinePredicate(expectedGraduationYearPredicate,
                    ratingPredicate, gpaPredicate, interviewDatePredicate);
            return new FilterCommand(combinedPredicate);
        } catch (ParseException pe) {
            throw pe;
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }

    /**
     * checks whether the user input is of the correct format in the sense that it contains at least 1 prefix
     * @param argumentMultimap Parsed user input
     * @param prefixes Supported prefixes
     * @return whether the input is valid
     */
    private boolean isValidFilterCommandInput(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        boolean hasAnyPrefixes = false;
        for (Prefix p: prefixes) {
            if (arePrefixesPresent(argumentMultimap, p)) {
                hasAnyPrefixes = true;
                break;
            }
        }
        return hasAnyPrefixes;
    }

    /**
     * combines all the predicate into one predicate AND-connected
     * @param predicates all the predicates to be combined
     * @return a single predicate
     */
    private Predicate<Person> combinePredicate(Predicate<Person>... predicates) {
        Predicate<Person> combinedPredicate = null;
        for (Predicate<Person> p: predicates) {
            if (p != null) {
                if (combinedPredicate == null) {
                    combinedPredicate = p;
                } else {
                    combinedPredicate = combinedPredicate.and(p);
                }
            }
        }
        return combinedPredicate;
    }

    /**
     * Returns true if none of the prefixes contains empty {@code Optional} values in the given
     * {@code ArgumentMultimap}.
     */
    private static boolean arePrefixesPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        return Stream.of(prefixes).allMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }
}
```
